<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | 猫·仁波切]]></title>
  <link href="http://andelf.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://andelf.github.io/"/>
  <updated>2017-02-13T22:05:35+08:00</updated>
  <id>http://andelf.github.io/</id>
  <author>
    <name><![CDATA[猫·仁波切 (Feather)]]></name>
    <email><![CDATA[andelf@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在 CircleCI 上使用 Rust(CircleCI Meets Rust)]]></title>
    <link href="http://andelf.github.io/blog/2016/11/18/circleci-meets-rust/"/>
    <updated>2016-11-18T13:26:15+08:00</updated>
    <id>http://andelf.github.io/blog/2016/11/18/circleci-meets-rust</id>
    <content type="html"><![CDATA[<p>最近由于频频遇到 travis-ci 的问题，主要是 Linux 资源排队、macOS 资源更需要排队，导致自动测试时间被拉长，
影响开发效率。</p>

<p>了解到 CircleCI 是不错的替代品，所以打算迁移 Rust 项目过去。当然说起来， CircleCI 的野心更大，是要来替代 jenkins 的。</p>

<p>目前官方支持语言其实都比较落后，包括 go 也只是 1.6 版本，但似乎不是问题，而且据介绍， CircleCI 2.0 支持自定义 build image，支持语言的版本当然不在话下。</p>

<p>每天面对各种 IaaS, PaaS，免不了写配置是，这也是 yaml 程序员的日常。</p>

<pre><code class="yaml">dependencies:
  pre:
    - curl https://sh.rustup.rs -sSf | sh

test:
  override:
    - cargo build
    - cargo test
</code></pre>

<p>如上。然而不 work。报错：</p>

<pre><code>cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: spurious network error (2 tries remaining): [12/-12] Malformed URL 'ssh://git@github.com:/rust-lang/crates.io-index'
warning: spurious network error (1 tries remaining): [12/-12] Malformed URL 'ssh://git@github.com:/rust-lang/crates.io-index'
error: failed to fetch `https://github.com/rust-lang/crates.io-index`

To learn more, run the command again with --verbose.

cargo build returned exit code 101

Action failed: cargo build
</code></pre>

<p>神了。原来， CircleCI 自作聪明在 <code>.gitconfig</code> 里修改了映射配置，强制用它自己的 ssh key 去访问 github，rewrite 了 <code>https://github.com</code> 的所有仓库。
这恰恰和 cargo 的 registry 机制冲突。所以报错。</p>

<blockquote><p>CircleCI has rewrite <code>https:://github.com</code> to <code>ssh://git@github.com:</code> in <code>.gitconfig</code>. And this made cargo fail with above error message.</p></blockquote>

<p>找到了原因，就可以搞了：</p>

<pre><code class="yaml">machine:
  pre:
    - sed -i 's/github/git-non-exist-hub/g' ~/.gitconfig

dependencies:
  pre:
    - curl https://sh.rustup.rs -sSf | sh

test:
  override:
    - cargo build
    - cargo test
</code></pre>

<p>嗯, Ugly but works.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust Pattern Match(Rust中的模式匹配)]]></title>
    <link href="http://andelf.github.io/blog/2016/03/22/rust-pattern-match/"/>
    <updated>2016-03-22T23:35:19+08:00</updated>
    <id>http://andelf.github.io/blog/2016/03/22/rust-pattern-match</id>
    <content type="html"><![CDATA[<h1>模式匹配</h1>

<p>汉语字典中对“模式”的解释是：事物的标准样式。在计算机科学中，它指特定类型的数据（往往是序列或是树形结构）满足某一特定结构或格式。“匹配”本身是指一个判断寻找过程。最早的模式匹配用于文本编辑器中的正则字符串搜索，之后才作为编程语言特性。</p>

<h2>模式匹配基础</h2>

<p>模式匹配在计算机科学领域有两层意思。其一，可以特指字符串匹配算法，例如为人熟知的 KMP 字符串匹配算法、命令行工具 grep 等。
其二，特指在一些语言中作为一种以结构的方式处理数据的工具，此时的匹配过程往往是树形匹配，与此相伴的往往还有一个特性叫 guard（守卫）。</p>

<p>Rust 中模式匹配随处可见，例如在<code>let</code>变量绑定语句、<code>match</code>匹配语句中等。利用好模式匹配这一特性可以使代码更简洁易懂。<code>Rust</code>支持模式匹配中的变量绑定、结构体/元组解构、守卫条件判断、数值范围匹配等特性。</p>

<h3>原始匹配</h3>

<p><code>match</code> 语句中可以直接匹配字面常量，下划线<code>_</code>匹配任意情形。</p>

<pre><code class="rust">let x = 1;

match x {
    1 =&gt; println!("one"),
    2 =&gt; println!("two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}
</code></pre>

<p>以上代码会打印出<code>one</code>。</p>

<h3>结构匹配</h3>

<p><code>match</code> 用于匹配一个表达式的值，寻找满足条件的子分支(<code>arm</code>)并执行。每个子分支包含三部分：一系列模式、可选的守卫条件以及主体代码块。</p>

<h3>多个模式</h3>

<p>每个子分支可以是多个模式，通过 <code>|</code> 符号分割：</p>

<pre><code class="rust">let x = 1;

match x {
    1 | 2 =&gt; println!("one or two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}
</code></pre>

<p>以上代码打印出<code>one or two</code>。</p>

<h3>守卫条件</h3>

<p>通过<code>if</code>引入子分支的守卫条件：</p>

<pre><code class="rust">enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!("Got an int bigger than five!"),
    OptionalInt::Value(..) =&gt; println!("Got an int!"),
    OptionalInt::Missing =&gt; println!("No such luck."),
}
</code></pre>

<h2>模式匹配进阶</h2>

<p>其实进阶，不如直接从<code>libsyntax</code>源码看看到底模式匹配是如何实现。<code>syntax::ast::Pat</code>。</p>

<p>从AST源码中寻找语法要素屋外户两个要点，其一，语法要素是如何表达为对应AST的；其二，对应AST在哪些父AST中出现。</p>

<p>Rust中使用<code>syntax::ast::Pat</code>枚举来表示一个模式匹配。</p>

<pre><code class="rust">pub struct Pat {
    pub id: NodeId,
    pub node: PatKind,
    pub span: Span,
}

pub enum PatKind {
    /// Represents a wildcard pattern (`_`)
    /// 表示通配，下划线
    Wild,

    /// A `PatKind::Ident` may either be a new bound variable,
    /// or a unit struct/variant pattern, or a const pattern (in the last two cases
    /// the third field must be `None`).
    ///
    /// In the unit or const pattern case, the parser can't determine
    /// which it is. The resolver determines this, and
    /// records this pattern's `NodeId` in an auxiliary
    /// set (of "PatIdents that refer to unit patterns or constants").
    Ident(BindingMode, SpannedIdent, Option&lt;P&lt;Pat&gt;&gt;),

    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.
    /// The `bool` is `true` in the presence of a `..`.
    Struct(Path, Vec&lt;Spanned&lt;FieldPat&gt;&gt;, bool),

    /// A tuple struct/variant pattern `Variant(x, y, z)`.
    /// "None" means a `Variant(..)` pattern where we don't bind the fields to names.
    TupleStruct(Path, Option&lt;Vec&lt;P&lt;Pat&gt;&gt;&gt;),

    /// A path pattern.
    /// Such pattern can be resolved to a unit struct/variant or a constant.
    Path(Path),

    /// An associated const named using the qualified path `&lt;T&gt;::CONST` or
    /// `&lt;T as Trait&gt;::CONST`. Associated consts from inherent impls can be
    /// referred to as simply `T::CONST`, in which case they will end up as
    /// PatKind::Path, and the resolver will have to sort that out.
    QPath(QSelf, Path),

    /// A tuple pattern `(a, b)`
    Tup(Vec&lt;P&lt;Pat&gt;&gt;),
    /// A `box` pattern
    Box(P&lt;Pat&gt;),
    /// A reference pattern, e.g. `&amp;mut (a, b)`
    Ref(P&lt;Pat&gt;, Mutability),
    /// A literal
    Lit(P&lt;Expr&gt;),
    /// A range pattern, e.g. `1...2`
    Range(P&lt;Expr&gt;, P&lt;Expr&gt;),
    /// `[a, b, ..i, y, z]` is represented as:
    ///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`
    Vec(Vec&lt;P&lt;Pat&gt;&gt;, Option&lt;P&lt;Pat&gt;&gt;, Vec&lt;P&lt;Pat&gt;&gt;),
    /// A macro pattern; pre-expansion
    Mac(Mac),
}
</code></pre>

<p>以上AST定义，即说明，到底什么被认为是一个“模式”。</p>

<p>以下介绍<code>Pat</code>在哪些AST中出现。</p>

<h3>全局 Item</h3>

<p>全局 Item 中，使用模式匹配的均为函数参数。</p>

<h4>ItemKind::Fn</h4>

<p><code>Fn</code> 全局函数 -> <code>FnDecl</code> 函数声明 -> <code>[Arg]</code> 函数头参数声明。</p>

<h4>ItemKind::Trait</h4>

<p><code>Trait</code> -> <code>[TraitItem]</code> -> <code>TraitItemKind::Method</code> -> <code>MethodSig</code> -> <code>FnDecl</code> 方法声明，同上。</p>

<h4>ItemKind::Impl</h4>

<p><code>Impl</code> -> <code>[ImplItem]</code> -> <code>ImplItemKind::Method</code> -> <code>MethodSig</code> -> <code>FnDecl</code>。</p>

<h3>ast::Stmt 语句</h3>

<h4>StmtKind::Decl</h4>

<p><code>Decl</code> -> <code>DeclKind::Local</code>。</p>

<p>即 <code>let</code> 语句 <code>let &lt;pat&gt;:&lt;ty&gt; = &lt;expr&gt;;</code>。</p>

<h4>StmtKind::Expr 表达式</h4>

<p>见下。</p>

<h3>ast::Expr</h3>

<p>除<code>match</code>外，<code>if let</code>、<code>while let</code>、<code>for</code>控制语句支持同时进行模式匹配。具体实现是一种<code>desugared</code>过程，即，去语法糖化。</p>

<p>同时类似于函数定义，闭包参数也支持模式匹配。</p>

<h4>if let</h4>

<p><code>IfLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;P&lt;Expr&gt;&gt;)</code></p>

<p><code>if let pat = expr { block } else { expr }</code></p>

<p>This is desugared to a match expression.</p>

<h4>while let</h4>

<p><code>WhileLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code>'label: while let pat = expr { block }</code></p>

<h4>for</h4>

<p><code>ForLoop(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code>'label: for pat in expr { block }</code></p>

<h4>match</h4>

<p><code>Match(P&lt;Expr&gt;, Vec&lt;Arm&gt;)</code></p>

<p><code>match</code> 语句，在 <code>Arm</code> 中出现，其中 <code>Arm</code> 定义为</p>

<pre><code>pub struct Arm {
    pub attrs: Vec&lt;Attribute&gt;,
    pub pats: Vec&lt;P&lt;Pat&gt;&gt;,
    pub guard: Option&lt;P&lt;Expr&gt;&gt;,
    pub body: P&lt;Expr&gt;,
}
</code></pre>

<h4>闭包</h4>

<p><code>Closure(CaptureBy, P&lt;FnDecl&gt;, P&lt;Block&gt;)</code></p>

<p>闭包，例如 <code>move |a, b, c| {a + b + c}</code>。</p>

<h2>相关 feature gate</h2>

<p><code>advanced_slice_patterns</code> - See the match expressions section for discussion; the exact semantics of slice patterns are subject to change, so some types are still unstable.</p>

<p><code>slice_patterns</code> - OK, actually, slice patterns are just scary and completely unstable.</p>

<p><code>box_patterns</code> - Allows box patterns, the exact semantics of which is subject to change.</p>

<h2>参考</h2>

<p><a href="https://doc.rust-lang.org/book/patterns.html">https://doc.rust-lang.org/book/patterns.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust Tips]]></title>
    <link href="http://andelf.github.io/blog/2014/05/15/rust-tips/"/>
    <updated>2014-05-15T11:08:59+08:00</updated>
    <id>http://andelf.github.io/blog/2014/05/15/rust-tips</id>
    <content type="html"><![CDATA[<h2>extern crate</h2>

<pre><code class="rust">extern crate sdl2 = "github.com/andelf/rust-sdl2";
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Rustdoc Plugin]]></title>
    <link href="http://andelf.github.io/blog/2014/04/29/a-rustdoc-plugin/"/>
    <updated>2014-04-29T02:26:48+08:00</updated>
    <id>http://andelf.github.io/blog/2014/04/29/a-rustdoc-plugin</id>
    <content type="html"><![CDATA[<p>Run with</p>

<pre><code>rustdoc -L. --plugin-path . --plugins dummy rust-sdl2/src/sdl2/lib.rs
</code></pre>

<pre><code class="rust">#![crate_id = "dummy#0.1"]
#![crate_type = "dylib"]


extern crate rustdoc;

use rustdoc::clean;

use rustdoc::plugins::{PluginCallback, PluginResult, PluginJson};

#[no_mangle]
pub fn rustdoc_plugin_entrypoint(c: clean::Crate) -&gt; PluginResult {
    println!("loading extension ok!");
    println!("crate =&gt; {}", c.name);
    (c, None)
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust Tokenizer]]></title>
    <link href="http://andelf.github.io/blog/2014/04/29/rust-tokenizer/"/>
    <updated>2014-04-29T01:06:38+08:00</updated>
    <id>http://andelf.github.io/blog/2014/04/29/rust-tokenizer</id>
    <content type="html"><![CDATA[<p>A rust tokenizer from rust standard library.</p>

<pre><code class="rust">extern crate syntax;

use syntax::parse;
use syntax::ast;

fn main() {
    let sess = parse::new_parse_sess();
    let cfg = Vec::new();
    let mut p = parse::new_parser_from_file(&amp;sess, cfg, &amp;Path::new("./mytest.rs"));
    while p.token != parse::token::EOF {
        p.bump();
        println!("debug =&gt; {}", parse::token::to_str(&amp;p.token));
    }
}
</code></pre>

<p>DONE!</p>

<p><code>p.parse_token_tree()</code> will return a <code>TokenTree</code>, which is a nested
token list.</p>
]]></content>
  </entry>
  
</feed>
