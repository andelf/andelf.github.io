<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 猫·仁波切]]></title>
  <link href="http://andelf.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://andelf.github.io/"/>
  <updated>2016-03-22T23:28:16+08:00</updated>
  <id>http://andelf.github.io/</id>
  <author>
    <name><![CDATA[猫·仁波切 (Feather)]]></name>
    <email><![CDATA[andelf@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift 2.0 的错误处理(Swift 2.0 Error Handling)]]></title>
    <link href="http://andelf.github.io/blog/2015/06/09/swift-2-dot-0-error-handling/"/>
    <updated>2015-06-09T15:27:58+08:00</updated>
    <id>http://andelf.github.io/blog/2015/06/09/swift-2-dot-0-error-handling</id>
    <content type="html"><![CDATA[<pre><code>protocol ErrorType {
  var _domain: String { get }
  var _code: Int { get }
}

@asmname("swift_bridgeErrorTypeToNSError") func _bridgeErrorTypeToNSError(e: ErrorType) -&gt; AnyObject

@asmname("swift_stdlib_getErrorCode") func _stdlib_getErrorCode&lt;T : ErrorType&gt;(x: UnsafePointer&lt;T&gt;) -&gt; Int

@asmname("swift_stdlib_getErrorDomainNSString") func _stdlib_getErrorDomainNSString&lt;T : ErrorType&gt;(x: UnsafePointer&lt;T&gt;) -&gt; AnyObject
</code></pre>

<h2>Foundation</h2>

<pre><code>protocol _ObjectiveCBridgeableErrorType : ErrorType {
  init?(_bridgedNSError: NSError)
}

struct NSCocoaError : RawRepresentable, _BridgedNSError, _ObjectiveCBridgeableErrorType, ErrorType, __BridgedNSError, Hashable, Equatable {
  let rawValue: Int
  init(rawValue: Int)
  static var _NSErrorDomain: String {
    get {}
  }
  typealias RawValue = Int
}


infix func ==(a: _GenericObjCError, b: _GenericObjCError) -&gt; Bool
infix func ==(a: _GenericObjCError, b: _GenericObjCError) -&gt; Bool
func ==&lt;T : __BridgedNSError where T.RawValue : SignedIntegerType&gt;(lhs: T, rhs: T) -&gt; Bool

@available(OSX 10.11, iOS 9.0, *)
func resolveError(error: NSError?) throws

enum _GenericObjCError : ErrorType {
  case NilError
  var hashValue: Int {
    get {}
  }
  var _domain: String {
    get {}
  }
  var _code: Int {
    get {}
  }
}

@asmname("swift_stdlib_bridgeNSErrorToErrorType")
func _stdlib_bridgeNSErrorToErrorType&lt;T : _ObjectiveCBridgeableErrorType&gt;(error: NSError, out: UnsafeMutablePointer&lt;T&gt;) -&gt; Bool

@asmname("swift_convertNSErrorToErrorType") func _convertNSErrorToErrorType(error: NSError?) -&gt; ErrorType

@objc enum NSURLError : Int, _BridgedNSError, _ObjectiveCBridgeableErrorType, ErrorType, __BridgedNSError { ... }


protocol __BridgedNSError : RawRepresentable {
  static var _NSErrorDomain: String { get }
}
@asmname("swift_convertErrorTypeToNSError") func _convertErrorTypeToNSError(error: ErrorType) -&gt; NSError
func ~=(match: NSCocoaError, error: ErrorType) -&gt; Bool
protocol _BridgedNSError : __BridgedNSError, _ObjectiveCBridgeableErrorType, Hashable {
  static var _NSErrorDomain: String { get }
}
</code></pre>

<p>ErrorType 在 Swift 中表示。</p>

<pre><code>extension NSError : ErrorType {
  @objc dynamic var _domain: String {
    @objc dynamic get {}
  }
  @objc dynamic var _code: Int {
    @objc dynamic get {}
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为第三方扩展创建 Swift 模块]]></title>
    <link href="http://andelf.github.io/blog/2015/01/23/swift-3rd-library-install-as-swift-modules/"/>
    <updated>2015-01-23T23:21:00+08:00</updated>
    <id>http://andelf.github.io/blog/2015/01/23/swift-3rd-library-install-as-swift-modules</id>
    <content type="html"><![CDATA[<p>本文提出了一种将第三方扩展引入到 Swift 标准库的方法。</p>

<p>以 Alamofire 为例，</p>

<pre><code>cd Path-To-Alamofire-Src-Dir
mkdir -p 32 64

# 创建动态链接库，及对应 Swift 模块，32/64版本
xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphoneos) Alamofire.swift -target arm64-apple-ios7.1 -target-cpu cyclone -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib

mv Alamofire.swiftdoc Alamofire.swiftmodule libswiftAlamofire.dylib ./64

xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphoneos) Alamofire.swift -target armv7-apple-ios7.1 -target-cpu cyclone -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib

mv Alamofire.swiftdoc Alamofire.swiftmodule libswiftAlamofire.dylib ./64

# 创建 universal lib
lipo -create ./{32,64}/libswiftAlamofire.dylib  -output ./libswiftAlamofire.dylib

# 创建模拟器用 lib
xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphonesimulator) Alamofire.swift -target i386-apple-ios7.1 -target-cpu yonah -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib
</code></pre>

<p>其他相关 target
<code>
-target armv7-apple-ios7.1 -target-cpu cortex-a8
-target arm64-apple-ios7.1 -target-cpu cyclone
-target i386-apple-ios7.1 -target-cpu yonah
-target x86_64-apple-ios7.1 -target-cpu core2
</code></p>

<p>其实你了解 Swift 模块结构的化，应该回想到，将第三方模块创建为 swiftmodule 应该是最靠谱的选择。不过实际操作发现，
编译命令无法很方便地调整，主要是因为 xcodebuild 系统，和编译命令不知道怎么导出。也是略纠结。</p>

<p>实际上，如果使用 Carthage 的话，即把第三方扩展作为 Framework 引入，会导致无法支持 iOS 7，但是 Swift 本身是支持 iOS 7 的，
在编译命令和生成的文件中检查发现，对于 iOS 7，Swift 使用了纯静态模块编译的方法。所以其实我们引入第三方扩展的时候也可以这样做。</p>

<p>以下是静态编译所需命令：</p>

<pre><code>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) SwiftyJSON.swift -c -parse-as-library -module-name SwiftyJSON -v -o SwiftyJSON.o

ar rvs libswiftSwiftyJSON.a SwiftyJSON.o
</code></pre>

<p>如何使用？</p>

<p>将编译结果扔到：</p>

<pre><code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift_static
</code></pre>

<p>下对应目录。</p>

<p>然后在 Xcode 里，直接 import。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Beta3 Changes ( Swift 在 Beta3 中的变化）]]></title>
    <link href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/"/>
    <updated>2014-07-08T17:22:11+08:00</updated>
    <id>http://andelf.github.io/blog/2014/07/08/swift-beta3-changes</id>
    <content type="html"><![CDATA[<p>准确说是 beta2 <code>Swift version 1.0 (swift-600.0.34.4.8)</code> 到 beta3 <code>Swift version 1.0 (swift-600.0.38.7)</code> 的变化。</p>

<p>对了，补充下。 beta1 <code>Swift version 1.0 (swift-600.0.34.4.5)</code> 到 beta2 几乎没有什么变化。</p>

<h2>语法</h2>

<p><code>nil</code> 成为关键字。</p>

<p><code>[KeyType : ValueType]</code> 可以表示字典类型 <code>Dictionary&lt;KeyType, ValueType&gt;</code>。</p>

<p><code>[Type]</code> 用于表示原 Array 类型 <code>Type[]</code>，等价 <code>Array&lt;T&gt;</code>，原用法会导致警告。</p>

<p><del>增加 @noinline 属性</del></p>

<p><code>..</code> 运算符改为 <code>..&lt;</code>，不容易和 <code>...</code> 混淆。</p>

<h2>函数、类型</h2>

<p>原 <code>sort()</code> 改名为 <code>sorted()</code>。新增 <code>sort()</code> 函数，参数为 <code>inout</code>。</p>

<p>Index 类型中的 <code>.succ()</code> 变为 <code>.successor()</code>、 <code>.pred()</code> 变为 <code>.predecessor()</code>。</p>

<h2>C/ObjC 交互变化</h2>

<p>增加 <code>UnsafeMutableArray&lt;T&gt;</code> 类型。</p>

<p>增加 <code>CFunctionPointer&lt;T&gt;</code> 类型。</p>

<p>删除 <code>CConstVoidPointer</code>、 <code>CMutableVoidPointer</code>。替换为 <code>UnsafePointer&lt;()&gt;</code>、<code>ConstUnsafePointer&lt;Int32&gt;</code>。</p>

<p>删除 <code>CConstPointer&lt;T&gt;</code>、<code>CMutablePointer&lt;T&gt;</code>。替换为 <code>UnsafePointer&lt;T&gt;</code>、<code>ConstUnsafePointer&lt;T&gt;</code>。</p>

<p>这么一来指针操作简单了好多。原有会出现 <code>COpaquePointer</code> 的不合理情况，也都对应到适合的类型。</p>

<p><code>CString</code> 可以从 <code>UnsafePointer&lt;UInt8&gt;</code> 和 <code>UnsafePointer&lt;CChar&gt;</code> 两种类型构造获得，之前只支持 <code>UInt8</code>。</p>

<p>module.map 中头文件声明转换为 Swift 声明不再使用 C 兼容类型，直接使用 Swift 相应类型。原有 <code>CInt</code>，现在成为 <code>Int32</code>。</p>

<p>结构体会自动添加构造函数 <code>init(field1:field2:...)</code> 这样。</p>

<h3>nil</h3>

<p>去掉了 <code>NilType</code>，增加了 <code>NilLiteralConvertible</code>， <code>nil</code> 成为关键字。可以认为是 nil 常量。</p>

<pre><code>protocol NilLiteralConvertible {
  class func convertFromNilLiteral() -&gt; Self
}
</code></pre>

<p>除了 Optional 、上面所提到的指针类型外，<code>RawOptionSet</code> 也实现了该协议。</p>

<h3>Array</h3>

<p>去掉了 <code>.copy()</code>、<code>unshare()</code> 方法。</p>

<p>增加了以下方法：</p>

<pre><code>func makeUnique(inout buffer: ArrayBuffer&lt;T&gt;, e: T, index: Int)
func sorted(isOrderedBefore: (T, T) -&gt; Bool) -&gt; Array&lt;T&gt;
</code></pre>

<p>看起来 <code>Array</code> 对底层容器的引用有了更好的控制 <code>ArrayBufferType</code> 增加了判断方法 <code>func isMutableAndUniquelyReferenced() -&gt; Bool</code>。</p>

<p>Array 目前可以认为是真正的值类型。</p>

<h3>指针</h3>

<h4>增加了 <code>_Pointer</code> protocol</h4>

<pre><code class="scala">protocol _Pointer {
  var value: RawPointer { get }
  init(_ value: RawPointer)
}
</code></pre>

<p>表示一个类型可以对应到原生指针。</p>

<p>同时成为内部桥接类型，编译器内部在转换时使用它（取出 RawPointer, 构造具体指针类型）。</p>

<h2>模块</h2>

<p>增加了  StdlibUnittest 模块。 <a href="https://github.com/andelf/Defines-Swift/blob/79ed8d40659e4d038f41e3c30b4b3358106bd50a/StdlibUnittest.swift">声明代码</a>。单元测试终于有了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Swift Dynamic Framework （如何科学地引用第三方 Swift 库)]]></title>
    <link href="http://andelf.github.io/blog/2014/07/07/use-swift-dynamic-library/"/>
    <updated>2014-07-07T12:09:54+08:00</updated>
    <id>http://andelf.github.io/blog/2014/07/07/use-swift-dynamic-library</id>
    <content type="html"><![CDATA[<p>排名 16 了。啧啧。你看才刚出一个月。</p>

<p>目前已经有了很多非常棒的 Swift 第三方库， JSON 处理啊、 HTTP 访问啊、 UIView 插件啊等等。</p>

<p>如何科学地引用这些第三方库呢？</p>

<h2>现状</h2>

<p>CocoaPods 由于完全使用静态链接解决方法，过度依赖 Objective-C ，目前应该是官方 repo 有提到是 <code>-Xlinker</code> error , 这个问题之前我也遇到过，无解。除非手工执行 <code>ar</code> 不用 <code>ld</code> 和 <code>libtool</code>。</p>

<p>小伙伴有用子目录的方法引用代码，貌似不错，还有就是直接用 <code>git submodule</code>，看起来维护性也可以。</p>

<h2>简单解决方案</h2>

<p>一个良好的第三方库应该实现为 Cocoa Touch Framework (实际内容为 Header + 动态链接库)。而不是直接把 Swift 代码 Copy 过来放入自己的项目。这里以一个简单项目为例，介绍如何科学使用。</p>

<h3>目标描述</h3>

<p>用 Swift 创建一个 Demo ，使用 SwiftyJSON 和 LTMorphingLabel 库。</p>

<p>项目的名字叫 DemoApp 。</p>

<h4>创建 Workspace</h4>

<p>创建一个 Workspace ，名字随意，位置能找到就好。这个 Workspace 主要用来管理我们的项目及其依赖的第三方库。</p>

<h4>创建 DemoApp</h4>

<p>在 Workspace 创建一个 App ，因为是测试所以我选了 Single View Application 。</p>

<h4>引入 SwiftyJSON</h4>

<p>SwiftyJSON 是一个 Cocoa Touch Framework ，可以直接使用， <code>git clone</code> 后，添加项目到 Workspace 即可。</p>

<p>尝试操作发现。。最容易最不会出错的方法就是直接从 Finder 里把 <code>.xcodeproj</code> 文件拖动到 Workspace 。</p>

<h4>引入 LTMorphingLabel</h4>

<p>LTMorphingLabel 是一个 App Deme 式项目。其中 Label View 的实现在一个子目录中。可以采用创建 Cocoa
Touch Framework 的方法来引入这几个文件。</p>

<p>当然也可以直接把目录拖到我们的 DemoApp 里，不过太原始粗暴了。</p>

<h4>为 App 添加依赖</h4>

<p>在 DemoApp 的 Genral 选项卡中，添加 Linked Frameworks and Libraries 。选择  Workspace 中 SwiftyJSON 和
LTMorphingLabel 两个 <code>.framework</code> 。</p>

<p>如果是直接选择来自其他项目的 <code>.framework</code> 而不是同一 Workspace ，那么这里也许还要同时加入 <code>Embedded Binaries</code>。</p>

<h4>使用</h4>

<p>添加好依赖后，就可以在 DemoApp 项目代码中 <code>import SwiftyJSON</code> 或者 <code>import LTMorphingLabel</code> 来使用对应的库。同时还可以用 Command + 鼠标点击的方法查看声明代码。</p>

<h4>除错</h4>

<p>比较坑爹的是，实际上按照以上方法， <code>LTMorphingLabel</code> 并不能正常使用，查看报错信息发现是自动生成的 <code>LTMorphingLabel-Swift.h</code> 有处语法无法被识别，编辑器找到 <code>.h</code> 文件，注释掉这行诡异代码即可。</p>

<p>看起来目前的 Bridge Header 和 -emit-objc-header 实现还是有问题的。小伙伴一定要淡定。</p>

<h2>对于非 Workspace</h2>

<p>如果不喜欢使用 Workspace ，也可以将第三方库的编译结果，一个 <code>.framework</code> 目录拖到项目文件里，然后添加 <code>Embedded Binaries</code>。</p>

<h2>评论</h2>

<p>创建 Cocoa Touch Framework 选项中，可以使用 Swift 代码，此时编译结果（默认）会包含 <code>module.modulemap</code> 文件，
之前有介绍过它的作用，通过它， Swift 可以使用第三方模块。参考 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a> 。</p>

<p>实际上这个解决方案绕了一大圈，通过 Swift 文件导出 <code>ProjName-Swift.h</code>、然后 <code>module.modulemap</code> 模块描述文件引入、然后再由 Swift 导入。</p>

<p>其实 <code>.framework</code> 同时也包含了 <code>ProjName.swiftmodule/[ARCH].swiftmodule</code> 不过看起来没有使用到，而且默认在 IDE 下也不支持 Swift 从 <code>.swiftmodule</code> 文件导入，比较坑。希望以后版本能加入支持。</p>

<p><code>.framework</code> 包含了所有 Swift 标准库的动态链接库，小伙伴可能会以为这会导致编译后的 App 变大。其实大可放心，任何 Swift 语言的 App 都会包含这些动态链接库，而且只会包含一个副本。此方法对 App 最终的大小几乎无影响。</p>

<p>注： 个人测试了下，发现这个 <code>.swiftmodule</code> 是可以通过其他方法使用的，绕过 <code>module.modulemap</code>，应该是更佳的解决方案，但是需要控制命令行参数。</p>

<p>至于静态链接库，过时了。抛弃吧。</p>

<h2>参考</h2>

<ul>
<li><a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont/">Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Undocumented Grammar （Swift 黑语法）]]></title>
    <link href="http://andelf.github.io/blog/2014/07/04/swift-undocumented-grammar/"/>
    <updated>2014-07-04T03:05:11+08:00</updated>
    <id>http://andelf.github.io/blog/2014/07/04/swift-undocumented-grammar</id>
    <content type="html"><![CDATA[<p>本文介绍 Swift 的 Undocumented 语法特性。</p>

<p>电子书上介绍的 default function parameter 这里都不好意思拿出来写。</p>

<p>咳咳。持续更新。</p>

<h2>用关键字当变量名</h2>

<p>Keywards as variable name.</p>

<pre><code class="scala">// escaped variable name
let `let` = 1000
dump(`let`, name: "variable named let")
</code></pre>

<h2><code>new</code> 关键字</h2>

<p>The <code>new</code> keyword.</p>

<p>快速初始化数组。</p>

<pre><code class="scala">let an_array_with_100_zero = new(Int)[100]
</code></pre>

<h2>protocol type</h2>

<p>use <code>protocol&lt;Protocol1, Protocol2, ...&gt;</code> as a type.</p>

<h2>How I find it?</h2>

<p>瞎试出来的。</p>
]]></content>
  </entry>
  
</feed>
