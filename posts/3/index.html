
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>猫·仁波切</title>
  <meta name="author" content="猫·仁波切 (Feather)">

  
  <meta name="description" content="Swift is written in C++ 、Objective-C、Swift、 Assembly. TO BE CONTINUED libdyld.dylib`start 1
2
3
4
5
main(argc, argv) { once() { C_ARGC = argc } once &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andelf.github.io/posts/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="猫·仁波切" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">猫·仁波切</a></h1>
  
    <h2>会研发的PM才是好OP.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:andelf.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/16/swift-runtime/">Swift Runtime</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-16T10:38:45+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Swift is written in C++ 、Objective-C、Swift、 Assembly.</p>

<p>TO BE CONTINUED</p>

<p>libdyld.dylib`start</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">once</span><span class="p">()</span> <span class="p">{</span> <span class="n">C_ARGC</span> <span class="o">=</span> <span class="n">argc</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">once</span><span class="p">()</span> <span class="p">{</span> <span class="n">C_ARGV</span> <span class="o">=</span> <span class="n">argv</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">top_level_code</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>All code in swift file goes to <code>top_level_code</code>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/15/swift-and-c-interop/">Swift and C Interop(简析Swift和C的交互)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-15T00:11:44+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>声明： 转载注明我或者 SwiftChina . <a href="http://weibo.com/234632333">weibo</a></p>

<p>其中 <code>@asmname</code> 的两个用法源于我的猜测验证，用到了 Xcode, lldb, nm, llvm ir 等工具或格式。</p>

<p>其中 name mangling 部分源自 WWDC。</p>

<p>相关的分析主要基于我 dump 出的 Swift 标准库声明代码，位于 <a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a>。</p>

<p>目前有两个小部分还未完成。</p>

<p>之前好像简单说过 Swift 和 Objective-C 的交互问题。其实我们也可以用 Swift 调用纯 C 代码或者基于 C 的第三方库。（这里不会也永远不会考虑 C++ 的情况，因为不支持，不过可以用 C 写 wrapper, 这个没有任何问题。）</p>

<p>Swift 官方文档中，以及那本已经被迅速翻译为中文的 ibooks 书中，都提到了 Swift 调用 Objective-C 和 C 是有很好支持的。不过没有细节。</p>

<p><del>这里不会考虑如何用 C 调用 Swift, 暂时，看心情。：）</del> 本内容包括 Swift 调用 C 和相应的 C 调用 Swift，项目混编。</p>

<p>这里主要面向 MacOSX 应用。iOS 或许可以适用。</p>

<p>先复习下区别。</p>

<h2>第一部分 预备知识</h2>

<h3>语言区别</h3>

<p>说到底就是 C 少了很多东西。但是多了个指针。</p>

<p>对于 C 来说，最头疼的莫过于指针，而 Swift 是一门没有指针的语言。是不是要吐血？相对来说指针不但代表者指针操作传参，还有指针运算等等。</p>

<h2>第二部分 调用 C</h2>

<p>这里主要讨论函数的调用。对于结构、枚举、类的兼容性暂时没尝试。</p>

<h3>C 标准库</h3>

<p>好消息是，对于标准库中的 C 函数，根本不需要考虑太多导入头文件神马的。比如 <code>strlen</code>、<code>putchar</code>、<code>vprintf</code>。当然 <code>vprintf</code> 需要多说几句，后面说。</p>

<p>请直接 <code>import Darwin</code> 模块。</p>

<p>这些标准库函数表示为 <code>Darwin.C.HEADER.name</code>。</p>

<p>实际上由于 Swift 模块结构是平坦的，他们均位于 <code>Darwin</code> 中，所以基本上是直接用的。</p>

<p>然后 <code>CoreFoundation</code> 用到了 <code>Darwin</code> ( @exported 导入，所以相当于这些名字也在 <code>CoreFoundation</code> 中)。</p>

<p>然后 <code>Foundation</code> 用到了 <code>CoreFoundation</code> （也是 @exported 导入。）</p>

<p>所以其实你导入 <code>Foundation</code> 的时候，这些 C 函数都是直接可用的。比如 <code>putchar</code> 一类。</p>

<p>多说一句，<code>Cocoa</code> 当然也包含 <code>Foundation</code>。</p>

<h3>C 函数</h3>

<p>好吧假设你有个牛逼到顶天的算法是 C 写的，不对，假设是别人写的，牛逼到你只能凑合用却看不懂然后自己也写不出没空迁移的地步。</p>

<p>我们直接创建一个 Swift 项目，然后 New File，添加一个 <code>.c</code> 文件。</p>

<p>这时候 Xcode 会弹出对话框询问是否配置 Bridge Header，确认就可以了。也可以手动添加 Bridge Header，位置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。指向你的 Bridge Header 文件名就可以了。</p>

<p>一般这个文件是 <code>ProjectName-Bridging-Header.h</code>。情况基本和与 Objective-C 混编没区别。</p>

<p>剩下的工作就很简单了。在 <code>.c</code> 文件填上传说中的牛逼算法。在 <code>ProjectName-Bridging-Header.h</code> 中加上该函数原型或者引入相关的头文件。</p>

<p>在 Swift 中调用的名字和 C 名字一样就可以了，比如你定义了一个 <code>int mycsort()</code> 那么在 Swift 中就是 <code>func mycsort() -&gt; CInt</code>。</p>

<p>这时候问题来了。一个漂亮的问题。</p>

<p>我的 C 函数名字和 Swift 标准库冲突怎么办？比如我定义了一个函数就叫 <code>println</code>，我们知道 Swift 里也有个 <code>println</code>。</p>

<p>这样，如果直接调用会提示 <code>Ambiguous use of 'println'</code>。没辙了么？</p>

<p>这里有个我发现的 Undocumented Featuer 或者说是 Undocumented Attribute。你转载好歹提下我好吧。（发现方法是通过 Xcode 查看定义，然后通过 nm 命令发现符号, 对照 llvm ir 确认的。)</p>

<p>那就是 <code>@asmname("func_name_in_c")</code>。用于函数声明前。使用方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">println</span><span class="p">()</span> <span class="p">{</span> <span class="p">....</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">@</span><span class="n">asmname</span><span class="p">(</span><span class="s">&quot;println&quot;</span><span class="p">)</span> <span class="n">func</span> <span class="n">c_println</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">CInt</span> <span class="c1">// 声明，不需要 {} 函数体</span>
</span><span class='line'><span class="n">c_println</span><span class="p">()</span> <span class="c1">// 调用</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是 C 中的同名函数，我们可以给赋予一个别名，然后正常调用。这么一看就基本没有问题了。至于类型问题，待会说，详细说。</p>

<h3>C Framework</h3>

<p>很多时候我们拿到的是第三方库，格式大概是个 Framework。比如 <code>SDL2.framework</code>。举这个例子是因为我想对来说比较熟悉 SDL2。</p>

<p>直接用 Finder 找到这个 <code>.framework</code> 文件，拖动到当前项目的文件列表里，这样它将作为一个可以展开的文件夹样式存在于我们的项目中。</p>

<p>在 <code>ProjectName-Bridging-Header.h</code> 中引入其中需要的 <code>.h</code>。</p>

<p>比如我们引入 <code>SDL2.framework</code>，那么我们就需要写上 <code>#import &lt;SDL2/SDL.h&gt;</code>。</p>

<p>然后在 Swift 文件里正常调用就好了。</p>

<p>所以其实说到底核心就是那个 <code>ProjectName-Bridging-Header.h</code>，因为它是作为参数传递给 Swift 编译器的，所以 Swit 文件里可以从它找到定义的符号。</p>

<p>但是，这个桥接头文件的一切都是隐式的，类型自动对应，所以很多时候需要我们在 Swift 里调用并封装。或者使用 <code>@asmname(...)</code> 避免名字冲突。</p>

<h2>第三部分 类型转换</h2>

<p>前面说到了 C 中有指针，而 Swift 中没有，同时基本类型还有很多不同。所以混编难免需要在两种语言的不同类型之间进行转换。</p>

<p>牢记一个万能函数 <code>reinterpretCast&lt;T, U&gt;(T) -&gt; U</code>，只要 T, U sizeof 运算相等就可以直接转换。这个在之前的标准库函数里有提到。调用 C 代码的利器！</p>

<h3>基本类型对应</h3>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。简言之，不在对应为 C 别名类型，而是直接对应到 Siwft 类型。而指针类型简化为 <code>UnsafePointer&lt;T&gt;</code> 和 <code>ConstUnsafePointer&lt;T&gt;</code> 两种， <code>COpaquePointer</code> 依然存在。另新增了 <code>CFunctionPointer&lt;T&gt;</code>。</p>

<ul>
<li>int => CInt</li>
<li>char => CChar / CSignedChar</li>
<li>char* => CString</li>
<li>unsigned long = > CUnsignedLong</li>
<li>wchar_t => CWideChar</li>
<li>double => CDouble</li>
<li>T* => CMutablePointer<T></li>
<li>void* => CMutableVoidPointer</li>
<li>const T* => CConstPointer<T></li>
<li>const void* => CConstVoidPointer</li>
<li>&hellip;</li>
</ul>


<p>继续这个列表，你肯定会想这么多数值类型，怎么搞。其实大都是被 <code>typealias</code> 定义到 <code>UInt8</code>，<code>Double</code> 这些的。放心。C 中数值类型全部被明确地用别名定义到带 size 的 Swift 数值类型上。完全是一样用的。</p>

<p>其实真正的 Pointer 类型只是 <code>UnsafePointer&lt;T&gt;</code>，大小与 C 保证一致，而对于这里不同类型的 Pointer，其实都是 <code>UnsafePointer</code>
到它们的隐式类型转换。<del>还有个指针相关类型是 <code>COpaquePointer</code>，不过没试验怎么用</del>。</p>

<p>UPDATE: 我们在调用的时候，更多地用到 <code>COpaquePointer</code>，我将再坑一篇介绍它。</p>

<p>同时 <code>NilType</code>，也就是 <code>nil</code> 有到这些指针的隐式类型转换。所以可以当做任何一种指针的 <code>NULL</code> 用。</p>

<p>还有个需要提到的类型是 CString, 他的内存 layout 等于 <code>UnsafePointer&lt;UInt8&gt;</code>，下面说。</p>

<h3>CString</h3>

<p>用于表示 <code>char *</code>，<code>\0</code> 结尾的 c 字符串，实际上似乎还看到了判断是否 ASCII 的选项，但是没试出来用法。</p>

<p>实现了 <code>StringLiteralConvertible</code> 和 <code>LogicValue</code>。可以从字符串常量直接赋值获得 <code>CString</code>。<code>LogicValue</code> 也就是是 <code>if a_c_str {}</code>，实际是用于判断是否为 <code>NULL</code>，可用，但是不稳定，老 crash。</p>

<p>运算符支持 <code>==</code>，判断两字符串是否相当，猜测实际是 <code>strcmp</code> 实现，对比 NULL 会 crash。Orz。</p>

<p>CString 和 String 的转换通过一个 extension 实现，也是很方便。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">String</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">fromCString</span><span class="o">(</span><span class="n">cs</span><span class="k">:</span> <span class="kt">CString</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">fromCString</span><span class="o">(</span><span class="n">up</span><span class="k">:</span> <span class="kt">UnsafePointer&lt;CChar&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">// 还有两个方便的工具方法。 Rust 背景的同学一定仰天长啸。太相似了。</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">String</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">withCString</span><span class="o">&lt;</span><span class="nc">Result</span><span class="o">&gt;(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">CString</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">Result</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Result</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">withCString</span><span class="o">&lt;</span><span class="nc">Result</span><span class="o">&gt;(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">UnsafePointer&lt;CChar&gt;</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">Result</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Result</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在我们的 Bridging Header 头文件中 <code>char *</code> 的类型会对应为 <code>UnsafePointer&lt;CChar&gt;</code>，而实际上 <code>CString</code> 更适合。所以在 Swift 代码中，往往我们要再次申明下这个函数。或者用一个函数封装下，转换成我们需要的类型。</p>

<p>例如，假设在 Bridging Header 中我们声明了 <code>char * foo();</code>，那么，在 Swift 代码中我们可以用上面提到的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@asmname</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">)</span> <span class="n">func</span> <span class="n">c_foo</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">CString</span>
</span><span class='line'><span class="c1">// 注意这里没有 {}，只是声明</span>
</span><span class='line'><span class="n">let</span> <span class="n">ret</span> <span class="k">=</span> <span class="n">c_foo</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然也可以直接调用原始函数然后类型转换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">let</span> <span class="n">raw</span> <span class="k">=</span> <span class="n">foo</span><span class="o">()</span> <span class="c1">// UnsafePointer&lt;Int8&gt; &lt;=&gt; UnsafePointer&lt;CChar&gt;</span>
</span><span class='line'><span class="n">let</span> <span class="n">ret</span> <span class="k">=</span> <span class="nc">String</span><span class="o">.</span><span class="n">fromCString</span><span class="o">(</span><span class="n">ret</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果这里要转成 CString 就略复杂了，因为 CString 构造函数接受的参数是 <code>UnsafePointer&lt;UInt8&gt;</code>， 而 <code>CChar</code> 是 <code>Int8</code> 的别名，所以还牵扯到 Genrics 类型转换，不够方便。</p>

<p>如果非要作为 CString 处理，可以用 <code>reinterpretCast()</code>，直接转换。但是请一定要知道自己在转换什么，确保类型的 sizeof 相同，确保转换本身有意义。</p>

<p>例如获得环境变量字符串：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">let</span> <span class="n">key</span> <span class="k">=</span> <span class="s">&quot;PATH&quot;</span>
</span><span class='line'><span class="c1">// 这里相当于把 UnsafePointer&lt;CChar&gt; 转为了 UnsafePointer&lt;UInt8&gt; 然后到 CString</span>
</span><span class='line'><span class="n">let</span> <span class="n">path_str</span><span class="k">:</span> <span class="kt">CString</span> <span class="o">=</span> <span class="n">reinterpretCast</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="n">withCString</span><span class="o">(</span><span class="n">getenv</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Unmanaged</h3>

<p>这个先挖坑，随后填上。</p>

<h3>VaList</h3>

<p>这个也是坑，随后填上。</p>

<h2>第三部分 C 调用 Swift</h2>

<p>如果项目里加入了 C 文件，那么它可以调用我们的 Swift 函数么？答案是可以的，而且令人吃惊地透明。这也许是因为 Apple 所宣传的，Small Runtime 概念吧。极小的语言运行时。</p>

<p>和 Objective-C 混编类似，配置好 Bridging Header 的项目，在 .c .h .m 文件中都可以使用一个叫做 <code>ProjectName-Swift.h</code> 的头文件，其中包含 Swift 代码导出的函数等。</p>

<p>参考之前的 Objective-C 和 C 交互我们可以知道，说到底交互就是链接过程，只要链接的时候能找到符号就可以。</p>

<p>不过不能高兴太早，Swift 是带类、枚举、协议、多态、泛型等的高级语言，符号处理明显要比 C 中的复杂的多，现代语言一般靠 name mangle 来解决这个问题。也就是说一个 Swift 函数，在编译到 .o 的时候，名字就不是原来那么简单了。比如 <code>__TFV5hello4Rectg9subscriptFOS_9DirectionSi</code> 这样的名字。</p>

<p>Xcode 自带了个工具， 可以查看这些 mangled name 到底是什么东西：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">xcrun</span> <span class="n">swift</span><span class="o">-</span><span class="n">demangle</span> <span class="nc">__TFV5hello4Rectg9subscriptFOS_9DirectionSi</span>
</span><span class='line'><span class="nc">_TFV5hello4Rectg9subscriptFOS_9DirectionSi</span> <span class="o">---&gt;</span> <span class="n">hello</span><span class="o">.</span><span class="nc">Rect</span><span class="o">.</span><span class="n">subscript</span><span class="o">.</span><span class="n">getter</span> <span class="o">(</span><span class="n">hello</span><span class="o">.</span><span class="nc">Direction</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Swift</span><span class="o">.</span><span class="nc">Int</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们从 C 调用的时候，应该规避这样的名字。还记得前面的 <code>@asmname</code> 么？没错，它可以用于指定 Swift 函数的符号名，我猜测应该有指定 mangled name 的作用，但是不是特别确定。</p>

<p>这里随便指定个例子先。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@asmname</span><span class="o">(</span><span class="s">&quot;say_hello&quot;</span><span class="o">)</span> <span class="n">func</span> <span class="n">say_hello</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Double</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="s">&quot;This is say_hello() in swift&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mf">3.14</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在 .c 文件中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="nc">ProjectName</span><span class="o">-</span><span class="nc">Swift</span><span class="o">.</span><span class="n">h</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">extern</span> <span class="n">double</span> <span class="n">say_hello</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">int</span> <span class="n">some_func</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">say_hello</span><span class="o">();</span> <span class="c1">// or capture its value and process it</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><del>当然这里的 extern 一行是可选的，因为实际上声明会存在于 ProjectName-Swift.h 中，只是为了避免首次编译警告而已（第二次以后的编译，其实这个 Header 已经被缓存起来了，这个牵扯到 Xcode 的编译过程）。</del> 错了。</p>

<p>对于函数而言 extern 必须手动加上，对于 class  、 protocol ，会在生成的头文件里。</p>

<p>按照这个思路，其实很容易实现 Swift 调用 C 中调用了 Swift 函数的函数。这意味着，可以通过简单的方法封装支持向 C 传递 Swift block 作为回调函数。难度中上，对于有过类似扩展编写经验的人来说很简单。</p>

<h2>第四部分 编译过程</h2>

<p>其实调用基本就这么多， Objective-C 那篇文章中说的编译过程同样有效。我 C-c C-v 下：</p>

<ul>
<li>编译所有 <code>X.swift</code> 文件到 <code>X.o</code> (with <code>-emit-objc-header</code>, <code>-import-objc-header</code>) (其中包含 <code>.swiftmodule</code> 子过程)

<ul>
<li>由于选项里有 <code>-emit-objc-header</code>，所以之后的 C 文件可以直接 import 对应的 <code>ProjectName-Swift.h</code></li>
</ul>
</li>
<li>编译 <code>X.c</code> 到 <code>X.o</code></li>
<li>链接所有 <code>.o</code> 生成可执行文件</li>
</ul>


<p>仔细理解上面的简简单单四行编译过程说明，你就明白为什么 .swfit 和 .c 可以互相调用了。其中两个 Header 文件起到了媒介的作用，一个将 .c/.m 文件中的定义暴露给 Swift，另一个将 .swift 中的定义暴露给 .c/.m 。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/13/swift-misc/">Swift Misc</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-13T13:53:13+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Just Notes. Keep Updating.</p>

<h2>escaped variable name</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let `let` = 1000
</span><span class='line'>dump(`let`, name: "variable named let")</span></code></pre></td></tr></table></div></figure>


<h2>Optimise Parameter</h2>

<ul>
<li><code>-Onone</code> // optimization off, safety checks on</li>
<li><code>-O</code> // optimization on,  safety checks on</li>
<li><code>-Ofast</code> // optimization on,  safety checks off</li>
</ul>


<h2>High Level Optimization</h2>

<ul>
<li>Removing abstraction penalties</li>
<li>Generic specialization</li>
<li>Devirtualization (Resolving dynamic method calls at compile-time)

<ul>
<li>If Swift can see where you constructed the object</li>
<li>If Swift knows that a class doesn&rsquo;t have any subclasses</li>
<li>If you&rsquo;ve marked a method with the @final attribute</li>
</ul>
</li>
<li>ARC optimization</li>
<li>Enum analysis</li>
<li>Alias analysis</li>
<li>Value propagation</li>
<li>Library optimizations on strings, arrays, etc.</li>
</ul>


<h2>Closure Memoize</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">func</span> <span class="n">memoize</span><span class="o">&lt;</span><span class="n">T</span><span class="k">:</span> <span class="kt">Hashable</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;(</span> <span class="n">body</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">)</span><span class="kt">-&gt;U</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">T</span><span class="o">)-&gt;</span><span class="n">U</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">memo</span> <span class="k">=</span> <span class="nc">Dictionary</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;()</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">{</span> <span class="n">x</span> <span class="n">in</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">q</span> <span class="k">=</span> <span class="n">memo</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="o">{</span> <span class="k">return</span> <span class="n">q</span> <span class="o">}</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">r</span> <span class="k">=</span> <span class="n">body</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class='line'>    <span class="n">memo</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=</span> <span class="n">r</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">r</span>
</span><span class='line'><span class="o">}</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">memoize</span><span class="o">&lt;</span><span class="n">T</span><span class="k">:</span> <span class="kt">Hashable</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;(</span> <span class="n">body</span><span class="k">:</span> <span class="o">((</span><span class="kt">T</span><span class="o">)</span><span class="kt">-&gt;U</span><span class="o">,</span> <span class="kt">T</span><span class="o">)-&gt;</span><span class="n">U</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">T</span><span class="o">)-&gt;</span><span class="n">U</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">memo</span> <span class="k">=</span> <span class="nc">Dictionary</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;()</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">result</span><span class="k">:</span> <span class="o">((</span><span class="kt">T</span><span class="o">)</span><span class="kt">-&gt;U</span><span class="o">)</span><span class="kt">!</span>
</span><span class='line'>  <span class="n">result</span> <span class="k">=</span> <span class="o">{</span> <span class="n">x</span> <span class="n">in</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">q</span> <span class="k">=</span> <span class="n">memo</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="o">{</span> <span class="k">return</span> <span class="n">q</span> <span class="o">}</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">r</span> <span class="k">=</span> <span class="n">body</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class='line'>    <span class="n">memo</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=</span> <span class="n">r</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">r</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>lldb</h2>

<h3>Raw Display</h3>

<p>(lldb) fr v -R age</p>

<h3>Protocol</h3>

<p>fr v val</p>

<p>fr v -d r val</p>

<h3>misc</h3>

<p>repl // repl loop</p>

<p>// find stop reason
t i // thread info
// how did this code get called, list frames
bt // thread backtrace</p>

<p>一般主要查找 top_level_code 位置，找到出错未知</p>

<p>// what is the failure conditions
f 1 // frame select 1</p>

<p>p foo // expression foo</p>

<p>b filename.swift:8
b func_name</p>

<p>br s -r timestwo.<em>String // breakpoint set &ndash;func-regex timestwo.</em>String</p>

<p>b *
br m -c “valueInCents &lt; Int(amountInCents)”  // breakpoint modify &ndash;condition “&hellip;”
br m -c &ldquo;&hellip;.&rdquo; 3.1</p>

<p>b *
br co a //  breakpoint command add // enter commands, <code>DONE</code> to end</p>

<p>br l // breakpoint list</p>

<p>br dis 1 // breakpoint disable 1</p>

<h3>Infos</h3>

<p>The stop reason tells you what happened</p>

<ul>
<li><code>EXC_BAD_INSTRUCTION</code>  Assertion</li>
<li><code>SIGABRT</code> Exception (usually Objective-C)</li>
<li><code>EXC_BAD_ACCESS</code>  Memory error</li>
</ul>


<p>The stack tells you how it happened
The expression command helps you inspect variables</p>

<h2>swift-demangle</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">xcrun</span> <span class="n">swift</span><span class="o">-</span><span class="n">demangle</span> <span class="nc">__TIFSs4dumpU__FTQ_4nameGSqSS_6indentSi8maxDepthSi8maxItemsSi_Q_A1_</span>
</span><span class='line'><span class="nc">_TIFSs4dumpU__FTQ_4nameGSqSS_6indentSi8maxDepthSi8maxItemsSi_Q_A1_</span> <span class="o">---&gt;</span>
</span><span class='line'><span class="nc">Swift</span><span class="o">.(</span><span class="n">dump</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;(</span><span class="n">A</span><span class="o">,</span> <span class="n">name</span> <span class="k">:</span> <span class="kt">Swift.String?</span><span class="o">,</span> <span class="n">indent</span> <span class="k">:</span> <span class="kt">Swift.Int</span><span class="o">,</span> <span class="n">maxDepth</span> <span class="k">:</span> <span class="kt">Swift.Int</span><span class="o">,</span> <span class="n">maxItems</span> <span class="k">:</span> <span class="kt">Swift.Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="o">).(</span><span class="n">default</span> <span class="n">argument</span> <span class="mi">2</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>dispatch queue</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">Foundation</span>
</span><span class='line'><span class="k">var</span> <span class="n">queue</span> <span class="k">:</span> <span class="kt">dispatch_queue_t</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="o">(</span><span class="s">&quot;my_queue&quot;</span><span class="o">,</span> <span class="n">nil</span><span class="o">)</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span><span class="n">println</span><span class="o">(</span><span class="err">“</span><span class="n">world</span><span class="err">&quot;</span><span class="o">)}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Upcast vs Downcast</h2>

<p>A matter of idom</p>

<p>Upcast: T to AnyObject</p>

<p>Downcast: AnyObject <code>as</code> T</p>

<h2>Swift Array <code>T[]</code></h2>

<p>Two representations.</p>

<ul>
<li>Native Array => |len|cap|0|1|2|..|</li>
<li>Cocoa Array => NSArray obj</li>
</ul>


<h2>Unmanaged</h2>

<p>Used in CF.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">struct</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="k">:</span> <span class="kt">AnyObject&gt;</span> <span class="o">{</span><span class="err"> </span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">takeUnretainedValue</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">T</span>   <span class="c1">// for +0 returns</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">takeRetainedValue</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">T</span> <span class="err"> </span> <span class="c1">// for +1 returns </span>
</span><span class='line'>
</span><span class='line'>  <span class="n">func</span> <span class="n">retain</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="err"> </span>
</span><span class='line'>  <span class="n">func</span> <span class="n">release</span><span class="o">()</span><span class="err"> </span>
</span><span class='line'>  <span class="n">func</span> <span class="n">autorelease</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">}</span><span class="err"> </span>
</span></code></pre></td></tr></table></div></figure>


<h2>Weak Reference</h2>

<p>Weak references are optional values</p>

<ul>
<li>Use strong references from owners to the objects they own</li>
<li>Use weak references among objects with independent lifetimes</li>
<li>Use unowned references from owned objects with the same lifetime //  互相绑定的引用，生命周期相同</li>
</ul>


<h2>Initializer</h2>

<ul>
<li>Initialize all values before you use them</li>
<li>Set all stored properties first, then call super.init</li>
<li>Designated initializers only delegate up</li>
<li>Convenience initializers only delegate across</li>
</ul>


<h2>Capture List</h2>

<p>避免循环引用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">onChange</span> <span class="k">=</span> <span class="o">{[</span><span class="kt">unowned</span> <span class="kt">self</span><span class="o">]</span> <span class="n">temp</span> <span class="n">in</span>
</span><span class='line'>    <span class="n">self</span><span class="o">.</span><span class="n">currentTemp</span> <span class="k">=</span> <span class="n">temp</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QuickLookObject</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">enum</span> <span class="nc">QuickLookObject</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Text</span><span class="o">(</span><span class="nc">String</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Int</span><span class="o">(</span><span class="nc">Int64</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">UInt</span><span class="o">(</span><span class="nc">UInt64</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Float</span><span class="o">(</span><span class="nc">Double</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Image</span><span class="o">(</span><span class="nc">Any</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Sound</span><span class="o">(</span><span class="nc">Any</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Color</span><span class="o">(</span><span class="nc">Any</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">BezierPath</span><span class="o">(</span><span class="nc">Any</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">AttributedString</span><span class="o">(</span><span class="nc">Any</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Double</span><span class="o">,</span> <span class="nc">Double</span><span class="o">,</span> <span class="nc">Double</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Point</span><span class="o">(</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Double</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Size</span><span class="o">(</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Double</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Logical</span><span class="o">(</span><span class="nc">Bool</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Range</span><span class="o">(</span><span class="nc">UInt64</span><span class="o">,</span> <span class="nc">UInt64</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">View</span><span class="o">(</span><span class="nc">Any</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Sprite</span><span class="o">(</span><span class="nc">Any</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">URL</span><span class="o">(</span><span class="nc">String</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">_Raw</span><span class="o">(</span><span class="nc">UInt8</span><span class="o">[],</span> <span class="nc">String</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Add Quick Look support to NSObject subclasses only
Implement the debugQuickLookObject() method</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">func</span> <span class="n">debugQuickLookObject</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">AnyObject</span><span class="o">?</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;Some Quick Look type&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/13/swift-special-protocols/">Swift Special Protocols</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-13T12:43:07+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>via WWDC 404</p>

<p>Protocols are your hooks into the Swift core language
Swift generics combine abstraction, safety, and performance in new ways
Read, experiment, and have fun. There’s plenty to discover!</p>

<h2><code>LogicValue</code> // 重载 if val</h2>

<h2><code>Printable</code> // 重载 println</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">Printable</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">description</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><code>Sequence</code> // 重载 for-in</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">Sequence</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="nc">GeneratorType</span> <span class="k">:</span> <span class="kt">Generator</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">generate</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">GeneratorType</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">protocol</span> <span class="nc">Generator</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="nc">Element</span>
</span><span class='line'>  <span class="n">mutating</span> <span class="n">func</span> <span class="n">next</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Element</span><span class="o">?</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// for .. in { }</span>
</span><span class='line'><span class="k">var</span> <span class="nc">__g</span> <span class="k">=</span> <span class="n">someSequence</span><span class="o">.</span><span class="n">generate</span><span class="o">()</span>
</span><span class='line'><span class="k">while</span> <span class="n">let</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">__g</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'><span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>*Convertible</h2>

<ul>
<li>IntegerLiteralConvertible</li>
<li>FloatLiteralConvertible</li>
<li>StringLiteralConvertible</li>
<li>ArrayLiteralConvertible</li>
<li>DictionaryLiteralConvertible</li>
</ul>


<h2>Equatable</h2>

<p><code>==</code></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/12/swift-and-objectivec-interop-cont/">Swift and ObjectiveC Interop Cont. (Swift 与 Objective-C 之间的交互，续坑)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-12T17:10:28+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>关于 <code>_ConditionallyBridgedToObjectiveC</code></h2>

<p>When you bridge from a Swift array to an NSArray object, the elements in the Swift array must be AnyObject compatible. For example, a Swift array of type Int[] contains Int structure elements. The Int type is not an instance of a class, but because the Int type bridges to the NSNumber class, the Int type is AnyObject compatible. Therefore, you can bridge a Swift array of type Int[] to an NSArray object. If an element in a Swift array is not AnyObject compatible, a runtime error occurs when you bridge to an NSArray object.</p>

<h2>其他 Tips</h2>

<p>When you declare an outlet in Swift, the compiler automatically converts the type to a weak implicitly unwrapped optional and assigns it an initial value of nil. In effect, the compiler replaces @IBOutlet var name: Type with @IBOutlet weak var name: Type! = nil.</p>

<p>In Swift, there are no readwrite and readonly attributes. When declaring a stored property, use let to make it read-only, and use var to make it read/write. When declaring a computed property, provide a getter only to make it read-only and provide both a getter and setter to make it read/write.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/12/swift-string-extension-for-int-index/">Swift String Extension for Integer Index(扩展String使之可以支持数字Index和数字Range)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-12T11:17:28+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>使用效果:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">let</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;Hello World 世界&quot;</span>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="s">&quot;foo[13] \(foo[13])&quot;</span><span class="o">)</span>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="s">&quot;foo[-1] \(foo[-1])&quot;</span><span class="o">)</span>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="s">&quot;foo[-2] \(foo[-2])&quot;</span><span class="o">)</span>
</span><span class='line'><span class="n">dump</span><span class="o">(</span><span class="n">foo</span><span class="o">[</span><span class="err">1</span><span class="kt">..</span><span class="err">5</span><span class="o">],</span> <span class="n">name</span><span class="k">:</span> <span class="err">&quot;</span><span class="kt">foo</span><span class="o">[</span><span class="err">1</span><span class="kt">:</span><span class="err">4</span><span class="o">]</span><span class="s">&quot;)</span>
</span><span class='line'><span class="s">dump(foo[10...13], name: &quot;</span><span class="n">foo</span><span class="o">[</span><span class="err">10</span><span class="kt">:</span><span class="err">13</span><span class="o">]</span><span class="err">&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单介绍下实现背后的思路和想法。</p>

<p>首先熟悉 String/Range 的一定知道这玩意 subscript 类型只能是 <code>String.Index</code>，也就是通过 <code>String.startIndex</code> 或者 <code>.endIndex</code> 获得。很不爽，实际使用场景里面大家直接把 <code>String</code> 当 Unicode 字符串搞。假定无风险好了。</p>

<p>用 <code>sizeofValue</code> 检查 <code>aString.endIndex</code> 发现大小是 32，猜测是 4x8 (64位)个整数或者指针，如果是我，索引值肯定放在这个结构的第一位，所以这就是 <code>_Dummy</code> 结构的由来（猜测+代码验证），就是为了和 <code>String.Index</code> 类型大小一致结构相似（反正我只关心第一个，其他的我用 <code>_padding</code> 补全）</p>

<p>然后用强制类型转换，然后操作这个值。</p>

<p>至于重载 subscript ，那啥。看书好了。</p>

<p>然后有人说字符串没有长度方法。。</p>

<p><code>countElements(aString)</code> 标准库函数。可以用 extension 做到 <code>String</code> 里。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">String</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">struct</span> <span class="nc">_Dummy</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">idxVal</span><span class="k">:</span> <span class="kt">Int</span>
</span><span class='line'>        <span class="k">var</span> <span class="nc">_padding</span><span class="k">:</span> <span class="kt">Int</span>
</span><span class='line'>        <span class="k">var</span> <span class="nc">_padding2</span><span class="k">:</span> <span class="kt">Int</span>
</span><span class='line'>        <span class="k">var</span> <span class="nc">_padding3</span><span class="k">:</span> <span class="kt">Int</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">subscript</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Character</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">dummy</span><span class="k">:</span> <span class="k">_</span><span class="kt">Dummy</span> <span class="o">=</span> <span class="n">reinterpretCast</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="k">:</span> <span class="kt">self.endIndex</span><span class="o">)</span>
</span><span class='line'>        <span class="n">dummy</span><span class="o">.</span><span class="n">idxVal</span> <span class="o">+=</span> <span class="n">i</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">idx</span><span class="k">:</span> <span class="kt">String.Index</span> <span class="o">=</span> <span class="n">reinterpretCast</span><span class="o">(</span><span class="n">dummy</span><span class="o">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">self</span><span class="o">[</span><span class="kt">idx</span><span class="o">]</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">subscript</span> <span class="o">(</span><span class="n">subRange</span><span class="k">:</span> <span class="kt">Range&lt;Int&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">start</span><span class="k">:</span> <span class="k">_</span><span class="kt">Dummy</span> <span class="o">=</span> <span class="n">reinterpretCast</span><span class="o">(</span><span class="n">self</span><span class="o">.</span><span class="n">startIndex</span><span class="o">)</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">end</span> <span class="k">=</span> <span class="n">start</span>
</span><span class='line'>        <span class="n">start</span><span class="o">.</span><span class="n">idxVal</span> <span class="k">=</span> <span class="n">subRange</span><span class="o">.</span><span class="nc">_startIndex</span>
</span><span class='line'>        <span class="n">end</span><span class="o">.</span><span class="n">idxVal</span> <span class="k">=</span> <span class="n">subRange</span><span class="o">.</span><span class="nc">_endIndex</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">startIndex</span><span class="k">:</span> <span class="kt">String.Index</span> <span class="o">=</span> <span class="n">reinterpretCast</span><span class="o">(</span><span class="n">start</span><span class="o">)</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">endIndex</span><span class="k">:</span> <span class="kt">String.Index</span> <span class="o">=</span> <span class="n">reinterpretCast</span><span class="o">(</span><span class="n">end</span><span class="o">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">self</span><span class="o">[</span><span class="kt">startIndex..endIndex</span><span class="o">]</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>讨论内容在 <a href="http://swift.sh/topic/95/stringindexrange/">SwiftChina</a>. 其中有人给出了负数 range 的实现。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/11/swift-and-objectivec-interop/">Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-11T20:01:11+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。</p>

<p>瞎写的，有错或者不明白的地方直接告诉我。转载注明我或者 SwiftChina 。</p>

<p>参考资料是 我的 Github : <a href="https://github.com/andelf/Defines-Swift">andelf/Defines-Swift</a> 是我dump出的定义。10w行swift代码。</p>

<h1>预备知识</h1>

<h2>Objective-C (Cocoa) 特色</h2>

<p>数值类型统一用 <code>NSNumber</code>，不区分具体。大量操作在指针上进行，也就隐含着一切可能出错的调用都会返回 <code>nil</code>。
没有泛型支持，字典或者数组更多用 <code>id</code> 类型。</p>

<h2>对应 Swift 特色</h2>

<p>数值类型众多 （<code>Int, UInt, Float, Double, ...</code>），无指针（<code>UnsafePointer</code> 这类用于和其他代码交互的结构不计，<code>&amp;</code> + <code>inout</code> 认为是引用。）。
<code>nil</code> 用于 <code>Type?</code>, <code>Type!</code>。字典和数组用泛型表示。</p>

<h2>一些属性</h2>

<p>有几个属性用于和 Objective-C 之间的交互。</p>

<h3><code>@objc</code> 和 <code>@objc(a_name_defined_in_objc)</code></h3>

<h3><code>@objc_block</code></h3>

<p>用于函数类型前，标记后面的 block 是 Objective-C 的。个人觉得编译器会自动转换相关的 block 类型。</p>

<p>然后需要预备下几个属性的知识。</p>

<h3><code>@conversion</code></h3>

<p>Swift 中的隐式类型转换。有另一篇文章介绍。</p>

<h3><code>@final</code></h3>

<p>就是 final 了。</p>

<h3><code>@transparent</code></h3>

<p>经过反汇编查看，相当于 <code>inline</code> 的作用。同时生成的 <code>.swiftmodule</code> 文件依然带有原函数实现。这个很高大上。保证了 <code>inline</code> 特性在包外可用。</p>

<h2>重要 Swift protocol</h2>

<h3><code>*LiteralConvertible</code></h3>

<p>表示可以从 Swift 字面常量转换而得。比如 <code>let a: Type = 100</code>, 那么 Type 必须实现 IntegerLiteralConvertible。</p>

<p>大概有 IntegerLiteralConvertible, FloatLiteralConvertible, StringLiteralConvertible, ArrayLiteralConvertible, DictionaryLiteralConvertible, CharacterLiteralConvertible 等。</p>

<h3><code>_BridgedToObjectiveC</code> <code>_ConditionallyBridgedToObjectiveC</code></h3>

<p>顾名思义。就是相当于这个 Swift 类型可以和某一 Objective-C 类型对等，可以相互转换。</p>

<p>Conditional 多了个判断函数，也就是说这个类型可能是并没有对等起来的，什么情况下用呢，目前猜测应该是带泛型参数的类型中用到，有的泛型可以对应，有的不可以。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">_BridgedToObjectiveC</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="nc">ObjectiveCType</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">func</span> <span class="n">getObjectiveCType</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Any</span><span class="o">.</span><span class="nc">Type</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">bridgeToObjectiveC</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">ObjectiveCType</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">func</span> <span class="n">bridgeFromObjectiveC</span><span class="o">(</span><span class="n">source</span><span class="k">:</span> <span class="kt">ObjectiveCType</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Self</span><span class="o">?</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><code>Reflectable</code> <code>Mirror</code></h3>

<p>这个具体暂时不清楚。反射相关的两个 protocol 。</p>

<h3><code>Sequence</code> <code>Generator</code></h3>

<p>这两个用于 Swift 的 for-in 循环，简单说就是，实现了 <code>Sequence</code> 协议的对象可以 <code>.generate()</code> 出一个 <code>Generator</code>，
然后 <code>Generator</code> 可以不断地 <code>.next()</code> 返回 <code>Type?</code>，其中 <code>Type</code> 是这个序列的泛型。</p>

<h3><code>Hashable</code> <code>Equatable</code></h3>

<p>英汉字典拿来。所以其实为了让 Objective-C 类型在 Swift 代码中正常工作，这个是必不可少的。</p>

<h1>第一部分，类型交互</h1>

<h2>For 类、方法、协议</h2>

<p>通过 <code>@objc(name)</code> 转为 Swift 定义。其中 name 为 Objective-C 下的名字。</p>

<p>例如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@objc</span><span class="o">(</span><span class="nc">NSNumber</span><span class="o">)</span> <span class="k">class</span> <span class="nc">NSNumber</span> <span class="k">:</span> <span class="kt">NSValue</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">@objc</span><span class="o">(</span><span class="kt">init</span><span class="o">)</span> <span class="kt">convenience</span> <span class="kt">init</span><span class="o">()</span>
</span><span class='line'>    <span class="kt">@objc</span> <span class="kt">var</span> <span class="kt">integerValue:</span> <span class="kt">Int</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">@objc</span><span class="o">(</span><span class="kt">integerValue</span><span class="o">)</span> <span class="kt">get</span> <span class="o">{}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kt">...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kt">@objc</span><span class="o">(</span><span class="kt">NSCopying</span><span class="o">)</span> <span class="kt">protocol</span> <span class="kt">NSCopying</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">@objc</span><span class="o">(</span><span class="kt">copyWithZone:</span><span class="o">)</span> <span class="kt">func</span> <span class="kt">copyWithZone</span><span class="o">(</span><span class="kt">zone:</span> <span class="kt">NSZone</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">AnyObject!</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有可能为 <code>nil</code> 的指针类型几乎都被转为 <code>Type!</code>，由于 <code>ImplicitlyUnwrappedOptional</code> 的特性，所以几乎用起来一样。</p>

<h2>For 基础数字类型</h2>

<p><code>Int</code>, <code>UInt</code>, <code>Float</code>, <code>Double</code> 均实现了 <code>_BridgedToObjectiveC</code>, 其中类型参数 <code>ObjectiveCType</code> 均为 <code>NSNumber</code>。</p>

<p>也就是说，可以直接 <code>.getObjectiveCType()</code> 获取到 <code>NSNumber</code>，然后剩下的就很熟悉了。</p>

<p><code>NSNumber</code> 实现了 <code>FloatLiteralConvertible</code>, <code>IntegerLiteralConvertible</code>，所以其实，也可以直接从 Swift 字面常量获得。</p>

<h2>For Bool</h2>

<p>实际上 Objective-C 中的 <code>BOOL</code> 是某一数字类型，<code>YES</code>, <code>NO</code> 也分别是 1, 0 。</p>

<p>所以 Swift <code>Bool</code> 实现了 <code>_BridgedToObjectiveC</code>，对应于 <code>NSNumber</code> 类型。</p>

<h2>For String</h2>

<p><code>NSString</code> 实现了 <code>StringLiteralConvertible</code>，可以直接通过字面常量获得，同时还有到 <code>String</code> 的隐式类型转换。</p>

<p><code>String</code> 实现了 <code>_BridgedToObjectiveC</code> 对应于 <code>NSString</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">NSString</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@conversion</span> <span class="n">func</span> <span class="nc">__conversion</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是为什么官方文档说 Swift 中 <code>String</code> 和 Objective-C 基本是相同操作的。其实都是背后的隐式类型转换。</p>

<p>同时 Foundation 还为 <code>String</code> 扩充了很多方法，发现几个比较有意思的是 <code>._ns</code>，直接返回 <code>NSString</code>, <code>._index(Int)</code> 返回 <code>String.Index</code>，等等。</p>

<h2>For Array</h2>

<p><code>NSArray</code> 实现了 <code>ArrayLiteralConvertible</code>， 可以从字面常量直接获得。还实现了到 <code>AnyObject[]</code> 的隐式类型转换。</p>

<p><code>Array&lt;T&gt;</code> 实现了 <code>_ConditionallyBridgedToObjectiveC</code>, 对应于 <code>NSArray</code>.</p>

<p><code>NSArray</code> 还实现了 <code>Sequence</code> 协议，也就是可以通过 for-in 操作。其中 <code>generate()</code> 返回 <code>NSFastGenerator</code> 类，这个应该是在原有 Foundation 没有的。
当然 <code>.next()</code> 返回 <code>AnyObject?</code></p>

<h2>For Dictionary</h2>

<p><code>NSDictionary</code> 实现了 <code>DictionaryLiteralConvertible</code>, <code>Sequence</code>。同时还实现了到 <code>Dictionary&lt;NSObject, AnyObject&gt;</code> 的隐式类型转换。</p>

<p><code>Dictionary&lt;KeyType, ValueType&gt;</code> 实现了到 <code>NSDictionary</code> 的隐式类型转换。实现了 <code>_ConditionallyBridgedToObjectiveC</code> 对应于 <code>NSDictionary</code>。</p>

<h2>其他扩充类型</h2>

<p>新类型 <code>NSRange</code>，实现了 <code>_BridgedToObjectiveC</code>，对应于 <code>NSValue</code>，实现了到 <code>Range&lt;Int&gt;</code> 的隐式类型转换。</p>

<p><code>NSMutableSet</code> <code>NSMutableDictionary</code> <code>NSSet</code> <code>NSMutableArray</code> 均实现了 <code>Sequence</code> 可以 for-in .</p>

<h1>第二部分：从 Swift 调用 Objective-C</h1>

<p>一般说来，你在 Swift 项目新建 Objective-C 类的时候，直接弹出是否创建 Bridge Header 的窗口，点 YES 就是了，这时候一般多出来个 <code>ProjectName-Bridging-Header.h</code> 。</p>

<p>如果没有自动的话，这个配置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。</p>

<p>说到底，其实是调用编译命令的 <code>-import-objc-header</code> 参数，后面加上这个 Header 文件。</p>

<p>然后你就可以把你的 Objective-C Class 的 .h 文件都 import 到这个 Herder 文件里了。</p>

<p>所有 Swift 代码都可以直接调用。完全透明，自动生成。</p>

<h1>第三部分：从 Objective-C 调用 Swift</h1>

<p>头文件是 <code>ProjectName-Swift.h</code>。直接 import 。</p>

<p>不要吝啬你的键盘大量地加入 <code>@objc</code> 属性就是了。</p>

<p>具体实现据我猜测是这样，先 swift 调用 <code>-emit-objc-header</code> <code>-emit-objc-header-path</code> 参数控制生成 Objective-C 的 Header，同时 swift 编译为模块，然后再编译一次。</p>

<p>头文件内容大概是会包含一堆宏定义。然后是 Swift 的类定义等。这里可以看到 Swift 的 mangling 名字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">SWIFT_CLASS</span><span class="o">(</span><span class="s">&quot;_TtC5Hello11AppDelegate&quot;</span><span class="o">)</span>
</span><span class='line'><span class="nd">@interface</span> <span class="nc">AppDelegate</span> <span class="k">:</span> <span class="kt">UIResponder</span> <span class="kt">&lt;UIApplicationDelegate&gt;</span>
</span><span class='line'><span class="nd">@property</span> <span class="o">(</span><span class="n">nonatomic</span><span class="o">)</span> <span class="nc">UIWindow</span> <span class="o">*</span> <span class="n">window</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="nc">BOOL</span><span class="o">)</span><span class="n">application</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span> <span class="kt">didFinishLaunchingWithOptions:</span><span class="o">(</span><span class="kt">NSDictionary</span> <span class="kt">*</span><span class="o">)</span><span class="kt">launchOptions</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillResignActive</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationDidEnterBackground</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillEnterForeground</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationDidBecomeActive</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillTerminate</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">instancetype</span><span class="o">)</span><span class="n">init</span> <span class="nc">OBJC_DESIGNATED_INITIALIZER</span><span class="o">;</span>
</span><span class='line'><span class="nd">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h1>第四部分：一个 Swift 和 Objective-C 混合项目的编译过程</h1>

<p>这里只先考虑一个 Swift 项目使用 Objective-C 代码的情况，这个应该暂时比较多见（使用旧的 MVC 代码，用新的 Swift 创建 ui 一类）。</p>

<ul>
<li>编译所有 <code>X.swift</code> 文件到 <code>X.o</code> (with <code>-emit-objc-header</code>, <code>-import-objc-header</code>) (其中包含 <code>.swiftmodule</code> 子过程)

<ul>
<li>由于选项里有 <code>-emit-objc-header</code>，所以之后的 Objective-C 文件可以直接 import 对应的 <code>ProjectName-Swift.h</code></li>
</ul>
</li>
<li>编译 <code>X.m</code> 到 <code>X.o</code></li>
<li>链接所有 <code>.o</code> 生成可执行文件</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/09/swift-any-star/">Swift Any*</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-09T00:40:52+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">typealias</span> <span class="nc">Any</span> <span class="k">=</span> <span class="n">protocol</span><span class="o">&lt;&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">typealias</span> <span class="nc">AnyClass</span> <span class="k">=</span> <span class="nc">AnyObject</span><span class="o">.</span><span class="nc">Type</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@class_protocol</span> <span class="n">protocol</span> <span class="nc">AnyObject</span> <span class="o">{</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Also there is another type:</span>
</span><span class='line'><span class="nc">Any</span><span class="o">.</span><span class="nc">Type</span>
</span></code></pre></td></tr></table></div></figure>


<p>Metatype Type</p>

<p>“The metatype of a class, structure, or enumeration type is the name of that type followed by .Type. The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by .Protocol. For example, the metatype of the class type SomeClass is SomeClass.Type and the metatype of the protocol SomeProtocol is SomeProtocol.Protocol.”</p>

<p>摘录来自: Apple Inc. “The Swift Programming Language”。 iBooks. <a href="https://itun.es/cn/jEUH0.l">https://itun.es/cn/jEUH0.l</a></p>

<p>“You can use the postfix self expression to access a type as a value. For example, SomeClass.self returns SomeClass itself, not an instance of SomeClass. And SomeProtocol.self returns SomeProtocol itself, not an instance of a type that conforms to SomeProtocol at runtime. You can use a dynamicType expression with an instance of a type to access that instance’s runtime type as a value”</p>

<p>摘录来自: Apple Inc. “The Swift Programming Language”。 iBooks. <a href="https://itun.es/cn/jEUH0.l">https://itun.es/cn/jEUH0.l</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/08/swift-implicit-type-cast/">Implicit Type Convertion in Swift (Swift 的隐式类型转换)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-08T00:25:43+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这是我自己给的命名，因为这个特性暂时看是 undocumented 的。通过 lldb 和 Xcode 的变量 inspector 功能发掘出来的。然后尝试调用没有问题。</p>

<p>This is an undocumented feature. I found it by lldb and the variable inspector of Xcode6-beta.</p>

<p>形式: <code>@conversion func __conversion&lt;T&gt;() -&gt; T { }</code></p>

<p>对了 Reddit 网友提出 <code>@conversion</code> 是可以省略的。个人认为编译器可能对不同的两种方式行为略有不同，最好还是加上。还有就是 <code>@transparent</code> 其实是表示 inline 。</p>

<p>先随便设想个场合。比如我们某个库需要表示一个二维点。</p>

<p>Suppose we need a Point type in our library.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">struct</span> <span class="nc">Point</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">p</span> <span class="k">=</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="err">23</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="err">45</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>相信看了几天的 Swift，信手捏来啊。啧啧。
然后你发现你的另个库已经用了 (Int, Int) 来表示二维点了。。。。。你的把手头一堆的 Point 在转成 (Int, Int)，或者加个什么方法。？</p>

<p>For some reason, we need to work with another library, which uses <code>(Int, Int)</code> as the representation of a point.
Must we refacotr the code and add type conversion function calls?</p>

<p>妈蛋重构么？</p>

<p>No no~~</p>

<p>我们这样来</p>

<p>复习下 extension 语法, 加上这里要介绍的“隐式类型转换”</p>

<p>We can use the Swift&rsquo;s hiding feature &ndash; Implicit Type Convertion(or to say Cast?).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">Point</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@conversion</span> <span class="n">func</span> <span class="nc">__conversion</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>赞爆了。然后我们就可以这么写</p>

<p>The we can directly make a <code>(Int, Int)</code> from a <code>Point</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">let</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span>
</span><span class='line'><span class="c1">// suppose: func drawPoint(pt: (Int,Int)) { }</span>
</span><span class='line'><span class="n">drawPoint</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>你看无痛苦吧。然后所有需要 (Int, Int) 参数的函数，直接传递 Point 类型是没有任何问题的。（这个我也很吃惊，理论上这个玩意还是有个推导过程的，会有BUG什么的，没想到老crash 的 Swift 编译器竟然这个做得很好)</p>

<p>好吧这个例子实在是太渣了。我们换个例子说。</p>

<p>假设，我们有个库函数，接受 Color struct (r, g, b 三原色表示) 作为参数。
比如调用  <code>setColor(Color(r:23, g:34, b:34))</code>
然后实际上颜色我们用字符串表示，比如"white", &ldquo;black&rdquo; 或者 UInt32 表示比如 #ffeeff 。。。</p>

<p>然后为了方便，我们本来需要写一些转换函数，然后调用。</p>

<p>现在不同了，比如我们给 String 写个 隐式转换，代码里直接用。（用protocol 也可以实现相同的功能）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">String</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@conversion</span> <span class="n">func</span> <span class="nc">__conversion</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Color</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">switch</span> <span class="n">self</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="s">&quot;red&quot;</span><span class="k">:</span>
</span><span class='line'>            <span class="kt">return</span> <span class="kt">Color</span><span class="o">(</span><span class="kt">r:</span><span class="err">255</span><span class="o">,</span> <span class="kt">g:</span><span class="err">0</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="err">0</span><span class="o">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="s">&quot;green&quot;</span><span class="k">:</span>
</span><span class='line'>            <span class="kt">return</span> <span class="kt">Color</span><span class="o">(</span><span class="kt">r:</span><span class="err">0</span><span class="o">,</span> <span class="kt">g:</span><span class="err">255</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span><span class="err">0</span><span class="o">)</span>
</span><span class='line'>        <span class="o">.....</span>
</span><span class='line'>        <span class="n">default</span><span class="k">:</span>
</span><span class='line'>            <span class="kt">return</span> <span class="kt">Color</span><span class="o">(</span><span class="kt">r:</span><span class="err">0</span><span class="o">,</span> <span class="kt">g:</span><span class="err">0</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span><span class="err">0</span><span class="o">)</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后代码里用到 Color 的地方你直接写个 &ldquo;red&rdquo; 啊 &ldquo;pink&rdquo; 骚粉啊。都是没有问题的。
setColor(&ldquo;red&rdquo;)</p>

<p>上面都是废话。</p>

<p>隐式类型转换标准： <code>@conversion func __conversion&lt;T&gt;() -&gt; T { }</code> 可以作为方法写到 struct 里。也可以通过 extension 附加。</p>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。</p>

<p>然后就是语言本身中有个细小的问题 微博 onevcat 文章里提到。</p>

<p>nil 是 NilType 的唯一实例（来自Python的同学对这种定义一定不陌生)
而 Type? 是 Optional<Type> 类型的，是个enum，变种是  Some(T) 和 None.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">enum</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>  <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">None</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">T</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那同学你有没有想到 ，我们为什么可以给一个 Type? 赋值 nil 呢?</p>

<p>答案就是这里讲到的 隐式类型转换。</p>

<p>In Swift standard library, the unique <code>nil</code> has a type of <code>NilType</code> and is the only instance. And <code>Type?</code> is the
shortcut to <code>Option&lt;T&gt;</code>， an enum.</p>

<p>Why we can directly set a <code>Type?</code> variable to <code>nil</code>?</p>

<p>The Implicit Types Convertion is the answer. The <code>NilType</code> implements conversion methed to <code>Type?</code> and <code>Type!</code>.</p>

<p>I&rsquo;ve dump the definitions from lldb. You can find them in:</p>

<p>我导出的一些标准库定义在下面的链接。</p>

<p><a href="https://github.com/andelf/Defines-Swift/blob/master/Swift-misc.swift">My Github Repo</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/06/swift-attributes/">Swift Attributes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-06T17:12:53+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>@availability(*, unavailable, message=&ldquo;a Message&rdquo;)</h2>

<p>to disable a func?</p>

<h2>@asmname(&ldquo;a_name&rdquo;)</h2>

<p>Undocumented Attributes By me. :)</p>

<p>@asmname(&ldquo;swift_xxxx&rdquo;) func funname(&hellip;)</p>

<p>Builtin asm symbol. maybe internal functions.</p>

<p>这里用于调用 C 函数。相当于与 Objective-C 交互时候用的 @objc(name)。避免名字冲突，也可以相当于别名。</p>

<p>使用方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">println</span><span class="p">()</span> <span class="p">{</span> <span class="p">....</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">@</span><span class="n">asmname</span><span class="p">(</span><span class="s">&quot;println&quot;</span><span class="p">)</span> <span class="n">func</span> <span class="n">c_println</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">CInt</span><span class="p">;</span> <span class="c1">// 声明</span>
</span><span class='line'><span class="n">c_println</span><span class="p">()</span> <span class="c1">// 调用</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是 C 中的同名函数，我们可以给赋予一个别名，然后正常调用。</p>

<p>同时也用于指定 Swift 导出符号的名字，用于在 C 语言调用。</p>

<p>详细参考 <a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">简析Swift和C的交互</a></p>

<h2>@transparent</h2>

<p>用在函数、方法定义前，根据 lldb 和 llvm ir 猜测，作用相当于 inline。内联函数。</p>

<p>需要扯一点 Swift 的编译，会生成 <code>.swiftmodule</code>，这个文件里包含信息更多，引用外部 <code>.swiftmodule</code> 时候，inline 仍然有效。</p>

<h2>@assignment</h2>

<p>用于重载操作符时表示赋值副作用。参数类型需要标记为 <code>inout</code>。参考运算符重载的那篇文章。</p>

<p><a href="http://andelf.github.io/blog/2014/06/06/swift-operator-overload/">Swift 运算符重载、自定义运算符</a></p>

<h2>@final</h2>

<p>这个好像没什么多说的。文档里有。类似 java 的 <code>final</code>，C井中的 <code>sealed</code>。</p>

<h2>@conversion</h2>

<p>参考上面的一篇。隐式类型转换好了。</p>

<p><a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">Implicit Type Convertion in Swift //Swift 的隐式类型转换</a></p>

<h2>@noreturn</h2>

<p>表示函数不返回它的调用者。类似于 Rust 的 Buttom Type。</p>

<p>实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@noreturn</span> <span class="nd">@transparent</span> <span class="n">func</span> <span class="n">fatalError</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">StaticString</span><span class="o">,</span> <span class="n">file</span><span class="k">:</span> <span class="kt">StaticString</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">line</span><span class="k">:</span> <span class="kt">UWord</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行后打印出错消息，退出。</p>

<h2>@auto_closure</h2>

<p>用于函数参数类型前，表示一个空参数的 closure，调用时直接以语句的方式创建 closure，很自然。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">func</span> <span class="n">simpleAssert</span><span class="o">(</span><span class="n">condition</span><span class="k">:</span> <span class="kt">@auto_closure</span> <span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">Bool</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">!</span><span class="n">condition</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">println</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">testNumber</span> <span class="k">=</span> <span class="mi">5</span>
</span><span class='line'><span class="n">simpleAssert</span><span class="o">(</span><span class="n">testNumber</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;testNumber isn&#39;t an even number.&quot;</span><span class="o">)</span>
</span><span class='line'><span class="c1">// prints &quot;testNumber isn&#39;t an even number.</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>simpleAssert</code> 中第一个参数，实际上是自动创建了一个 closure。文档中有详细描述。</p>

<h2>@IBAction, @IBDesignable, @IBInspectable, and @IBOutlet</h2>

<p>同 Objective-C</p>

<h2>@objc @objc(name:name:)</h2>

<p>参考文档。</p>

<h2>@objc_block</h2>

<h2>@class_protocol</h2>

<h2>@required</h2>

<h2>@optional</h2>

<h2>@UIApplicationMain</h2>

<h2>@NSManaged</h2>

<h2>@NSCopying</h2>

<h2>@lazy</h2>

<p>In class property:</p>

<pre><code>@lazy let prop_name: PropType = PropType()
</code></pre>

<h2>@exported</h2>

<p>e.g.</p>

<p>@exported import ModName</p>

<h2>@sil_weak</h2>

<h2>@sil_unowned</h2>

<h2>@sil_unmanaged</h2>

<p>猜测是语言内部表示一个属性禁用 ARC？</p>

<p>Safety Integrity Level</p>

<h2>@sil_self</h2>

<h2>@opened(&hellip;)</h2>

<h2>@cc(&hellip;)</h2>

<h2>@autoreleased</h2>

<h2>@objc_metatype</h2>

<h2>@LLDBDebuggerFunction</h2>

<h2>@requires_stored_property_inits</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@requires_stored_property_inits</span> <span class="k">class</span> <span class="nc">Point</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<h2>only in sil modules</h2>

<ul>
<li>@callee_unowned</li>
<li>@callee_owned</li>
<li>@callee_guaranteed</li>
<li>@guaranteed</li>
<li>@out</li>
<li>@thin</li>
<li>@thick</li>
<li>@owned</li>
</ul>


<h2>unused</h2>

<p>这里可以看到一些 Swift 的历史变迁。4 年也不算很短。</p>

<ul>
<li>@lvalue</li>
<li>@unchecked

<ul>
<li>&lsquo;@unchecked T?&rsquo; syntax is going away, use &rsquo;T!'</li>
</ul>
</li>
<li>@inout

<ul>
<li>@inout is no longer an attribute 应该是现在的 inout 关键字</li>
</ul>
</li>
<li>@unowned

<ul>
<li>&lsquo;@unowned&rsquo; is not an attribute, use the &lsquo;unowned&rsquo; keyword instead</li>
</ul>
</li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/22/rust-pattern-match/">Rust Pattern Match(Rust中的模式匹配)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/18/guangzhou-realtime-bus/">广州实时工具App逆向</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/09/swift-2-dot-0-error-handling/">Swift 2.0 的错误处理(Swift 2.0 Error Handling)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/01/beijing-realtime-bus/">北京实时公交分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/23/swift-3rd-library-install-as-swift-modules/">为第三方扩展创建 Swift 模块</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/08/swift-beta3-changes/">Swift Beta3 Changes ( Swift 在 Beta3 中的变化）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/07/use-swift-dynamic-library/">Use Swift Dynamic Framework （如何科学地引用第三方 Swift 库)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/04/swift-undocumented-grammar/">Swift Undocumented Grammar （Swift 黑语法）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/04/cocoa-in-swift/">Cocoa Extensions in Swift ( Cocoa 在 Swift 中所添加的扩展）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/30/swift-type-hierarchy/">Swift Type Hierarchy ( Swift 类型层次结构 ）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/30/my-view-of-swift/">My View of Swift （闲扯对 Swift 语言的看法）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/28/swift-interop-with-c-slash-objc/">Swift Interop With C/ObjC Part 3 (Swift 与 ObjC 和 C 的交互，第三部分）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/25/tilde-arrow-in-swift/">Tilde Arrow in Swift （Swift 标准库中的波浪箭头 ~> ）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/25/write-swift-module-with-swift-cont/">Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/23/use-cocoapods-with-swift/">Use CocoaPods With Swift (在 Swift 中使用 CocoaPods）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/20/swift-reflection/">Swift Reflection （Swift 的反射）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/18/swift-and-c-interop-cont/">Swift and C Interop Cont. (简析 Swift 和 C 的交互，Part 二)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/17/nsobject-pattern-match-in-swift/">NSObject Pattern Match in Swift (简析 Swift 中的 Pattern Match)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/andelf">@andelf</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'andelf',
            count: 2,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/+WangMaomao?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 猫·仁波切 (Feather) -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'andelf';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
