<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Swift Reflection （Swift 的反射） | 猫·仁波切</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Swift Reflection （Swift 的反射）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Swift 其实是支持反射的，不过功能略弱。本文介绍基本的反射用法和相关类型。" />
<meta property="og:description" content="Swift 其实是支持反射的，不过功能略弱。本文介绍基本的反射用法和相关类型。" />
<link rel="canonical" href="https://andelf.github.io/blog/2014/06/20/swift-reflection/" />
<meta property="og:url" content="https://andelf.github.io/blog/2014/06/20/swift-reflection/" />
<meta property="og:site_name" content="猫·仁波切" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-06-20T23:48:51+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Swift Reflection （Swift 的反射）" />
<script type="application/ld+json">
{"url":"https://andelf.github.io/blog/2014/06/20/swift-reflection/","headline":"Swift Reflection （Swift 的反射）","dateModified":"2014-06-20T23:48:51+08:00","datePublished":"2014-06-20T23:48:51+08:00","description":"Swift 其实是支持反射的，不过功能略弱。本文介绍基本的反射用法和相关类型。","mainEntityOfPage":{"@type":"WebPage","@id":"https://andelf.github.io/blog/2014/06/20/swift-reflection/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://andelf.github.io/feed.xml" title="猫·仁波切" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">猫·仁波切</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Swift Reflection （Swift 的反射）</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-06-20T23:48:51+08:00" itemprop="datePublished">Jun 20, 2014
      </time></p><p>Tags: swift</p></p>

  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Swift 其实是支持反射的，不过功能略弱。本文介绍基本的反射用法和相关类型。</p>

<h2 id="metatype-和-type-语法">MetaType 和 Type 语法</h2>

<blockquote>
  <p>The metatype of a class, structure, or enumeration type is the name of that type followed by .Type. The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by .Protocol. For example, the metatype of the class type SomeClass is SomeClass.Type and the metatype of the protocol SomeProtocol is SomeProtocol.Protocol.</p>
</blockquote>

<blockquote>
  <p>You can use the postfix self expression to access a type as a value. For example, SomeClass.self returns SomeClass itself, not an instance of SomeClass. And SomeProtocol.self returns SomeProtocol itself, not an instance of a type that conforms to SomeProtocol at runtime.</p>
</blockquote>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>metatype-type -&gt; <code class="language-plaintext highlighter-rouge">type</code>.<strong>Type</strong></td>
          <td><code class="language-plaintext highlighter-rouge">type</code>.<strong>Protocol</strong></td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>type-as-value -&gt; <code class="language-plaintext highlighter-rouge">type</code>.self</li>
</ul>

<p>其中 metatype-type 出现在代码中需要类型的地方， type-as-value 出现在代码中需要值、变量的地方。</p>

<p><code class="language-plaintext highlighter-rouge">Any.Type</code> 类型大家可以猜下它表示什么。</p>

<h2 id="基础定义">基础定义</h2>

<p>反射信息用 <code class="language-plaintext highlighter-rouge">Mirror</code> 类型表示，类型协议是 <code class="language-plaintext highlighter-rouge">Reflectable</code>，但实际看起来 <code class="language-plaintext highlighter-rouge">Reflectable</code> 没有任何作用。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Reflectable {
  func getMirror() -&gt; Mirror
}
protocol Mirror {
  var value: Any { get }
  var valueType: Any.Type { get }
  var objectIdentifier: ObjectIdentifier? { get }
  var count: Int { get }
  subscript (i: Int) -&gt; (String, Mirror) { get }
  var summary: String { get }
  var quickLookObject: QuickLookObject? { get }
  var disposition: MirrorDisposition { get }
}
</code></pre></div></div>

<p>实际上所有类型都实现了 <code class="language-plaintext highlighter-rouge">Reflectable</code>。</p>

<p><code class="language-plaintext highlighter-rouge">Mirror</code> 协议相关字段：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">value</code> 相当于变量的 <code class="language-plaintext highlighter-rouge">as Any</code> 操作</li>
  <li><code class="language-plaintext highlighter-rouge">valueType</code> 获得变量类型</li>
  <li><code class="language-plaintext highlighter-rouge">objectIdentifier</code> 相当于一个 UInt 作用未知，可能是 metadata 表用到</li>
  <li><code class="language-plaintext highlighter-rouge">count</code> 子项目个数（可以是类、结构体的成员变量，也可以是字典，数组的数据）</li>
  <li><code class="language-plaintext highlighter-rouge">subscript(Int)</code> 访问子项目, 和子项目的名字</li>
  <li><code class="language-plaintext highlighter-rouge">summary</code> 相当于 <code class="language-plaintext highlighter-rouge">description</code></li>
  <li><code class="language-plaintext highlighter-rouge">quickLookObject</code> 是一个枚举，这个在 WWDC 有讲到，就是 Playground 代码右边栏的显示内容，比如常见类型，颜色，视图都可以</li>
  <li><code class="language-plaintext highlighter-rouge">disposition</code> 表示变量类型的性质，基础类型 or 结构 or 类 or 枚举 or 索引对象 or … 如下</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum MirrorDisposition {
  case Struct // 结构体
  case Class // 类
  case Enum // 枚举
  case Tuple // 元组
  case Aggregate // 基础类型
  case IndexContainer // 索引对象
  case KeyContainer // 键-值对象
  case MembershipContainer // 未知
  case Container // 未知
  case Optional // Type?
  var hashValue: Int { get }
}
</code></pre></div></div>

<p>通过函数 <code class="language-plaintext highlighter-rouge">func reflect&lt;T&gt;(x: T) -&gt; Mirror</code> 可以获得反射对象 <code class="language-plaintext highlighter-rouge">Mirror</code> 。它定义在 <code class="language-plaintext highlighter-rouge">Any</code> 上，所有类型均可用。</p>

<h2 id="实际操作">实际操作</h2>

<h3 id="valuetype-处理"><code class="language-plaintext highlighter-rouge">.valueType</code> 处理</h3>

<p><code class="language-plaintext highlighter-rouge">Any.Type</code> 是所有类型的元类型，所以 <code class="language-plaintext highlighter-rouge">.valueType</code> 属性表示类型。实际使用的时候还真是有点诡异：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let mir = reflect(someVal)
swith mir.valueType {
case _ as String.Type:
    println("type = string")
case _ as Range&lt;Int&gt;.Type:
    println("type = range of int")
case _ as Dictionary&lt;Int, Int&gt;.Type:
    println("type = dict of int")
case _ as Point.Type:
    println("type = a point struct")
default:
    println("unkown type")
}
</code></pre></div></div>

<p>或者使用 <code class="language-plaintext highlighter-rouge">is</code> 判断：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if mir.valueType is String.Type {
    println("!!!type =&gt; String")
}
</code></pre></div></div>

<p>勘误： 这里之前笔误了。遗漏了 <code class="language-plaintext highlighter-rouge">.valueType</code> 。</p>

<p><code class="language-plaintext highlighter-rouge">is String</code> 判断变量是否是 String 类型，而 <code class="language-plaintext highlighter-rouge">is String.Type</code> 这里用来判断类型是否是 String 类型。</p>

<h3 id="subscriptint-处理"><code class="language-plaintext highlighter-rouge">subscript(Int)</code> 处理</h3>

<p>实测发现直接用 <code class="language-plaintext highlighter-rouge">mir[0]</code> 访问偶尔会出错，也许是 beta 的原因。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for r in 0..mir.count {
    let (name, subref) = mir[r]
    prtln("name: \(name)")
    // visit sub Mirror here
}
</code></pre></div></div>

<p>通过上面的方法，基本上可以遍历大部分结构。</p>

<h2 id="不同类型的处理">不同类型的处理</h2>

<h3 id="struct-结构体-class-类">Struct 结构体、 Class 类</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.count</code> 为字段个数。</li>
  <li><code class="language-plaintext highlighter-rouge">subscript(Int)</code> 返回 （字段名，字段值反射 <code class="language-plaintext highlighter-rouge">Mirror</code>） 元组</li>
  <li><code class="language-plaintext highlighter-rouge">summary</code> 为 mangled name</li>
</ul>

<h3 id="tuple-元组">Tuple 元组</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.count</code> 为元组子元素个数</li>
  <li><code class="language-plaintext highlighter-rouge">subscript(Int)</code> 的 name 为 “.0”, “.1” …</li>
</ul>

<h3 id="aggregate-基础类型">Aggregate 基础类型</h3>

<p>包括数字、字符串（含 <code class="language-plaintext highlighter-rouge">NSString</code>）、函数、部分 Foundation 类型、 MetaType 。</p>

<p>很奇怪一点是测试发现枚举也被反射为基础类型。怀疑是没实现完。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.count</code> 为 0</li>
</ul>

<h3 id="indexcontainer-索引对象">IndexContainer 索引对象</h3>

<p>包括 <code class="language-plaintext highlighter-rouge">Array&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">T[]</code>, <code class="language-plaintext highlighter-rouge">NSArray</code> 等。可以通过 subscript 访问。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.count</code> 为元组子元素个数</li>
  <li><code class="language-plaintext highlighter-rouge">subscript(Int)</code> 的 name 为 “[0]”, “[1]” …</li>
</ul>

<h3 id="keycontainer-键-值对象">KeyContainer 键-值对象</h3>

<p>包括 <code class="language-plaintext highlighter-rouge">Dictionary&lt;T, U&gt;</code>、<code class="language-plaintext highlighter-rouge">NSDictionary</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.count</code> 为元组子元素个数</li>
  <li><code class="language-plaintext highlighter-rouge">subscript(Int)</code> 的 name 为 “[0]”, “[1]” … 实际访问是 <code class="language-plaintext highlighter-rouge">(name, (reflect(key), reflect(val)))</code></li>
</ul>

<h3 id="optional-type">Optional Type?</h3>

<p>只包括 <code class="language-plaintext highlighter-rouge">Type?</code>，不包括 <code class="language-plaintext highlighter-rouge">Type!</code>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.count</code> 为 0 或者 1 (对应 nil 和有值的情况)</li>
  <li><code class="language-plaintext highlighter-rouge">subscript(Int)</code> , name 为 “Some”</li>
</ul>

<h3 id="其他">其他</h3>

<ul>
  <li>Enum 枚举 看起来是未使用</li>
  <li>MembershipContainer // 未知</li>
  <li>Container // 未知</li>
</ul>

<h2 id="示例代码">示例代码</h2>

<p><a href="https://gist.github.com/anonymous/190fc7ecee30e83a5dca">Gist</a></p>

  </div>

  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://andelf.github.io/blog/2014/06/20/swift-reflection/';
      this.page.identifier = 'https://andelf.github.io/blog/2014/06/20/swift-reflection/';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://andelf.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<a class="u-url" href="/blog/2014/06/20/swift-reflection/" hidden></a>
</article>



  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://andelf.github.io/blog/2014/06/20/swift-reflection/';
      this.page.identifier = 'https://andelf.github.io/blog/2014/06/20/swift-reflection/';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://andelf.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>




      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">猫·仁波切</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">猫·仁波切</li><li><a class="u-email" href="mailto:andelf@gmail.com">andelf@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/andelf"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">andelf</span></a></li><li><a href="https://www.twitter.com/andelf"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">andelf</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>会研发的PM才是好OP.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
