
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互) - 猫·仁波切</title>
  <meta name="author" content="猫·仁波切 (Feather)">

  
  <meta name="description" content="主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。 瞎写的，有错或者不明白的地方直接告诉我。转载注明我或者 SwiftChina &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="猫·仁波切" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">猫·仁波切</a></h1>
  
    <h2>会研发的PM才是好OP.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:andelf.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-11T20:01:11+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。</p>

<p>瞎写的，有错或者不明白的地方直接告诉我。转载注明我或者 SwiftChina 。</p>

<p>参考资料是 我的 Github : <a href="https://github.com/andelf/Defines-Swift">andelf/Defines-Swift</a> 是我dump出的定义。10w行swift代码。</p>

<h1>预备知识</h1>

<h2>Objective-C (Cocoa) 特色</h2>

<p>数值类型统一用 <code>NSNumber</code>，不区分具体。大量操作在指针上进行，也就隐含着一切可能出错的调用都会返回 <code>nil</code>。
没有泛型支持，字典或者数组更多用 <code>id</code> 类型。</p>

<h2>对应 Swift 特色</h2>

<p>数值类型众多 （<code>Int, UInt, Float, Double, ...</code>），无指针（<code>UnsafePointer</code> 这类用于和其他代码交互的结构不计，<code>&amp;</code> + <code>inout</code> 认为是引用。）。
<code>nil</code> 用于 <code>Type?</code>, <code>Type!</code>。字典和数组用泛型表示。</p>

<h2>一些属性</h2>

<p>有几个属性用于和 Objective-C 之间的交互。</p>

<h3><code>@objc</code> 和 <code>@objc(a_name_defined_in_objc)</code></h3>

<h3><code>@objc_block</code></h3>

<p>用于函数类型前，标记后面的 block 是 Objective-C 的。个人觉得编译器会自动转换相关的 block 类型。</p>

<p>然后需要预备下几个属性的知识。</p>

<h3><code>@conversion</code></h3>

<p>Swift 中的隐式类型转换。有另一篇文章介绍。</p>

<h3><code>@final</code></h3>

<p>就是 final 了。</p>

<h3><code>@transparent</code></h3>

<p>经过反汇编查看，相当于 <code>inline</code> 的作用。同时生成的 <code>.swiftmodule</code> 文件依然带有原函数实现。这个很高大上。保证了 <code>inline</code> 特性在包外可用。</p>

<h2>重要 Swift protocol</h2>

<h3><code>*LiteralConvertible</code></h3>

<p>表示可以从 Swift 字面常量转换而得。比如 <code>let a: Type = 100</code>, 那么 Type 必须实现 IntegerLiteralConvertible。</p>

<p>大概有 IntegerLiteralConvertible, FloatLiteralConvertible, StringLiteralConvertible, ArrayLiteralConvertible, DictionaryLiteralConvertible, CharacterLiteralConvertible 等。</p>

<h3><code>_BridgedToObjectiveC</code> <code>_ConditionallyBridgedToObjectiveC</code></h3>

<p>顾名思义。就是相当于这个 Swift 类型可以和某一 Objective-C 类型对等，可以相互转换。</p>

<p>Conditional 多了个判断函数，也就是说这个类型可能是并没有对等起来的，什么情况下用呢，目前猜测应该是带泛型参数的类型中用到，有的泛型可以对应，有的不可以。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">_BridgedToObjectiveC</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="nc">ObjectiveCType</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">func</span> <span class="n">getObjectiveCType</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Any</span><span class="o">.</span><span class="nc">Type</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">bridgeToObjectiveC</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">ObjectiveCType</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">func</span> <span class="n">bridgeFromObjectiveC</span><span class="o">(</span><span class="n">source</span><span class="k">:</span> <span class="kt">ObjectiveCType</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Self</span><span class="o">?</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><code>Reflectable</code> <code>Mirror</code></h3>

<p>这个具体暂时不清楚。反射相关的两个 protocol 。</p>

<h3><code>Sequence</code> <code>Generator</code></h3>

<p>这两个用于 Swift 的 for-in 循环，简单说就是，实现了 <code>Sequence</code> 协议的对象可以 <code>.generate()</code> 出一个 <code>Generator</code>，
然后 <code>Generator</code> 可以不断地 <code>.next()</code> 返回 <code>Type?</code>，其中 <code>Type</code> 是这个序列的泛型。</p>

<h3><code>Hashable</code> <code>Equatable</code></h3>

<p>英汉字典拿来。所以其实为了让 Objective-C 类型在 Swift 代码中正常工作，这个是必不可少的。</p>

<h1>第一部分，类型交互</h1>

<h2>For 类、方法、协议</h2>

<p>通过 <code>@objc(name)</code> 转为 Swift 定义。其中 name 为 Objective-C 下的名字。</p>

<p>例如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@objc</span><span class="o">(</span><span class="nc">NSNumber</span><span class="o">)</span> <span class="k">class</span> <span class="nc">NSNumber</span> <span class="k">:</span> <span class="kt">NSValue</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">@objc</span><span class="o">(</span><span class="kt">init</span><span class="o">)</span> <span class="kt">convenience</span> <span class="kt">init</span><span class="o">()</span>
</span><span class='line'>    <span class="kt">@objc</span> <span class="kt">var</span> <span class="kt">integerValue:</span> <span class="kt">Int</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">@objc</span><span class="o">(</span><span class="kt">integerValue</span><span class="o">)</span> <span class="kt">get</span> <span class="o">{}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kt">...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kt">@objc</span><span class="o">(</span><span class="kt">NSCopying</span><span class="o">)</span> <span class="kt">protocol</span> <span class="kt">NSCopying</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">@objc</span><span class="o">(</span><span class="kt">copyWithZone:</span><span class="o">)</span> <span class="kt">func</span> <span class="kt">copyWithZone</span><span class="o">(</span><span class="kt">zone:</span> <span class="kt">NSZone</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">AnyObject!</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有可能为 <code>nil</code> 的指针类型几乎都被转为 <code>Type!</code>，由于 <code>ImplicitlyUnwrappedOptional</code> 的特性，所以几乎用起来一样。</p>

<h2>For 基础数字类型</h2>

<p><code>Int</code>, <code>UInt</code>, <code>Float</code>, <code>Double</code> 均实现了 <code>_BridgedToObjectiveC</code>, 其中类型参数 <code>ObjectiveCType</code> 均为 <code>NSNumber</code>。</p>

<p>也就是说，可以直接 <code>.getObjectiveCType()</code> 获取到 <code>NSNumber</code>，然后剩下的就很熟悉了。</p>

<p><code>NSNumber</code> 实现了 <code>FloatLiteralConvertible</code>, <code>IntegerLiteralConvertible</code>，所以其实，也可以直接从 Swift 字面常量获得。</p>

<h2>For Bool</h2>

<p>实际上 Objective-C 中的 <code>BOOL</code> 是某一数字类型，<code>YES</code>, <code>NO</code> 也分别是 1, 0 。</p>

<p>所以 Swift <code>Bool</code> 实现了 <code>_BridgedToObjectiveC</code>，对应于 <code>NSNumber</code> 类型。</p>

<h2>For String</h2>

<p><code>NSString</code> 实现了 <code>StringLiteralConvertible</code>，可以直接通过字面常量获得，同时还有到 <code>String</code> 的隐式类型转换。</p>

<p><code>String</code> 实现了 <code>_BridgedToObjectiveC</code> 对应于 <code>NSString</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">NSString</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@conversion</span> <span class="n">func</span> <span class="nc">__conversion</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是为什么官方文档说 Swift 中 <code>String</code> 和 Objective-C 基本是相同操作的。其实都是背后的隐式类型转换。</p>

<p>同时 Foundation 还为 <code>String</code> 扩充了很多方法，发现几个比较有意思的是 <code>._ns</code>，直接返回 <code>NSString</code>, <code>._index(Int)</code> 返回 <code>String.Index</code>，等等。</p>

<h2>For Array</h2>

<p><code>NSArray</code> 实现了 <code>ArrayLiteralConvertible</code>， 可以从字面常量直接获得。还实现了到 <code>AnyObject[]</code> 的隐式类型转换。</p>

<p><code>Array&lt;T&gt;</code> 实现了 <code>_ConditionallyBridgedToObjectiveC</code>, 对应于 <code>NSArray</code>.</p>

<p><code>NSArray</code> 还实现了 <code>Sequence</code> 协议，也就是可以通过 for-in 操作。其中 <code>generate()</code> 返回 <code>NSFastGenerator</code> 类，这个应该是在原有 Foundation 没有的。
当然 <code>.next()</code> 返回 <code>AnyObject?</code></p>

<h2>For Dictionary</h2>

<p><code>NSDictionary</code> 实现了 <code>DictionaryLiteralConvertible</code>, <code>Sequence</code>。同时还实现了到 <code>Dictionary&lt;NSObject, AnyObject&gt;</code> 的隐式类型转换。</p>

<p><code>Dictionary&lt;KeyType, ValueType&gt;</code> 实现了到 <code>NSDictionary</code> 的隐式类型转换。实现了 <code>_ConditionallyBridgedToObjectiveC</code> 对应于 <code>NSDictionary</code>。</p>

<h2>其他扩充类型</h2>

<p>新类型 <code>NSRange</code>，实现了 <code>_BridgedToObjectiveC</code>，对应于 <code>NSValue</code>，实现了到 <code>Range&lt;Int&gt;</code> 的隐式类型转换。</p>

<p><code>NSMutableSet</code> <code>NSMutableDictionary</code> <code>NSSet</code> <code>NSMutableArray</code> 均实现了 <code>Sequence</code> 可以 for-in .</p>

<h1>第二部分：从 Swift 调用 Objective-C</h1>

<p>一般说来，你在 Swift 项目新建 Objective-C 类的时候，直接弹出是否创建 Bridge Header 的窗口，点 YES 就是了，这时候一般多出来个 <code>ProjectName-Bridging-Header.h</code> 。</p>

<p>如果没有自动的话，这个配置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。</p>

<p>说到底，其实是调用编译命令的 <code>-import-objc-header</code> 参数，后面加上这个 Header 文件。</p>

<p>然后你就可以把你的 Objective-C Class 的 .h 文件都 import 到这个 Herder 文件里了。</p>

<p>所有 Swift 代码都可以直接调用。完全透明，自动生成。</p>

<h1>第三部分：从 Objective-C 调用 Swift</h1>

<p>头文件是 <code>ProjectName-Swift.h</code>。直接 import 。</p>

<p>不要吝啬你的键盘大量地加入 <code>@objc</code> 属性就是了。</p>

<p>具体实现据我猜测是这样，先 swift 调用 <code>-emit-objc-header</code> <code>-emit-objc-header-path</code> 参数控制生成 Objective-C 的 Header，同时 swift 编译为模块，然后再编译一次。</p>

<p>头文件内容大概是会包含一堆宏定义。然后是 Swift 的类定义等。这里可以看到 Swift 的 mangling 名字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">SWIFT_CLASS</span><span class="o">(</span><span class="s">&quot;_TtC5Hello11AppDelegate&quot;</span><span class="o">)</span>
</span><span class='line'><span class="nd">@interface</span> <span class="nc">AppDelegate</span> <span class="k">:</span> <span class="kt">UIResponder</span> <span class="kt">&lt;UIApplicationDelegate&gt;</span>
</span><span class='line'><span class="nd">@property</span> <span class="o">(</span><span class="n">nonatomic</span><span class="o">)</span> <span class="nc">UIWindow</span> <span class="o">*</span> <span class="n">window</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="nc">BOOL</span><span class="o">)</span><span class="n">application</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span> <span class="kt">didFinishLaunchingWithOptions:</span><span class="o">(</span><span class="kt">NSDictionary</span> <span class="kt">*</span><span class="o">)</span><span class="kt">launchOptions</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillResignActive</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationDidEnterBackground</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillEnterForeground</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationDidBecomeActive</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillTerminate</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
</span><span class='line'><span class="o">-</span> <span class="o">(</span><span class="n">instancetype</span><span class="o">)</span><span class="n">init</span> <span class="nc">OBJC_DESIGNATED_INITIALIZER</span><span class="o">;</span>
</span><span class='line'><span class="nd">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h1>第四部分：一个 Swift 和 Objective-C 混合项目的编译过程</h1>

<p>这里只先考虑一个 Swift 项目使用 Objective-C 代码的情况，这个应该暂时比较多见（使用旧的 MVC 代码，用新的 Swift 创建 ui 一类）。</p>

<ul>
<li>编译所有 <code>X.swift</code> 文件到 <code>X.o</code> (with <code>-emit-objc-header</code>, <code>-import-objc-header</code>) (其中包含 <code>.swiftmodule</code> 子过程)

<ul>
<li>由于选项里有 <code>-emit-objc-header</code>，所以之后的 Objective-C 文件可以直接 import 对应的 <code>ProjectName-Swift.h</code></li>
</ul>
</li>
<li>编译 <code>X.m</code> 到 <code>X.o</code></li>
<li>链接所有 <code>.o</code> 生成可执行文件</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">猫·仁波切 (Feather)</span></span>

      








  


<time datetime="2014-06-11T20:01:11+08:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/swift/'>swift</a>, <a class='category' href='/blog/categories/swift-interop/'>swift-interop</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/" data-via="andelf" data-counturl="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/06/09/swift-any-star/" title="Previous Post: Swift Any*">&laquo; Swift Any*</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/06/12/swift-string-extension-for-int-index/" title="Next Post: Swift String Extension for Integer Index(扩展String使之可以支持数字Index和数字Range)">Swift String Extension for Integer Index(扩展String使之可以支持数字Index和数字Range) &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/11/18/circleci-meets-rust/">在 CircleCI 上使用 Rust(CircleCI Meets Rust)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/16/play-homekit-with-ios-10-and-raspberry-pi/">折腾 Raspberry Pi + HomeKit 手记</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/28/a-glimpse-of-swift-3-dot-0/">Swift 3.0 尝试——从入门到再学一门(a Glimpse of Swift 3.0)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/22/rust-pattern-match/">Rust Pattern Match(Rust中的模式匹配)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/18/guangzhou-realtime-bus/">广州实时工具App逆向</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/09/swift-2-dot-0-error-handling/">Swift 2.0 的错误处理(Swift 2.0 Error Handling)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/01/beijing-realtime-bus/">北京实时公交分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/23/swift-3rd-library-install-as-swift-modules/">为第三方扩展创建 Swift 模块</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/08/swift-beta3-changes/">Swift Beta3 Changes ( Swift 在 Beta3 中的变化）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/07/use-swift-dynamic-library/">Use Swift Dynamic Framework （如何科学地引用第三方 Swift 库)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/04/swift-undocumented-grammar/">Swift Undocumented Grammar （Swift 黑语法）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/04/cocoa-in-swift/">Cocoa Extensions in Swift ( Cocoa 在 Swift 中所添加的扩展）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/30/swift-type-hierarchy/">Swift Type Hierarchy ( Swift 类型层次结构 ）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/30/my-view-of-swift/">My View of Swift （闲扯对 Swift 语言的看法）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/28/swift-interop-with-c-slash-objc/">Swift Interop With C/ObjC Part 3 (Swift 与 ObjC 和 C 的交互，第三部分）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/25/tilde-arrow-in-swift/">Tilde Arrow in Swift （Swift 标准库中的波浪箭头 ~> ）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/25/write-swift-module-with-swift-cont/">Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/23/use-cocoapods-with-swift/">Use CocoaPods With Swift (在 Swift 中使用 CocoaPods）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/20/swift-reflection/">Swift Reflection （Swift 的反射）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/andelf">@andelf</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'andelf',
            count: 2,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/+WangMaomao?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 猫·仁波切 (Feather) -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'andelf';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/';
        var disqus_url = 'http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
