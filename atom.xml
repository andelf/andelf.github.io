<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[猫·仁波切]]></title>
  <link href="http://andelf.github.io/atom.xml" rel="self"/>
  <link href="http://andelf.github.io/"/>
  <updated>2016-03-23T00:26:03+08:00</updated>
  <id>http://andelf.github.io/</id>
  <author>
    <name><![CDATA[猫·仁波切 (Feather)]]></name>
    <email><![CDATA[andelf@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rust Pattern Match(Rust中的模式匹配)]]></title>
    <link href="http://andelf.github.io/blog/2016/03/22/rust-pattern-match/"/>
    <updated>2016-03-22T23:35:19+08:00</updated>
    <id>http://andelf.github.io/blog/2016/03/22/rust-pattern-match</id>
    <content type="html"><![CDATA[<h1>模式匹配</h1>

<p>汉语字典中对“模式”的解释是：事物的标准样式。在计算机科学中，它指特定类型的数据（往往是序列或是树形结构）满足某一特定结构或格式。“匹配”本身是指一个判断寻找过程。最早的模式匹配用于文本编辑器中的正则字符串搜索，之后才作为编程语言特性。</p>

<h2>模式匹配基础</h2>

<p>模式匹配在计算机科学领域有两层意思。其一，可以特指字符串匹配算法，例如为人熟知的 KMP 字符串匹配算法、命令行工具 grep 等。
其二，特指在一些语言中作为一种以结构的方式处理数据的工具，此时的匹配过程往往是树形匹配，与此相伴的往往还有一个特性叫 guard（守卫）。</p>

<p>Rust 中模式匹配随处可见，例如在<code>let</code>变量绑定语句、<code>match</code>匹配语句中等。利用好模式匹配这一特性可以使代码更简洁易懂。<code>Rust</code>支持模式匹配中的变量绑定、结构体/元组解构、守卫条件判断、数值范围匹配等特性。</p>

<h3>原始匹配</h3>

<p><code>match</code> 语句中可以直接匹配字面常量，下划线<code>_</code>匹配任意情形。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kd">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
</span><span class='line'>    <span class="mi">1</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;one&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="mi">2</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;two&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="mi">3</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;three&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">_</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;anything&quot;</span><span class="p">),</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码会打印出<code>one</code>。</p>

<h3>结构匹配</h3>

<p><code>match</code> 用于匹配一个表达式的值，寻找满足条件的子分支(<code>arm</code>)并执行。每个子分支包含三部分：一系列模式、可选的守卫条件以及主体代码块。</p>

<h3>多个模式</h3>

<p>每个子分支可以是多个模式，通过 <code>|</code> 符号分割：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kd">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
</span><span class='line'>    <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;one or two&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="mi">3</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;three&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">_</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;anything&quot;</span><span class="p">),</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码打印出<code>one or two</code>。</p>

<h3>守卫条件</h3>

<p>通过<code>if</code>引入子分支的守卫条件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">enum</span> <span class="n">OptionalInt</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Value</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Missing</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">OptionalInt</span><span class="o">::</span><span class="n">Value</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">OptionalInt</span><span class="o">::</span><span class="n">Value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Got an int bigger than five!&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">OptionalInt</span><span class="o">::</span><span class="n">Value</span><span class="p">(..)</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Got an int!&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">OptionalInt</span><span class="o">::</span><span class="n">Missing</span> <span class="o">=&gt;</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;No such luck.&quot;</span><span class="p">),</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>模式匹配进阶</h2>

<p>其实进阶，不如直接从<code>libsyntax</code>源码看看到底模式匹配是如何实现。<code>syntax::ast::Pat</code>。</p>

<p>从AST源码中寻找语法要素屋外户两个要点，其一，语法要素是如何表达为对应AST的；其二，对应AST在哪些父AST中出现。</p>

<p>Rust中使用<code>syntax::ast::Pat</code>枚举来表示一个模式匹配。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">Pat</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">pub</span> <span class="n">id</span><span class="o">:</span> <span class="n">NodeId</span><span class="p">,</span>
</span><span class='line'>    <span class="k">pub</span> <span class="n">node</span><span class="o">:</span> <span class="n">PatKind</span><span class="p">,</span>
</span><span class='line'>    <span class="k">pub</span> <span class="n">span</span><span class="o">:</span> <span class="n">Span</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">pub</span> <span class="k">enum</span> <span class="n">PatKind</span> <span class="p">{</span>
</span><span class='line'>    <span class="c-Doc">/// Represents a wildcard pattern (`_`)</span>
</span><span class='line'>    <span class="c-Doc">/// 表示通配，下划线</span>
</span><span class='line'>    <span class="n">Wild</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="c-Doc">/// A `PatKind::Ident` may either be a new bound variable,</span>
</span><span class='line'>    <span class="c-Doc">/// or a unit struct/variant pattern, or a const pattern (in the last two cases</span>
</span><span class='line'>    <span class="c-Doc">/// the third field must be `None`).</span>
</span><span class='line'>    <span class="c-Doc">///</span>
</span><span class='line'>    <span class="c-Doc">/// In the unit or const pattern case, the parser can&#39;t determine</span>
</span><span class='line'>    <span class="c-Doc">/// which it is. The resolver determines this, and</span>
</span><span class='line'>    <span class="c-Doc">/// records this pattern&#39;s `NodeId` in an auxiliary</span>
</span><span class='line'>    <span class="c-Doc">/// set (of &quot;PatIdents that refer to unit patterns or constants&quot;).</span>
</span><span class='line'>    <span class="n">Ident</span><span class="p">(</span><span class="n">BindingMode</span><span class="p">,</span> <span class="n">SpannedIdent</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">),</span>
</span><span class='line'>
</span><span class='line'>    <span class="c-Doc">/// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.</span>
</span><span class='line'>    <span class="c-Doc">/// The `bool` is `true` in the presence of a `..`.</span>
</span><span class='line'>    <span class="n">Struct</span><span class="p">(</span><span class="nb">Path</span><span class="p">,</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">Spanned</span><span class="o">&lt;</span><span class="n">FieldPat</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">),</span>
</span><span class='line'>
</span><span class='line'>    <span class="c-Doc">/// A tuple struct/variant pattern `Variant(x, y, z)`.</span>
</span><span class='line'>    <span class="c-Doc">/// &quot;None&quot; means a `Variant(..)` pattern where we don&#39;t bind the fields to names.</span>
</span><span class='line'>    <span class="n">TupleStruct</span><span class="p">(</span><span class="nb">Path</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;&gt;</span><span class="p">),</span>
</span><span class='line'>
</span><span class='line'>    <span class="c-Doc">/// A path pattern.</span>
</span><span class='line'>    <span class="c-Doc">/// Such pattern can be resolved to a unit struct/variant or a constant.</span>
</span><span class='line'>    <span class="nb">Path</span><span class="p">(</span><span class="nb">Path</span><span class="p">),</span>
</span><span class='line'>
</span><span class='line'>    <span class="c-Doc">/// An associated const named using the qualified path `&lt;T&gt;::CONST` or</span>
</span><span class='line'>    <span class="c-Doc">/// `&lt;T as Trait&gt;::CONST`. Associated consts from inherent impls can be</span>
</span><span class='line'>    <span class="c-Doc">/// referred to as simply `T::CONST`, in which case they will end up as</span>
</span><span class='line'>    <span class="c-Doc">/// PatKind::Path, and the resolver will have to sort that out.</span>
</span><span class='line'>    <span class="n">QPath</span><span class="p">(</span><span class="n">QSelf</span><span class="p">,</span> <span class="nb">Path</span><span class="p">),</span>
</span><span class='line'>
</span><span class='line'>    <span class="c-Doc">/// A tuple pattern `(a, b)`</span>
</span><span class='line'>    <span class="n">Tup</span><span class="p">(</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">),</span>
</span><span class='line'>    <span class="c-Doc">/// A `box` pattern</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;</span><span class="p">),</span>
</span><span class='line'>    <span class="c-Doc">/// A reference pattern, e.g. `&amp;mut (a, b)`</span>
</span><span class='line'>    <span class="n">Ref</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Mutability</span><span class="p">),</span>
</span><span class='line'>    <span class="c-Doc">/// A literal</span>
</span><span class='line'>    <span class="n">Lit</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span>
</span><span class='line'>    <span class="c-Doc">/// A range pattern, e.g. `1...2`</span>
</span><span class='line'>    <span class="n">Range</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span>
</span><span class='line'>    <span class="c-Doc">/// `[a, b, ..i, y, z]` is represented as:</span>
</span><span class='line'>    <span class="c-Doc">///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`</span>
</span><span class='line'>    <span class="n">Vec</span><span class="p">(</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">),</span>
</span><span class='line'>    <span class="c-Doc">/// A macro pattern; pre-expansion</span>
</span><span class='line'>    <span class="n">Mac</span><span class="p">(</span><span class="n">Mac</span><span class="p">),</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上AST定义，即说明，到底什么被认为是一个“模式”。</p>

<p>以下介绍<code>Pat</code>在哪些AST中出现。</p>

<h3>全局 Item</h3>

<p>全局 Item 中，使用模式匹配的均为函数参数。</p>

<h4>ItemKind::Fn</h4>

<p><code>Fn</code> 全局函数 -> <code>FnDecl</code> 函数声明 -> <code>[Arg]</code> 函数头参数声明。</p>

<h4>ItemKind::Trait</h4>

<p><code>Trait</code> -> <code>[TraitItem]</code> -> <code>TraitItemKind::Method</code> -> <code>MethodSig</code> -> <code>FnDecl</code> 方法声明，同上。</p>

<h4>ItemKind::Impl</h4>

<p><code>Impl</code> -> <code>[ImplItem]</code> -> <code>ImplItemKind::Method</code> -> <code>MethodSig</code> -> <code>FnDecl</code>。</p>

<h3>ast::Stmt 语句</h3>

<h4>StmtKind::Decl</h4>

<p><code>Decl</code> -> <code>DeclKind::Local</code>。</p>

<p>即 <code>let</code> 语句 <code>let &lt;pat&gt;:&lt;ty&gt; = &lt;expr&gt;;</code>。</p>

<h4>StmtKind::Expr 表达式</h4>

<p>见下。</p>

<h3>ast::Expr</h3>

<p>除<code>match</code>外，<code>if let</code>、<code>while let</code>、<code>for</code>控制语句支持同时进行模式匹配。具体实现是一种<code>desugared</code>过程，即，去语法糖化。</p>

<p>同时类似于函数定义，闭包参数也支持模式匹配。</p>

<h4>if let</h4>

<p><code>IfLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;P&lt;Expr&gt;&gt;)</code></p>

<p><code>if let pat = expr { block } else { expr }</code></p>

<p>This is desugared to a match expression.</p>

<h4>while let</h4>

<p><code>WhileLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code>'label: while let pat = expr { block }</code></p>

<h4>for</h4>

<p><code>ForLoop(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code>'label: for pat in expr { block }</code></p>

<h4>match</h4>

<p><code>Match(P&lt;Expr&gt;, Vec&lt;Arm&gt;)</code></p>

<p><code>match</code> 语句，在 <code>Arm</code> 中出现，其中 <code>Arm</code> 定义为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">pub</span> <span class="k">struct</span> <span class="n">Arm</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">pub</span> <span class="n">attrs</span><span class="o">:</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="p">,</span>
</span><span class='line'>    <span class="k">pub</span> <span class="n">pats</span><span class="o">:</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">,</span>
</span><span class='line'>    <span class="k">pub</span> <span class="n">guard</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;&gt;</span><span class="p">,</span>
</span><span class='line'>    <span class="k">pub</span> <span class="n">body</span><span class="o">:</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>闭包</h4>

<p><code>Closure(CaptureBy, P&lt;FnDecl&gt;, P&lt;Block&gt;)</code></p>

<p>闭包，例如 <code>move |a, b, c| {a + b + c}</code>。</p>

<h2>相关 feature gate</h2>

<p><code>advanced_slice_patterns</code> - See the match expressions section for discussion; the exact semantics of slice patterns are subject to change, so some types are still unstable.</p>

<p><code>slice_patterns</code> - OK, actually, slice patterns are just scary and completely unstable.</p>

<p><code>box_patterns</code> - Allows box patterns, the exact semantics of which is subject to change.</p>

<h2>参考</h2>

<p><a href="https://doc.rust-lang.org/book/patterns.html">https://doc.rust-lang.org/book/patterns.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[广州实时工具App逆向]]></title>
    <link href="http://andelf.github.io/blog/2015/06/18/guangzhou-realtime-bus/"/>
    <updated>2015-06-18T17:39:06+08:00</updated>
    <id>http://andelf.github.io/blog/2015/06/18/guangzhou-realtime-bus</id>
    <content type="html"><![CDATA[<p>简记。用了 IDA Pro，安卓手机的 Remote 客户端。以及 apktool 等。</p>

<p><a href="https://github.com/andelf/guangzhou-realtime-bus">Github: guangzhou-realtime-bus</a></p>

<ul>
<li>生成 e=3 的 1024 位 RSA 密钥对</li>
<li>公钥串用查表加密(byte 映射)，然后 base64 封装发送给服务器</li>
<li>服务器返回一串用公钥加密过的数据</li>
<li>用本地私钥解密后，该数据包含未知96字节的一段数据和 DES Key</li>
<li>从此通信用 DES 加密</li>
</ul>


<p>base64封装过程：先打包字符串长度，然后是原始字符串（JSON），然后是<code>0x10</code>(md5字符串长度)，
然后是 md5 校验值。整个二进制字符串用 base64 转码，POST 给服务器。</p>

<p>具体的登录注册过程还需要进一步抓包分析，不过暂时兴趣不在这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 2.0 的错误处理(Swift 2.0 Error Handling)]]></title>
    <link href="http://andelf.github.io/blog/2015/06/09/swift-2-dot-0-error-handling/"/>
    <updated>2015-06-09T15:27:58+08:00</updated>
    <id>http://andelf.github.io/blog/2015/06/09/swift-2-dot-0-error-handling</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol ErrorType {
</span><span class='line'>  var _domain: String { get }
</span><span class='line'>  var _code: Int { get }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@asmname("swift_bridgeErrorTypeToNSError") func _bridgeErrorTypeToNSError(e: ErrorType) -&gt; AnyObject
</span><span class='line'>
</span><span class='line'>@asmname("swift_stdlib_getErrorCode") func _stdlib_getErrorCode&lt;T : ErrorType&gt;(x: UnsafePointer&lt;T&gt;) -&gt; Int
</span><span class='line'>
</span><span class='line'>@asmname("swift_stdlib_getErrorDomainNSString") func _stdlib_getErrorDomainNSString&lt;T : ErrorType&gt;(x: UnsafePointer&lt;T&gt;) -&gt; AnyObject</span></code></pre></td></tr></table></div></figure>


<h2>Foundation</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol _ObjectiveCBridgeableErrorType : ErrorType {
</span><span class='line'>  init?(_bridgedNSError: NSError)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct NSCocoaError : RawRepresentable, _BridgedNSError, _ObjectiveCBridgeableErrorType, ErrorType, __BridgedNSError, Hashable, Equatable {
</span><span class='line'>  let rawValue: Int
</span><span class='line'>  init(rawValue: Int)
</span><span class='line'>  static var _NSErrorDomain: String {
</span><span class='line'>    get {}
</span><span class='line'>  }
</span><span class='line'>  typealias RawValue = Int
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>infix func ==(a: _GenericObjCError, b: _GenericObjCError) -&gt; Bool
</span><span class='line'>infix func ==(a: _GenericObjCError, b: _GenericObjCError) -&gt; Bool
</span><span class='line'>func ==&lt;T : __BridgedNSError where T.RawValue : SignedIntegerType&gt;(lhs: T, rhs: T) -&gt; Bool
</span><span class='line'>
</span><span class='line'>@available(OSX 10.11, iOS 9.0, *)
</span><span class='line'>func resolveError(error: NSError?) throws
</span><span class='line'>
</span><span class='line'>enum _GenericObjCError : ErrorType {
</span><span class='line'>  case NilError
</span><span class='line'>  var hashValue: Int {
</span><span class='line'>    get {}
</span><span class='line'>  }
</span><span class='line'>  var _domain: String {
</span><span class='line'>    get {}
</span><span class='line'>  }
</span><span class='line'>  var _code: Int {
</span><span class='line'>    get {}
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@asmname("swift_stdlib_bridgeNSErrorToErrorType")
</span><span class='line'>func _stdlib_bridgeNSErrorToErrorType&lt;T : _ObjectiveCBridgeableErrorType&gt;(error: NSError, out: UnsafeMutablePointer&lt;T&gt;) -&gt; Bool
</span><span class='line'>
</span><span class='line'>@asmname("swift_convertNSErrorToErrorType") func _convertNSErrorToErrorType(error: NSError?) -&gt; ErrorType
</span><span class='line'>
</span><span class='line'>@objc enum NSURLError : Int, _BridgedNSError, _ObjectiveCBridgeableErrorType, ErrorType, __BridgedNSError { ... }
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>protocol __BridgedNSError : RawRepresentable {
</span><span class='line'>  static var _NSErrorDomain: String { get }
</span><span class='line'>}
</span><span class='line'>@asmname("swift_convertErrorTypeToNSError") func _convertErrorTypeToNSError(error: ErrorType) -&gt; NSError
</span><span class='line'>func ~=(match: NSCocoaError, error: ErrorType) -&gt; Bool
</span><span class='line'>protocol _BridgedNSError : __BridgedNSError, _ObjectiveCBridgeableErrorType, Hashable {
</span><span class='line'>  static var _NSErrorDomain: String { get }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ErrorType 在 Swift 中表示。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension NSError : ErrorType {
</span><span class='line'>  @objc dynamic var _domain: String {
</span><span class='line'>    @objc dynamic get {}
</span><span class='line'>  }
</span><span class='line'>  @objc dynamic var _code: Int {
</span><span class='line'>    @objc dynamic get {}
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[北京实时公交分析]]></title>
    <link href="http://andelf.github.io/blog/2015/06/01/beijing-realtime-bus/"/>
    <updated>2015-06-01T13:17:50+08:00</updated>
    <id>http://andelf.github.io/blog/2015/06/01/beijing-realtime-bus</id>
    <content type="html"><![CDATA[<p>361 条线路，705条单向线路。 aibang 负责数据服务。</p>

<p>每辆车，每15秒更新一次 GPS，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为第三方扩展创建 Swift 模块]]></title>
    <link href="http://andelf.github.io/blog/2015/01/23/swift-3rd-library-install-as-swift-modules/"/>
    <updated>2015-01-23T23:21:00+08:00</updated>
    <id>http://andelf.github.io/blog/2015/01/23/swift-3rd-library-install-as-swift-modules</id>
    <content type="html"><![CDATA[<p>本文提出了一种将第三方扩展引入到 Swift 标准库的方法。</p>

<p>以 Alamofire 为例，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd Path-To-Alamofire-Src-Dir
</span><span class='line'>mkdir -p 32 64
</span><span class='line'>
</span><span class='line'># 创建动态链接库，及对应 Swift 模块，32/64版本
</span><span class='line'>xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphoneos) Alamofire.swift -target arm64-apple-ios7.1 -target-cpu cyclone -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib
</span><span class='line'>
</span><span class='line'>mv Alamofire.swiftdoc Alamofire.swiftmodule libswiftAlamofire.dylib ./64
</span><span class='line'>
</span><span class='line'>xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphoneos) Alamofire.swift -target armv7-apple-ios7.1 -target-cpu cyclone -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib
</span><span class='line'>
</span><span class='line'>mv Alamofire.swiftdoc Alamofire.swiftmodule libswiftAlamofire.dylib ./64
</span><span class='line'>
</span><span class='line'># 创建 universal lib
</span><span class='line'>lipo -create ./{32,64}/libswiftAlamofire.dylib  -output ./libswiftAlamofire.dylib
</span><span class='line'>
</span><span class='line'># 创建模拟器用 lib
</span><span class='line'>xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphonesimulator) Alamofire.swift -target i386-apple-ios7.1 -target-cpu yonah -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib</span></code></pre></td></tr></table></div></figure>


<p>其他相关 target</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-target armv7-apple-ios7.1 -target-cpu cortex-a8
</span><span class='line'>-target arm64-apple-ios7.1 -target-cpu cyclone
</span><span class='line'>-target i386-apple-ios7.1 -target-cpu yonah
</span><span class='line'>-target x86_64-apple-ios7.1 -target-cpu core2</span></code></pre></td></tr></table></div></figure>


<p>其实你了解 Swift 模块结构的化，应该回想到，将第三方模块创建为 swiftmodule 应该是最靠谱的选择。不过实际操作发现，
编译命令无法很方便地调整，主要是因为 xcodebuild 系统，和编译命令不知道怎么导出。也是略纠结。</p>

<p>实际上，如果使用 Carthage 的话，即把第三方扩展作为 Framework 引入，会导致无法支持 iOS 7，但是 Swift 本身是支持 iOS 7 的，
在编译命令和生成的文件中检查发现，对于 iOS 7，Swift 使用了纯静态模块编译的方法。所以其实我们引入第三方扩展的时候也可以这样做。</p>

<p>以下是静态编译所需命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) SwiftyJSON.swift -c -parse-as-library -module-name SwiftyJSON -v -o SwiftyJSON.o
</span><span class='line'>
</span><span class='line'>ar rvs libswiftSwiftyJSON.a SwiftyJSON.o</span></code></pre></td></tr></table></div></figure>


<p>如何使用？</p>

<p>将编译结果扔到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift
</span><span class='line'>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift_static</span></code></pre></td></tr></table></div></figure>


<p>下对应目录。</p>

<p>然后在 Xcode 里，直接 import。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Beta3 Changes ( Swift 在 Beta3 中的变化）]]></title>
    <link href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/"/>
    <updated>2014-07-08T17:22:11+08:00</updated>
    <id>http://andelf.github.io/blog/2014/07/08/swift-beta3-changes</id>
    <content type="html"><![CDATA[<p>准确说是 beta2 <code>Swift version 1.0 (swift-600.0.34.4.8)</code> 到 beta3 <code>Swift version 1.0 (swift-600.0.38.7)</code> 的变化。</p>

<p>对了，补充下。 beta1 <code>Swift version 1.0 (swift-600.0.34.4.5)</code> 到 beta2 几乎没有什么变化。</p>

<h2>语法</h2>

<p><code>nil</code> 成为关键字。</p>

<p><code>[KeyType : ValueType]</code> 可以表示字典类型 <code>Dictionary&lt;KeyType, ValueType&gt;</code>。</p>

<p><code>[Type]</code> 用于表示原 Array 类型 <code>Type[]</code>，等价 <code>Array&lt;T&gt;</code>，原用法会导致警告。</p>

<p><del>增加 @noinline 属性</del></p>

<p><code>..</code> 运算符改为 <code>..&lt;</code>，不容易和 <code>...</code> 混淆。</p>

<h2>函数、类型</h2>

<p>原 <code>sort()</code> 改名为 <code>sorted()</code>。新增 <code>sort()</code> 函数，参数为 <code>inout</code>。</p>

<p>Index 类型中的 <code>.succ()</code> 变为 <code>.successor()</code>、 <code>.pred()</code> 变为 <code>.predecessor()</code>。</p>

<h2>C/ObjC 交互变化</h2>

<p>增加 <code>UnsafeMutableArray&lt;T&gt;</code> 类型。</p>

<p>增加 <code>CFunctionPointer&lt;T&gt;</code> 类型。</p>

<p>删除 <code>CConstVoidPointer</code>、 <code>CMutableVoidPointer</code>。替换为 <code>UnsafePointer&lt;()&gt;</code>、<code>ConstUnsafePointer&lt;Int32&gt;</code>。</p>

<p>删除 <code>CConstPointer&lt;T&gt;</code>、<code>CMutablePointer&lt;T&gt;</code>。替换为 <code>UnsafePointer&lt;T&gt;</code>、<code>ConstUnsafePointer&lt;T&gt;</code>。</p>

<p>这么一来指针操作简单了好多。原有会出现 <code>COpaquePointer</code> 的不合理情况，也都对应到适合的类型。</p>

<p><code>CString</code> 可以从 <code>UnsafePointer&lt;UInt8&gt;</code> 和 <code>UnsafePointer&lt;CChar&gt;</code> 两种类型构造获得，之前只支持 <code>UInt8</code>。</p>

<p>module.map 中头文件声明转换为 Swift 声明不再使用 C 兼容类型，直接使用 Swift 相应类型。原有 <code>CInt</code>，现在成为 <code>Int32</code>。</p>

<p>结构体会自动添加构造函数 <code>init(field1:field2:...)</code> 这样。</p>

<h3>nil</h3>

<p>去掉了 <code>NilType</code>，增加了 <code>NilLiteralConvertible</code>， <code>nil</code> 成为关键字。可以认为是 nil 常量。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol NilLiteralConvertible {
</span><span class='line'>  class func convertFromNilLiteral() -&gt; Self
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>除了 Optional 、上面所提到的指针类型外，<code>RawOptionSet</code> 也实现了该协议。</p>

<h3>Array</h3>

<p>去掉了 <code>.copy()</code>、<code>unshare()</code> 方法。</p>

<p>增加了以下方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeUnique(inout buffer: ArrayBuffer&lt;T&gt;, e: T, index: Int)
</span><span class='line'>func sorted(isOrderedBefore: (T, T) -&gt; Bool) -&gt; Array&lt;T&gt;</span></code></pre></td></tr></table></div></figure>


<p>看起来 <code>Array</code> 对底层容器的引用有了更好的控制 <code>ArrayBufferType</code> 增加了判断方法 <code>func isMutableAndUniquelyReferenced() -&gt; Bool</code>。</p>

<p>Array 目前可以认为是真正的值类型。</p>

<h3>指针</h3>

<h4>增加了 <code>_Pointer</code> protocol</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">_Pointer</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">RawPointer</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">init</span><span class="o">(</span><span class="k">_</span> <span class="kt">value:</span> <span class="kt">RawPointer</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>表示一个类型可以对应到原生指针。</p>

<p>同时成为内部桥接类型，编译器内部在转换时使用它（取出 RawPointer, 构造具体指针类型）。</p>

<h2>模块</h2>

<p>增加了  StdlibUnittest 模块。 <a href="https://github.com/andelf/Defines-Swift/blob/79ed8d40659e4d038f41e3c30b4b3358106bd50a/StdlibUnittest.swift">声明代码</a>。单元测试终于有了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Swift Dynamic Framework （如何科学地引用第三方 Swift 库)]]></title>
    <link href="http://andelf.github.io/blog/2014/07/07/use-swift-dynamic-library/"/>
    <updated>2014-07-07T12:09:54+08:00</updated>
    <id>http://andelf.github.io/blog/2014/07/07/use-swift-dynamic-library</id>
    <content type="html"><![CDATA[<p>排名 16 了。啧啧。你看才刚出一个月。</p>

<p>目前已经有了很多非常棒的 Swift 第三方库， JSON 处理啊、 HTTP 访问啊、 UIView 插件啊等等。</p>

<p>如何科学地引用这些第三方库呢？</p>

<h2>现状</h2>

<p>CocoaPods 由于完全使用静态链接解决方法，过度依赖 Objective-C ，目前应该是官方 repo 有提到是 <code>-Xlinker</code> error , 这个问题之前我也遇到过，无解。除非手工执行 <code>ar</code> 不用 <code>ld</code> 和 <code>libtool</code>。</p>

<p>小伙伴有用子目录的方法引用代码，貌似不错，还有就是直接用 <code>git submodule</code>，看起来维护性也可以。</p>

<h2>简单解决方案</h2>

<p>一个良好的第三方库应该实现为 Cocoa Touch Framework (实际内容为 Header + 动态链接库)。而不是直接把 Swift 代码 Copy 过来放入自己的项目。这里以一个简单项目为例，介绍如何科学使用。</p>

<h3>目标描述</h3>

<p>用 Swift 创建一个 Demo ，使用 SwiftyJSON 和 LTMorphingLabel 库。</p>

<p>项目的名字叫 DemoApp 。</p>

<h4>创建 Workspace</h4>

<p>创建一个 Workspace ，名字随意，位置能找到就好。这个 Workspace 主要用来管理我们的项目及其依赖的第三方库。</p>

<h4>创建 DemoApp</h4>

<p>在 Workspace 创建一个 App ，因为是测试所以我选了 Single View Application 。</p>

<h4>引入 SwiftyJSON</h4>

<p>SwiftyJSON 是一个 Cocoa Touch Framework ，可以直接使用， <code>git clone</code> 后，添加项目到 Workspace 即可。</p>

<p>尝试操作发现。。最容易最不会出错的方法就是直接从 Finder 里把 <code>.xcodeproj</code> 文件拖动到 Workspace 。</p>

<h4>引入 LTMorphingLabel</h4>

<p>LTMorphingLabel 是一个 App Deme 式项目。其中 Label View 的实现在一个子目录中。可以采用创建 Cocoa
Touch Framework 的方法来引入这几个文件。</p>

<p>当然也可以直接把目录拖到我们的 DemoApp 里，不过太原始粗暴了。</p>

<h4>为 App 添加依赖</h4>

<p>在 DemoApp 的 Genral 选项卡中，添加 Linked Frameworks and Libraries 。选择  Workspace 中 SwiftyJSON 和
LTMorphingLabel 两个 <code>.framework</code> 。</p>

<p>如果是直接选择来自其他项目的 <code>.framework</code> 而不是同一 Workspace ，那么这里也许还要同时加入 <code>Embedded Binaries</code>。</p>

<h4>使用</h4>

<p>添加好依赖后，就可以在 DemoApp 项目代码中 <code>import SwiftyJSON</code> 或者 <code>import LTMorphingLabel</code> 来使用对应的库。同时还可以用 Command + 鼠标点击的方法查看声明代码。</p>

<h4>除错</h4>

<p>比较坑爹的是，实际上按照以上方法， <code>LTMorphingLabel</code> 并不能正常使用，查看报错信息发现是自动生成的 <code>LTMorphingLabel-Swift.h</code> 有处语法无法被识别，编辑器找到 <code>.h</code> 文件，注释掉这行诡异代码即可。</p>

<p>看起来目前的 Bridge Header 和 -emit-objc-header 实现还是有问题的。小伙伴一定要淡定。</p>

<h2>对于非 Workspace</h2>

<p>如果不喜欢使用 Workspace ，也可以将第三方库的编译结果，一个 <code>.framework</code> 目录拖到项目文件里，然后添加 <code>Embedded Binaries</code>。</p>

<h2>评论</h2>

<p>创建 Cocoa Touch Framework 选项中，可以使用 Swift 代码，此时编译结果（默认）会包含 <code>module.modulemap</code> 文件，
之前有介绍过它的作用，通过它， Swift 可以使用第三方模块。参考 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a> 。</p>

<p>实际上这个解决方案绕了一大圈，通过 Swift 文件导出 <code>ProjName-Swift.h</code>、然后 <code>module.modulemap</code> 模块描述文件引入、然后再由 Swift 导入。</p>

<p>其实 <code>.framework</code> 同时也包含了 <code>ProjName.swiftmodule/[ARCH].swiftmodule</code> 不过看起来没有使用到，而且默认在 IDE 下也不支持 Swift 从 <code>.swiftmodule</code> 文件导入，比较坑。希望以后版本能加入支持。</p>

<p><code>.framework</code> 包含了所有 Swift 标准库的动态链接库，小伙伴可能会以为这会导致编译后的 App 变大。其实大可放心，任何 Swift 语言的 App 都会包含这些动态链接库，而且只会包含一个副本。此方法对 App 最终的大小几乎无影响。</p>

<p>注： 个人测试了下，发现这个 <code>.swiftmodule</code> 是可以通过其他方法使用的，绕过 <code>module.modulemap</code>，应该是更佳的解决方案，但是需要控制命令行参数。</p>

<p>至于静态链接库，过时了。抛弃吧。</p>

<h2>参考</h2>

<ul>
<li><a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont/">Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Undocumented Grammar （Swift 黑语法）]]></title>
    <link href="http://andelf.github.io/blog/2014/07/04/swift-undocumented-grammar/"/>
    <updated>2014-07-04T03:05:11+08:00</updated>
    <id>http://andelf.github.io/blog/2014/07/04/swift-undocumented-grammar</id>
    <content type="html"><![CDATA[<p>本文介绍 Swift 的 Undocumented 语法特性。</p>

<p>电子书上介绍的 default function parameter 这里都不好意思拿出来写。</p>

<p>咳咳。持续更新。</p>

<h2>用关键字当变量名</h2>

<p>Keywards as variable name.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// escaped variable name</span>
</span><span class='line'><span class="n">let</span> <span class="n">`let`</span> <span class="k">=</span> <span class="mi">1000</span>
</span><span class='line'><span class="n">dump</span><span class="o">(</span><span class="n">`let`</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="err">&quot;</span><span class="kt">variable</span> <span class="kt">named</span> <span class="kt">let</span><span class="err">&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2><code>new</code> 关键字</h2>

<p>The <code>new</code> keyword.</p>

<p>快速初始化数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">let</span> <span class="n">an_array_with_100_zero</span> <span class="k">=</span> <span class="k">new</span><span class="o">(</span><span class="nc">Int</span><span class="o">)[</span><span class="err">100</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>protocol type</h2>

<p>use <code>protocol&lt;Protocol1, Protocol2, ...&gt;</code> as a type.</p>

<h2>How I find it?</h2>

<p>瞎试出来的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa Extensions in Swift ( Cocoa 在 Swift 中所添加的扩展）]]></title>
    <link href="http://andelf.github.io/blog/2014/07/04/cocoa-in-swift/"/>
    <updated>2014-07-04T01:05:55+08:00</updated>
    <id>http://andelf.github.io/blog/2014/07/04/cocoa-in-swift</id>
    <content type="html"><![CDATA[<p>最近看到了 <a href="https://github.com/raywenderlich/swift-style-guide">Swift Style Guide</a> 个人觉得内容太少，
Swift 本身作为一门庞大的语言，语素众多。本文就 Swift 本身对 Cocoa 的扩展，看看对日常 Cocoa 风格有什么影响。</p>

<p>Swift 本身的特性，导致它在一些用法上和 Objective-C 上有所不同，比如 ObjC 的 struct 单纯和 C 的一样，但是在 Swift
中的 struct 则要强大得多。</p>

<p>个人认为比如 <code>CGPointMake</code> 这样的函数，理论上不应该出现在 Swift 代码中。而是应该用 <code>CGPoint(x:y:)</code>。</p>

<p>本文可以作为参考手册使用。</p>

<h2>标准库扩展</h2>

<h3>ObjectiveC</h3>

<p>值得注意的是 Selector 相关方法，实现了 <code>StringLiteralConvertible</code>。也可以从 <code>nil</code> 获得。</p>

<h3>Foundation</h3>

<p>这里忽略之前介绍过的 <code>_BridgedToObjectiveC</code> 相关内容。</p>

<h4>协议附加</h4>

<p>Sequence 协议</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray NSSet NSArray NSMutableDictionary NSMutableSet NSDictionary</span></code></pre></td></tr></table></div></figure>


<p>所有以上这些类型都可以通过 for-in 操作。</p>

<p>*LiteralConvertible</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSNumber NSString NSArray NSDictionary</span></code></pre></td></tr></table></div></figure>


<h4>隐式类型转换</h4>

<p>CF 几乎都对应到了 NS 类型。这里略去</p>

<ul>
<li><code>NilType</code> -> <code>NSZone</code></li>
<li><code>Dictionary&lt;KeyType: Hashable, ValueType&gt;</code> -> <code>NSDictionary</code></li>
<li><code>NSDictionary</code> -> <code>Dictionary&lt;NSObject, AnyObject&gt;</code></li>
<li><code>String</code> <-> <code>NSString</code></li>
<li><code>NSArray</code> -> <code>AnyObject[]</code></li>
<li><code>A[]</code> -> <code>NSArray</code></li>
<li><code>Float Double Int UInt Bool</code> -> <code>NSNumber</code></li>
<li><code>NSRange</code> -> <code>Range&lt;Int&gt;</code> // 比较有意思的一个</li>
</ul>


<h4>方法扩展</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// let s = NSSet(objects: 12, 32, 23, 12)</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">NSSet</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">convenience</span> <span class="n">init</span><span class="o">(</span><span class="n">objects</span> <span class="n">elements</span><span class="k">:</span> <span class="kt">AnyObject...</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">NSOrderedSet</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">convenience</span> <span class="n">init</span><span class="o">(</span><span class="n">objects</span> <span class="n">elements</span><span class="k">:</span> <span class="kt">AnyObject...</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">// 这里注意，NSRange 和 Swift Range 对 range 结束的表述方法不同</span>
</span><span class='line'><span class="c1">// NSRange 保存 range 元素个数</span>
</span><span class='line'><span class="c1">// Swift Range 保存的是结束元素</span>
</span><span class='line'><span class="c1">// let r = NSRange(0..20)</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">NSRange</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="k">_</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Range&lt;Int&gt;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">// let prop = NSDictionary(objectsAndKeys: &quot;Feather&quot;, &quot;name&quot;, &quot;Programming&quot;, &quot;hobby&quot;)</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">NSDictionary</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">convenience</span> <span class="n">init</span><span class="o">(</span><span class="n">objectsAndKeys</span> <span class="n">objects</span><span class="k">:</span> <span class="kt">AnyObject...</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">NSObject</span> <span class="k">:</span> <span class="kt">CVarArg</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">@objc</span> <span class="kt">func</span> <span class="kt">encode</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">Word</span><span class="o">[]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>字符串的扩展方法非常多。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">availableStringEncodings</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">NSStringEncoding</span><span class="o">[]</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">defaultCStringEncoding</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">NSStringEncoding</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">localizedNameOfStringEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">localizedStringWithFormat</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">_</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">pathWithComponents</span><span class="o">(</span><span class="n">components</span><span class="k">:</span> <span class="kt">String</span><span class="o">[])</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">stringWithContentsOfFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">stringWithContentsOfFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">usedEncoding</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;NSStringEncoding&gt;</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">stringWithContentsOfURL</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">NSURL</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">stringWithContentsOfURL</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">NSURL</span><span class="o">,</span> <span class="n">usedEncoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;NSStringEncoding&gt;</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">stringWithCString</span><span class="o">(</span><span class="n">cString</span><span class="k">:</span> <span class="kt">CString</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">stringWithUTF8String</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">CString</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">canBeConvertedToEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">capitalizedString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">capitalizedStringWithLocale</span><span class="o">(</span><span class="kt">locale:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">caseInsensitiveCompare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">commonPrefixWithString</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">compare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">mask</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">completePathIntoString</span><span class="o">(</span><span class="k">_</span> <span class="n">outputName</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String&gt;</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">caseSensitive</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">,</span> <span class="n">matchesIntoArray</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String</span><span class="o">[]&gt;</span> <span class="k">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">filterTypes</span><span class="k">:</span> <span class="kt">String</span><span class="o">[]?</span> <span class="k">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Int</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">componentsSeparatedByCharactersInSet</span><span class="o">(</span><span class="n">separator</span><span class="k">:</span> <span class="kt">NSCharacterSet</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">componentsSeparatedByString</span><span class="o">(</span><span class="n">separator</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">cStringUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CChar</span><span class="o">[]?</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">dataUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">allowLossyConversion</span><span class="k">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSData</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">decomposedStringWithCanonicalMapping</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">decomposedStringWithCompatibilityMapping:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">enumerateLines</span><span class="o">(</span><span class="kt">body:</span> <span class="o">(</span><span class="kt">line:</span> <span class="kt">String</span><span class="o">,</span> <span class="kt">inout</span> <span class="kt">stop:</span> <span class="kt">Bool</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="o">())</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">enumerateLinguisticTagsInRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">scheme</span> <span class="n">tagScheme</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">opts</span><span class="k">:</span> <span class="kt">NSLinguisticTaggerOptions</span><span class="o">,</span> <span class="n">orthography</span><span class="k">:</span> <span class="kt">NSOrthography?</span><span class="o">,</span> <span class="k">_</span> <span class="n">body</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">.</span><span class="nc">Index</span><span class="o">&gt;,</span> <span class="n">inout</span> <span class="nc">Bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">())</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">enumerateSubstringsInRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">options</span> <span class="n">opts</span><span class="k">:</span> <span class="kt">NSStringEnumerationOptions</span><span class="o">,</span> <span class="k">_</span> <span class="n">body</span><span class="k">:</span> <span class="o">(</span><span class="kt">substring:</span> <span class="kt">String</span><span class="o">,</span> <span class="kt">substringRange:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">enclosingRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">inout</span> <span class="nc">Bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">())</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">fastestEncoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">fileSystemRepresentation</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">CChar</span><span class="o">[]</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">getBytes</span><span class="o">(</span><span class="n">inout</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">UInt8</span><span class="o">[],</span> <span class="n">maxLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">usedLength</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;Int&gt;</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">options</span><span class="k">:</span> <span class="kt">NSStringEncodingConversionOptions</span><span class="o">,</span> <span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">remainingRange</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;Range&lt;String.Index&gt;&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">getCString</span><span class="o">(</span><span class="n">inout</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">CChar</span><span class="o">[],</span> <span class="n">maxLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">getFileSystemRepresentation</span><span class="o">(</span><span class="n">inout</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">CChar</span><span class="o">[],</span> <span class="n">maxLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">getLineStart</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">contentsEnd</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">forRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">getParagraphStart</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">contentsEnd</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">forRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">hash</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">static</span> <span class="kt">func</span> <span class="kt">stringWithBytes</span><span class="o">(</span><span class="kt">bytes:</span> <span class="kt">UInt8</span><span class="o">[],</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">stringWithBytesNoCopy</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">CMutableVoidPointer</span><span class="o">,</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">freeWhenDone</span> <span class="n">flag</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">utf16CodeUnits</span><span class="k">:</span> <span class="kt">CConstPointer&lt;unichar&gt;</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">utf16CodeUnitsNoCopy</span><span class="k">:</span> <span class="kt">CConstPointer&lt;unichar&gt;</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">freeWhenDone</span> <span class="n">flag</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">)</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">_</span> <span class="nc">_arguments</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg</span><span class="o">[])</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span><span class="o">,</span> <span class="k">_</span> <span class="n">args</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span><span class="o">,</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg</span><span class="o">[])</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">lastPathComponent</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">utf16count:</span> <span class="kt">Int</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">lengthOfBytesUsingEncoding</span><span class="o">(</span><span class="kt">encoding:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">lineRangeForRange</span><span class="o">(</span><span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">.</span><span class="nc">Index</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">linguisticTagsInRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">scheme</span> <span class="n">tagScheme</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">opts</span><span class="k">:</span> <span class="kt">NSLinguisticTaggerOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">orthography</span><span class="k">:</span> <span class="kt">NSOrthography?</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">tokenRanges</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;Range&lt;String.Index&gt;</span><span class="o">[]&gt;</span> <span class="k">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">localizedCaseInsensitiveCompare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">localizedCompare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">localizedStandardCompare</span><span class="o">(</span><span class="n">string</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">lowercaseStringWithLocale</span><span class="o">(</span><span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">maximumLengthOfBytesUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Int</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">paragraphRangeForRange</span><span class="o">(</span><span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">.</span><span class="nc">Index</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">pathComponents</span><span class="k">:</span> <span class="kt">String</span><span class="o">[]</span> <span class="o">{</span> <span class="n">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">pathExtension</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">precomposedStringWithCanonicalMapping:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">precomposedStringWithCompatibilityMapping:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">propertyList</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">AnyObject</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">propertyListFromStringsFileFormat</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Dictionary</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rangeOfCharacterFromSet</span><span class="o">(</span><span class="n">aSet</span><span class="k">:</span> <span class="kt">NSCharacterSet</span><span class="o">,</span> <span class="n">options</span> <span class="n">mask</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span> <span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">.</span><span class="nc">Index</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rangeOfComposedCharacterSequenceAtIndex</span><span class="o">(</span><span class="n">anIndex</span><span class="k">:</span> <span class="kt">String.Index</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">.</span><span class="nc">Index</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rangeOfComposedCharacterSequencesForRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">.</span><span class="nc">Index</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rangeOfString</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">mask</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span> <span class="n">searchRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">.</span><span class="nc">Index</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">smallestEncoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">stringByAbbreviatingWithTildeInPath</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByAddingPercentEncodingWithAllowedCharacters</span><span class="o">(</span><span class="n">allowedCharacters</span><span class="k">:</span> <span class="kt">NSCharacterSet</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByAddingPercentEscapesUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByAppendingFormat</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">_</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByAppendingPathComponent</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByAppendingPathExtension</span><span class="o">(</span><span class="n">ext</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByAppendingString</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">stringByDeletingLastPathComponent</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">stringByDeletingPathExtension:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">stringByExpandingTildeInPath:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">stringByFoldingWithOptions</span><span class="o">(</span><span class="kt">options:</span> <span class="kt">NSStringCompareOptions</span><span class="o">,</span> <span class="kt">locale:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByPaddingToLength</span><span class="o">(</span><span class="n">newLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">withString</span> <span class="n">padString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">startingAtIndex</span> <span class="n">padIndex</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">stringByRemovingPercentEncoding</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">stringByReplacingCharactersInRange</span><span class="o">(</span><span class="kt">range:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="kt">withString</span> <span class="kt">replacement:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByReplacingOccurrencesOfString</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">withString</span> <span class="n">replacement</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span> <span class="n">searchRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringByReplacingPercentEscapesUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">stringByResolvingSymlinksInPath</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">stringByStandardizingPath:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">stringByTrimmingCharactersInSet</span><span class="o">(</span><span class="kt">set:</span> <span class="kt">NSCharacterSet</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">stringsByAppendingPaths</span><span class="o">(</span><span class="n">paths</span><span class="k">:</span> <span class="kt">String</span><span class="o">[])</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">substringFromIndex</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">substringToIndex</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">substringWithRange</span><span class="o">(</span><span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">uppercaseStringWithLocale</span><span class="o">(</span><span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">writeToFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">atomically</span> <span class="n">useAuxiliaryFile</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">writeToURL</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">NSURL</span><span class="o">,</span> <span class="n">atomically</span> <span class="n">useAuxiliaryFile</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span></code></pre></td></tr></table></div></figure>


<h3>CoreGraphics</h3>

<p>几个常用基本类型都有了 Swift-style 的构造函数。其中 <code>CGRect</code> 有很多的相关运算都被封装为方法，很不错。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">CGPoint</span> <span class="k">:</span> <span class="kt">Equatable</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">static</span> <span class="kt">var</span> <span class="kt">zeroPoint:</span> <span class="kt">CGPoint</span>
</span><span class='line'>  <span class="kt">init</span><span class="o">()</span>
</span><span class='line'>  <span class="kt">init</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">CGSize</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">static</span> <span class="k">var</span> <span class="n">zeroSize</span><span class="k">:</span> <span class="kt">CGSize</span>
</span><span class='line'>  <span class="n">init</span><span class="o">()</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">CGVector</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">static</span> <span class="k">var</span> <span class="n">zeroVector</span><span class="k">:</span> <span class="kt">CGVector</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="k">_</span> <span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="k">_</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="k">_</span> <span class="n">dx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">_</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">CGRect</span> <span class="k">:</span> <span class="kt">Equatable</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// 全为 0</span>
</span><span class='line'>  <span class="kt">static</span> <span class="kt">var</span> <span class="kt">zeroRect:</span> <span class="kt">CGRect</span>
</span><span class='line'>  <span class="c1">// 原点为无穷大，表示空</span>
</span><span class='line'>  <span class="n">static</span> <span class="k">var</span> <span class="n">nullRect</span><span class="k">:</span> <span class="kt">CGRect</span>
</span><span class='line'>  <span class="c1">// 原点无穷小，宽高无穷大</span>
</span><span class='line'>  <span class="n">static</span> <span class="k">var</span> <span class="n">infiniteRect</span><span class="k">:</span> <span class="kt">CGRect</span>
</span><span class='line'>  <span class="n">init</span><span class="o">()</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">width</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">height</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">minX</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">minY</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="c1">// 中点</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">midX</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">midY</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">maxX</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">maxY</span><span class="k">:</span> <span class="kt">CGFloat</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">isNull</span><span class="k">:</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">isInfinite</span><span class="k">:</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">standardizedRect</span><span class="k">:</span> <span class="kt">CGRect</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">standardize</span><span class="o">()</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">integerRect</span><span class="k">:</span> <span class="kt">CGRect</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">integerize</span><span class="o">()</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rectByInsetting</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">inset</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rectByOffsetting</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">offset</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rectByUnion</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">union</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rectByIntersecting</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">intersect</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">rectsByDividing</span><span class="o">(</span><span class="n">atDistance</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">fromEdge</span><span class="k">:</span> <span class="kt">CGRectEdge</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">slice</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">,</span> <span class="n">remainder</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">contains</span><span class="o">(</span><span class="n">rect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">contains</span><span class="o">(</span><span class="n">point</span><span class="k">:</span> <span class="kt">CGPoint</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">intersects</span><span class="o">(</span><span class="n">rect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>AppKit</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">NSGradient</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">convenience</span> <span class="n">init</span><span class="o">(</span><span class="n">colorsAndLocations</span> <span class="n">objects</span><span class="k">:</span> <span class="o">(</span><span class="kt">AnyObject</span><span class="o">,</span> <span class="kt">CGFloat</span><span class="o">)...)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>UIKit</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">UIDeviceOrientation</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">isPortrait</span><span class="k">:</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="c1">// also isLandscape isValidInterfaceOrientation isFlat </span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nc">UIInterfaceOrientation</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">isPortrait</span><span class="k">:</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">isLandscape</span><span class="k">:</span> <span class="kt">Bool</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个模块是交叉编译的。。不太容易获得信息。不过好在扩展内容不多。</p>

<h3>SpriteKit</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">extension</span> <span class="nc">SKNode</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@objc</span> <span class="n">subscript</span> <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">SKNode</span><span class="o">[]</span> <span class="o">{</span> <span class="n">get</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>特殊 Mirror 实现</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">NSSet</span> <span class="nc">NSDate</span> <span class="nc">NSArray</span> <span class="nc">NSRange</span> <span class="nc">NSURL</span> <span class="nc">NSDictionary</span> <span class="nc">NSString</span>
</span><span class='line'><span class="nc">CGPoint</span> <span class="nc">CGRect</span> <span class="nc">CGSize</span>
</span><span class='line'><span class="nc">NSView</span>
</span><span class='line'><span class="nc">UIView</span>
</span><span class='line'><span class="nc">SKTextureAtlas</span> <span class="nc">SKTexture</span> <span class="nc">SKSpriteNode</span> <span class="nc">SKShapeNode</span>
</span></code></pre></td></tr></table></div></figure>


<p>单独添加了自己的 <code>Mirror</code> 类型，单独实现。</p>

<p><code>Mirror</code> 类型其实是为 <code>QuickLookObject</code> 准备的，也就是在 Xcode Playground 中快速查看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Type Hierarchy ( Swift 类型层次结构 ）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/30/swift-type-hierarchy/"/>
    <updated>2014-06-30T15:10:41+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/30/swift-type-hierarchy</id>
    <content type="html"><![CDATA[<p>声明： 转载请注明，方便的情况下请知会本人. <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文主要介绍 Swift 所有标准库类型的层次结构，及所有标准类型。本文可作为参考手册使用。</p>

<p>本人不保证内容及时性和正确性，请善于怀疑并反馈。谢谢。</p>

<p>本文探索 Swift 所有基础类型和高级类型，以及所有协议和他们之间的继承关系。</p>

<p>为了简化问题，某些类型略去了中间的过渡类型，人肉保证不歧义。</p>

<h2>Swift 基础类型</h2>

<h3>数值类型</h3>

<h4>位</h4>

<pre><code>Bit
</code></pre>

<p>只有一位，实现为 <code>enum</code>， <code>.zero</code> 或 <code>.one</code>。简单明了。</p>

<p>协议: <code>RandomAccessIndex IntegerArithmetic</code></p>

<h4>整型</h4>

<p>有符号:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Int Int8 Int16 Int32 Int64</span></code></pre></td></tr></table></div></figure>


<p>协议：<code>SignedInteger RandomAccessIndex BitwiseOperations SignedNumber CVarArg</code></p>

<p>无符号:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UInt UInt8 UInt16 UInt32 UInt64</span></code></pre></td></tr></table></div></figure>


<p>协议：<code>UnsignedInteger RandomAccessIndex BitwiseOperations</code></p>

<p>别名:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IntMax = Int64
</span><span class='line'>UIntMax = UInt64
</span><span class='line'>IntegerLiteralType = Int
</span><span class='line'>Word = Int // 字长
</span><span class='line'>UWord = UInt</span></code></pre></td></tr></table></div></figure>


<h4>浮点型</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Float Double Float80</span></code></pre></td></tr></table></div></figure>


<p>别名：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FloatLiteralType = Double
</span><span class='line'>Float64 = Double</span></code></pre></td></tr></table></div></figure>


<p>协议：<code>FloatingPointNumber</code>。</p>

<h3>逻辑型</h3>

<p>只有一个 <code>Bool</code>。</p>

<p>实例： <code>true</code>、<code>false</code></p>

<p>协议：<code>LogicValue</code>。</p>

<h3>空</h3>

<p>只有一个 <code>NilType</code>。</p>

<p>唯一实例 <code>nil</code>。</p>

<h3>字符（串）类型</h3>

<ul>
<li><code>String</code></li>
<li><code>Character</code> Unicode 字符</li>
<li><code>UnicodeScalar</code> 相当于 C 中的 <code>wchar_t</code></li>
<li><code>CString</code> 用于表示 C 中的 <code>const char *</code>，请参考相关文章</li>
<li><code>StaticString</code> 静态字符串，内部使用，例如 <code>fatalError</code></li>
</ul>


<p>别名：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>StringLiteralType = String
</span><span class='line'>ExtendedGraphemeClusterType = String</span></code></pre></td></tr></table></div></figure>


<p>官方文档</p>

<blockquote><p><code>Character</code> represents some Unicode grapheme cluster as
defined by a canonical, localized, or otherwise tailored
segmentation algorithm.</p></blockquote>

<p><code>String</code> 实现协议：<code>Collection ExtensibleCollection OutputStream TargetStream</code>。</p>

<h3>Array 类型</h3>

<ul>
<li><code>Array&lt;T&gt;</code></li>
<li><code>ContiguousArray&lt;T&gt;</code></li>
</ul>


<p>实现协议 <code>ArrayType</code>。</p>

<p>内部容器：</p>

<ul>
<li><code>ArrayBuffer&lt;T&gt;</code></li>
<li><code>ContiguousArrayBuffer&lt;T&gt;</code></li>
</ul>


<p>这两个类型看起来是 Array 的内部容器，一般不应该直接使用。</p>

<h3>字典类型</h3>

<p><code>Dictionary&lt;KeyType : Hashable, ValueType&gt;</code></p>

<p>只实现了 <code>Collection</code>。</p>

<h3>元祖类型</h3>

<p>除正常元祖外，还有个特殊的别名</p>

<pre><code>Void = ()
</code></pre>

<p>其实很多语言都这么定义的，比如 Haskell 。</p>

<h3>Optional 类型</h3>

<ul>
<li><code>Optional&lt;T&gt;</code> 即 <code>T?</code></li>
<li><code>ImplicitlyUnwrappedOptional&lt;T&gt;</code> 即 <code>T!</code></li>
</ul>


<p>实现协议: <code>LogicValue</code>，行为是判断是否为 <code>.None</code>。</p>

<p>另外 <a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">Swift 的隐式类型转换</a>
有提到，为什么 <code>nil</code> 可以给 <code>Optional</code> 类型赋值的问题。</p>

<h3>C/ObjC 兼容类型</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CBool = Bool
</span><span class='line'>CFloat = Float
</span><span class='line'>CDouble = Double
</span><span class='line'>CChar = Int8
</span><span class='line'>CSignedChar = Int8
</span><span class='line'>CUnsignedChar = UInt8
</span><span class='line'>CChar16 = UInt16
</span><span class='line'>CWideChar = UnicodeScalar
</span><span class='line'>CChar32 = UnicodeScalar
</span><span class='line'>CInt = Int32
</span><span class='line'>CUnsignedInt = UInt32
</span><span class='line'>CShort = Int16
</span><span class='line'>CUnsignedShort = UInt16
</span><span class='line'>CLong = Int
</span><span class='line'>CUnsignedLong = UInt
</span><span class='line'>CLongLong = Int64
</span><span class='line'>CUnsignedLongLong = UInt64</span></code></pre></td></tr></table></div></figure>


<p>具体使用参考 C 交互的几篇文章，基本没区别。</p>

<h3>Any 类型</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AnyObject
</span><span class='line'>// 别名
</span><span class='line'>Any = protocol&lt;&gt;
</span><span class='line'>AnyClass = AnyObject.Type</span></code></pre></td></tr></table></div></figure>


<p>还有个用在函数定义的类型签名上， <code>Any.Type</code>。</p>

<p>顺便这里看到一个奇异的语法 <code>protocol&lt;&gt;</code>，这个也是 Swift 一种用来表示类型限制的方法，可以用在类型的位置，尖括号里可以是协议的列表。</p>

<h3>指针类型</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UnsafePointer&lt;T&gt;
</span><span class='line'>CMutableVoidPointer
</span><span class='line'>CConstVoidPointer
</span><span class='line'>COpaquePointer
</span><span class='line'>CConstPointer&lt;T&gt;
</span><span class='line'>AutoreleasingUnsafePointer&lt;T&gt;
</span><span class='line'>CVaListPointer
</span><span class='line'>CMutablePointer&lt;T&gt;</span></code></pre></td></tr></table></div></figure>


<p>参考 C 交互文章。</p>

<ul>
<li><a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">简析Swift和C的交互</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">简析 Swift 和 C 的交互，Part 二</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc/">Swift 与 ObjC 和 C 的交互，第三部分</a></li>
</ul>


<h3>其他辅助类型</h3>

<p>多了去了。比如 for-in 实现时候的 Generator 、比如反射时候用的 <code>*Mirror</code>、比如切片操作用的 <code>Range&lt;T&gt;</code>。比如内部储存类。</p>

<p>还有储存辅助类 <code>OnHeap&lt;T&gt;</code> 等等。以后有机会再探索。</p>

<h2>Swift 标准库协议</h2>

<h3>打印相关 <code>Printable DebugPrintable</code></h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">Printable</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">description</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">protocol</span> <span class="nc">DebugPrintable</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">debugDescription</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>用于打印和字符串的 Interpolation 。</p>

<h3><code>*LiteralConvertible</code></h3>

<p>从字面常量获取。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">ArrayLiteralConvertible</span>
</span><span class='line'><span class="nc">IntegerLiteralConvertible</span>
</span><span class='line'><span class="nc">DictionaryLiteralConvertible</span>
</span><span class='line'><span class="nc">CharacterLiteralConvertible</span>
</span><span class='line'><span class="nc">FloatLiteralConvertible</span>
</span><span class='line'><span class="nc">ExtendedGraphemeClusterLiteralConvertible</span>
</span><span class='line'><span class="nc">StringLiteralConvertible</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中字符串和字符的字面常量表示有所重合，也就是说 <code>"a"</code> 可以是字符串也可以是字符。<a href="http://andelf.github.io/blog/2014/06/17/nsobject-pattern-match-in-swift/">简析 Swift 中的 Pattern Match</a> 一文中就是遇到了类似的情况。</p>

<h3><code>LogicValue</code></h3>

<p>相当于重载 <code>if</code>、<code>while</code> 的行为。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">LogicValue</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">getLogicValue</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><code>Sequence</code></h3>

<p>相当于重载 for-in 。和 <code>Generator</code> 联用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">Sequence</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="nc">GeneratorType</span> <span class="k">:</span> <span class="kt">Generator</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">generate</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">GeneratorType</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">protocol</span> <span class="nc">Generator</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">typealias</span> <span class="nc">Element</span>
</span><span class='line'>  <span class="n">mutating</span> <span class="n">func</span> <span class="n">next</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Element</span><span class="o">?</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// for .. in { }</span>
</span><span class='line'><span class="k">var</span> <span class="nc">__g</span> <span class="k">=</span> <span class="n">someSequence</span><span class="o">.</span><span class="n">generate</span><span class="o">()</span>
</span><span class='line'><span class="k">while</span> <span class="n">let</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">__g</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'><span class="o">}}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>整型、 Index 相关协议</h3>

<p>这些协议都是用来表示容器类型的索引、及相关的索引运算。</p>

<p>这里略去了部分私有内容。略去了 <code>Printable</code> 等。</p>

<p><img class="left" src="http://andelf.github.io/images/attachments/swift-integer.png" title="'Swift Integer Type Hierarchy'" ></p>

<h3>RawOptionSet 相关协议</h3>

<p>一般用来表示二进制的选项，类似于 C enum ，很多 Cocoa 的 flag 被映射到它。相当于一个 Wrapper 的作用。</p>

<p><img class="left" src="http://andelf.github.io/images/attachments/swift-rawoptset.png" title="'Swift RawOptionSet'" ></p>

<p>可以看到要求被 Wrap 的对象支持 <code>BitwiseOperations</code>。</p>

<h3>Array 相关协议</h3>

<p>图中用虚线标注了和 <code>Generator</code> 的关系。</p>

<p><img class="left" src="http://andelf.github.io/images/attachments/swift-collection.png" title="'Swift Collection Protocol'" ></p>

<p><code>Array&lt;T&gt;</code> 类型实现了 <code>ArrayType</code> 协议。</p>

<p><code>Dictionary</code> 类型实现了 <code>Collection</code> 协议。</p>

<h3>反射相关协议</h3>

<p>包括 <code>Mirror</code>、<code>MirrorDisposition</code>、<code>Reflectable</code>。</p>

<p>请参考 <a href="http://andelf.github.io/blog/2014/06/20/swift-reflection/">Swift 的反射</a>。</p>

<h3>浮点数协议</h3>

<p>只有一个 <code>FloatingPointNumber</code>。单独存在。是为了定义完整而存在。看官自己搞定。</p>

<h3>IO 输出，伪输出相关</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">Streamable</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">writeTo</span><span class="o">&lt;</span><span class="nc">Target</span> <span class="k">:</span> <span class="kt">OutputStream&gt;</span><span class="o">(</span><span class="kt">inout</span> <span class="kt">target:</span> <span class="kt">Target</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Streamable</code> 表示可以被写入到输出流中，比如字符串、字符等。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">OutputStream</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">write</span><span class="o">(</span><span class="n">string</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>OutputStream</code> 表示一个输出流，比如标准输出（<code>stdout</code>），也可以表示一个伪输出流，例如字符串 <code>String</code>。</p>

<p>标准输出的获取方法</p>

<pre><code>var stdout = _Stdout()
</code></pre>

<p>看起来是私有结构，某一天不能用的话，别怪我。调用时候用 <code>inout</code> 引用语法。</p>

<h3>CVarArg 处理</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">CVarArg</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">encode</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Word</span><span class="o">[]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>用于处理 C 函数的可变参数，参考 <a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">简析 Swift 和 C 的交互，Part 二</a>。</p>

<h3>Bridge 协议</h3>

<p>这里有个疑问就是编译过程中这些 Bridge 协议有没有参与。目前还没办法确定。</p>

<ul>
<li><code>_BridgedToObjectiveC</code></li>
<li><code>_ConditionallyBridgedToObjectiveC</code></li>
</ul>


<p>具体内容可以参考 <a href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/">Swift 与 Objective-C 之间的交互</a>一文。</p>

<h3>其他</h3>

<p><code>Sink</code> 看起来是一个容器，可能是用来编码时使用。</p>

<p><code>ArrayBufferType</code> 用于表示 <code>ArrayType</code> 的内部储存，看起来似乎也可以直接用。</p>

<p><code>UnicodeCodec</code> 用于处理编码。有 <code>UTF8</code>、<code>UTF16</code>、<code>UTF32</code> 可用。</p>

<p><code>ArrayBound</code> 用来处理数组边界，详细原理和作用过程未知。</p>

<h2>总结</h2>

<p>无。</p>

<p>参考：</p>

<ul>
<li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My View of Swift （闲扯对 Swift 语言的看法）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/30/my-view-of-swift/"/>
    <updated>2014-06-30T11:05:13+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/30/my-view-of-swift</id>
    <content type="html"><![CDATA[<p>其实这是很早就像要说的了，大概当时信誓旦旦说要看完那本 epub 写个读后感谈谈对 Swift 看法什么的。后来不了了之。
现在觉得这个时机或许差不多，对 Swift 的了解也算凑合了。</p>

<p>纯个人观点。</p>

<h3>Swift 是系统编程语言</h3>

<p>一开始大家还不太了解的时候，可能会有很多误解。现在好歹一个月了。误解终于少了。</p>

<p>是的， Swift 是系统编程语言，原因是因为它 ABI 兼容 C （不包括 name mangling 部分）。基于强大的 llvm 生成具体平台代码。不是翻译为 Objective-C 的。</p>

<p>编译器参数还显示， Swift 文件的中间编译结果（介于 Swift 代码和 llvm ir ）是 SIL ，猜测是 Swift Intermediate Language 。好像和 llvm ir 有所联系。而且至少有两个 stage 。</p>

<p>不是脚本语言，也不是胶水语言。但是它的标准库 (import Swift 库) 几乎不含任何 IO 网络 等内容，随便做个功能强依赖 Cocoa 框架。也可以 <code>import Darwin</code> 用 C 语言的标准库来写。</p>

<p>猜测写个 Python C 模块这种任务是可以轻易胜任的。</p>

<p>而 Golang 、 Rust 本身 ABI 是和 C 不兼容的。虽然 Rust 通过 <code>extern "C"</code> 可以修改单个函数为兼容。</p>

<h3>Swift 是现代语言</h3>

<p>自动类型推导、泛型、 LLVM 。当然语言研究党都知道这些都是几十年前的“新东西”。</p>

<h3>Swift 是半完成品</h3>

<p>这么说主要是指 Swift 对 Cocoa 的库实在是太半吊子了。只是 Foundation 有 Bridge 支持，其他库中，明显的列表都无法支持 subscript 、 for-in 这样简单的操作。原因很简单，这些库都是自动转换 ObjC 头文件而来（参考模块那篇文章）。没有额外的封装代码。</p>

<p>所以其实真要用起来，可能会很纠结。或者可以预计很快就有第三方的 Bridge 库给这些类型加上舒服的 Swift 支持。</p>

<p>另外命令行没有静态链接库支持。只能用其他命令拼装。也侧面说明， Apple 希望开发者更多用动态链接库， Framework 。</p>

<p>另外目前的编译器 coredump 、 stackoverflow 太多太多。错哪都不知道。</p>

<h3>Swift 隐藏细节太多</h3>

<p>就对应到 Foundation 类型这个特性太说，太多黑魔法，隐式类型转换、 BridgeToObjectiveC 协议、指针类型转换。</p>

<p>这些隐藏的特性多少都会成为 Swift 的坑。</p>

<p>要知道定义在 ObjC 库的 <code>NSString</code> 参数某些情况下在 Swift 中被转换为 <code>String</code>。 <code>NSArray</code> 都被转换为 <code>AnyObject[]</code>。即使有隐式类型转换，某些极端情况下，还是会有编译时错误。</p>

<h3>Swfit 的性能</h3>

<p>我没做过测试，但就语言特性来说， Swift 是比 ObjC 快的，因为静态类型使得他在编译时就已经知道调用函数的具体位置。而不是 Objective-C 的消息发送、 Selector 机制。</p>

<p>目前来看， Swift 性能略差原因主要是编译器还没足够优化、还有就是 Cocoa 拖了后腿， Cocoa 本身有大量的 <code>AnyObject</code> 返回值。所以实际写 Swift 代码时，多用 <code>as</code> 一定是好习惯。明确类型。</p>

<h3>Swift 的未来</h3>

<p>我不知道。至少好像感觉很多培训机构都看到了前途开始疯狂的做视频。</p>

<p>倒是觉得什么时候 Cocoa for Swift 出了才算它完全完成任务。</p>

<p>总觉得 Cocoa 拖后腿，不然放到其他平台也不错。</p>

<p>对了，之前不是在 App 开发领域，这才知道原来这个地盘水很深，太多唯利的培训机构，太多嗷嗷待哺等视频教程的新人。觉得挺有意思。就拿 ? ! 这个 Optional 为例，太多介绍的文章。可惜能说明白的太少太少。糊里糊涂做开发就是当前现状吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Interop With C/ObjC Part 3 (Swift 与 ObjC 和 C 的交互，第三部分）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc/"/>
    <updated>2014-06-28T21:58:35+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc</id>
    <content type="html"><![CDATA[<p>声明： 转载请注明，方便的情况下请知会本人. <a href="http://weibo.com/234632333">weibo</a></p>

<p>之前说那是最后一篇。可惜越来越发现有很多东西还没介绍到。事不过三。再坑一篇。</p>

<h2>前言</h2>

<p>本文解决如下问题</p>

<ul>
<li>ObjC/C 中定义的某个类型、结构体，通过 Bridge Header 或者 Module 对应到 Swift 到底是什么类型</li>
<li>指针间的转换问题</li>
</ul>


<p>补充之前没解决的一些问题，比如提到 <code>CMutablePointer</code> 的 <code>sizeof</code> 是两个字长，那么在函数调用中是如何对应到 C 的指针的？</p>

<p>预备内容：</p>

<ul>
<li><a href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/">Swift 与 Objective-C 之间的交互</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">简析Swift和C的交互</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">简析 Swift 和 C 的交互，Part 二</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">Swift 的隐式类型转换</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/06/swift-attributes/">Swift Attributes</a></li>
</ul>


<h2>C/ObjC to Swift 对应规则</h2>

<p>以下内容均适合 Objective-C 。第一部分适合 C 。</p>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。</p>

<h3>for C</h3>

<h4>可导出的类型定义</h4>

<p>函数、枚举、结构体、常量定义、宏定义。</p>

<p>结构体定义支持：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Name</span> <span class="p">{...}</span> <span class="n">Name</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Name_t</span> <span class="p">{...}</span> <span class="n">Name</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中无法处理的结构体、函数类型、 varargs 定义不导出。预计以后版本会修复。带 bit field 的结构体也无法识别。</p>

<h4>类型对应关系</h4>

<p>仔细分析发现，诡异情况还很多。基础类型请参考上几篇。</p>

<p>在函数定义参数中：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">类型 </th>
<th style="text-align:center;"> 对应为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"><code>void *</code> </td>
<td style="text-align:center;"> <code>CMutableVoidPointer</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>Type *</code>、<code>Type[]</code> </td>
<td style="text-align:center;"> <code>CMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>const char *</code> </td>
<td style="text-align:center;"> <code>CString</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>const Type *</code> </td>
<td style="text-align:center;"> <code>CConstPointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>const void *</code> </td>
<td style="text-align:center;"> <code>CConstVoidPointer</code></td>
</tr>
</tbody>
</table>


<p>在函数返回、结构体字段中：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">类型 </th>
<th style="text-align:center;"> 对应为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"><code>const char *</code> </td>
<td style="text-align:center;"> <code>CString</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>Type *</code>、<code>const Type *</code> </td>
<td style="text-align:center;"> <code>UnsafePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>void *</code>、<code>const void *</code> </td>
<td style="text-align:center;"> <code>COpaquePointer</code></td>
</tr>
<tr>
<td style="text-align:center;">无法识别的结构指针  </td>
<td style="text-align:center;"> <code>COpaquePointer</code></td>
</tr>
</tbody>
</table>


<p>另外还有如下情况：</p>

<p>全局变量、全局常量(<code>const</code>)、宏定义常量(<code>#define</code>) 均使用 <code>var</code>，常量不带 <code>set</code>。</p>

<p>结构体中的数组，对应为元祖，例如 <code>int data[2]</code> 对应为 <code>(CInt, CInt)</code>，所以也许。。会很长。数组有多少元素就是几元祖。</p>

<h3>for ObjC</h3>

<p>ObjC 明显情况要好的多，官方文档也很详细。</p>

<p>除了 <code>NSError **</code> 转为 <code>NSErrorPointer</code> 外，需要注意的就是：</p>

<p>函数参数、返回中的 <code>NSString *</code> 被替换为 <code>String!</code>、<code>NSArray *</code> 被替换为 <code>AnyObject[]!</code>。</p>

<p>而全局变量、常量的 <code>NSString *</code> 不变。</p>

<h2>关于 <code>CMutablePointer</code> 的行为</h2>

<p>上回说到 <code>CMutablePointer</code>、<code>CConstPointer</code>、<code>CMutableVoidPointer</code>、<code>CConstVoidPointer</code>
四个指针类型的字长是 2，也就是说，不可以直接对应为 C 中的指针。但是前面说类型对应关系的时候， C 函数声明转为 Swift
时候又用到了这些类型，所以看起来自相矛盾。仔细分析了 lldb 反汇编代码后发现，有如下隐藏行为:</p>

<h3>in Swift</h3>

<p>在纯 Swift 环境下，函数定义等等、这些类型字长都为 2，不会有任何意外情况出现。</p>

<h3>in C/ObjC</h3>

<p>当一个函数的声明是由 Bridge Header 或者 LLVM Module 隐式转换而来，且用到了这四个指针类型，那么代码编译过程中类型转换规则、隐式转换调用等规则依然有效。只不过在代码最生成一步，会插入以下私有函数调用之一：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCMutablePointerToUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;T&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">UnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCConstPointerToUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CConstPointer&lt;T&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">UnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCMutableVoidPointerToCOpaquePointer</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CMutableVoidPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">COpaquePointer</span>
</span><span class='line'><span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCConstVoidPointerToCOpaquePointer</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CConstVoidPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">COpaquePointer</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个过程是背后隐藏的。然后将转换的结果传参给对应的 C/ObjC 函数。实现了指针类型字长正确、一致。</p>

<h3>结论</h3>

<p>作为程序员，需要保证调用 C 函数的时候类型一致。如果有特殊需求重新声明了对应的 C 函数，那么以上规则不起作用，所以重声明 C 中的函数时表示指针不可以使用这四个指针类型。</p>

<h2>再说指针</h2>

<p><img class="left" src="http://andelf.github.io/images/attachments/swift-pointers.png" title="'Swift Pointers'" ></p>

<p>虚线表示直接隐式类型转换。其中 <code>UnsafePointer&lt;T&gt;</code> 可以通过用其他任何指针调用构造函数获得。</p>

<p><code>CMutablePointer&lt;T&gt;</code> 和 <code>CMutableVoidPointer</code> 也可以通过 <code>Array&lt;T&gt;</code> 的引用隐式类型转换获得 （ <code>&amp;arr</code> ）。</p>

<p>椭圆表示类型 <code>sizeof</code> 为字长，可以用于声明 C 函数。</p>

<p>四大指针可以用 <code>withUnsafePointer</code> 操作。转换为 <code>UnsafePointer&lt;T&gt;</code>。上一节提到的私有转换函数请不要使用。</p>

<h2>字符串</h2>

<p>之前的文章已经介绍过怎么从 <code>CString</code> 获取 <code>String</code> （静态方法 <code>String.fromCString</code>）。</p>

<p>从 <code>String</code> 获取 <code>CString</code> 也说过， 是用 <code>withCString</code>。</p>

<p>也可以从 <code>CString(UnsafePointer.alloc(100))</code> 来分配空数组。</p>

<h2>参考</h2>

<ul>
<li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tilde Arrow in Swift （Swift 标准库中的波浪箭头 ~> ）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/25/tilde-arrow-in-swift/"/>
    <updated>2014-06-25T22:44:29+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/25/tilde-arrow-in-swift</id>
    <content type="html"><![CDATA[<p>本文瞎写，没实际内容。请不用看了。</p>

<h2>摘要</h2>

<p>本文挖掘 Swift 标准库中的诡异操作符 <code>~&gt;</code> 波浪箭头的作用。</p>

<h2>正文</h2>

<p>查看标准库定义的时候，发现了一个奇怪的运算符 <code>~&gt;</code>，看起来高大上，所以探索下它到底起什么作用。</p>

<p>标准库对 <code>~&gt;</code> 用到的地方很多，我取最简单的一个来做说明。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol SignedNumber : _SignedNumber {
</span><span class='line'>  func -(x: Self) -&gt; Self
</span><span class='line'>  func ~&gt;(_: Self, _: (_Abs, ())) -&gt; Self
</span><span class='line'>}
</span><span class='line'>func ~&gt;&lt;T : _SignedNumber&gt;(x: T, _: (_Abs, ())) -&gt; T
</span><span class='line'>func abs(_: CInt) -&gt; CInt
</span><span class='line'>func abs&lt;T : SignedNumber&gt;(x: T) -&gt; T</span></code></pre></td></tr></table></div></figure>


<p>这是对有符号整型的一个协议，我去掉了额外的属性。事实上 <code>_Abs</code> 类型是一个空结构， <code>sizeof</code> 为 0 。</p>

<p>写个测试程序，计算下 <code>abs(-100)</code> 看看情况，发现 <code>top_level_code()</code> 调用了 <code>SignedNumber</code> 版本的 <code>abs()</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>callq  0x100001410               ; Swift.abs &lt;A : Swift.SignedNumber&gt;(A) -&gt; A</span></code></pre></td></tr></table></div></figure>


<p>反汇编这个库函数，发现一个有意思的调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>callq  0x10000302a               ; symbol stub for: Swift._abs &lt;A&gt;(A) -&gt; (Swift._Abs, A)</span></code></pre></td></tr></table></div></figure>


<p>这个 <code>_abs()</code> 函数是私有函数， Swift 中把很多私有的函数、成员变量、结构、协议都以下划线开头，意思就是不希望我们去调用或者访问的函数，在缺乏成员访问控制的语言中，其实这么做也不错。大家可以借鉴。</p>

<p>而 <code>_abs()</code> 函数很简单，将任意类型 T 直接封装成 <code>(_Abs, T)</code> 元组，返回。</p>

<p>然后代码的逻辑就是用这个元祖解开重新组装，调用 <code>~&gt;</code>。逻辑如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// logic of abs() funciton</span>
</span><span class='line'><span class="n">let</span> <span class="o">(</span><span class="n">operation</span><span class="o">,</span> <span class="k">val</span><span class="o">)</span> <span class="k">=</span> <span class="nc">_abs</span><span class="o">(-</span><span class="mi">100</span><span class="o">)</span>
</span><span class='line'><span class="k">val</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="n">operation</span><span class="o">,</span> <span class="o">())</span> <span class="c1">// 返回 100</span>
</span></code></pre></td></tr></table></div></figure>


<p>到这里就清楚了。实际上 <code>~&gt;</code> 将一个简单的操作复杂化。多调用了层，实际开销主要在元祖的解开和重组装（实际开销理论上在优化模式下应该可以忽略，因为包含 <code>_Abs</code>， size 为 0）。</p>

<p>到这里很多朋友应该已经知道怎么回事了。 <code>SignedNumber</code> 中的 <code>~&gt;</code> 操作是为我们提供了一个方法可以 hook 到标准库的 <code>abs()</code> 函数。来自 Haskell 的同学应该会见过这种单纯地用类型签名来实现函数分发调用的方式。</p>

<h3>优点？</h3>

<p>暂时正在考虑。想明白会发出来。</p>

<h3>延伸</h3>

<p>其实很多标准库函数都用到了类似的方法实现。都用到了 <code>~&gt;</code> 运算符。包括：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">countElements</span><span class="o">()</span>
</span><span class='line'><span class="c1">// _countElements() 工具函数  _CountElements 结构</span>
</span><span class='line'><span class="n">underestimateCount</span><span class="o">()</span>
</span><span class='line'><span class="c1">// _underestimateCount() 、 _UnderestimateCount</span>
</span><span class='line'><span class="n">advance</span><span class="o">()</span>
</span><span class='line'><span class="c1">// _advance() 、 _Advance</span>
</span></code></pre></td></tr></table></div></figure>


<p>等。</p>

<h2>附录</h2>

<p>这里列出部分定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">Sequence</span> <span class="k">:</span> <span class="k">_</span><span class="kt">Sequence_</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span><span class="kt">alias</span> <span class="kt">GeneratorType</span> <span class="kt">:</span> <span class="kt">Generator</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">generate</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">GeneratorType</span>
</span><span class='line'>  <span class="n">func</span> <span class="o">~&gt;(</span><span class="k">_:</span> <span class="kt">Self</span><span class="o">,</span> <span class="k">_:</span> <span class="o">(</span><span class="k">_</span><span class="kt">UnderestimateCount</span><span class="o">,</span> <span class="o">()))</span> <span class="o">-&gt;</span> <span class="nc">Int</span>
</span><span class='line'>  <span class="n">func</span> <span class="o">~&gt;&lt;</span><span class="n">R</span><span class="o">&gt;(</span><span class="k">_:</span> <span class="kt">Self</span><span class="o">,</span> <span class="k">_:</span> <span class="o">(</span><span class="k">_</span><span class="kt">PreprocessingPass</span><span class="o">,</span> <span class="o">((</span><span class="kt">Self</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">R</span><span class="o">)))</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">?</span>
</span><span class='line'>  <span class="n">func</span> <span class="o">~&gt;(</span><span class="k">_:</span> <span class="kt">Self</span><span class="o">,</span> <span class="k">_:</span> <span class="o">(</span><span class="k">_</span><span class="kt">CopyToNativeArrayBuffer</span><span class="o">,</span> <span class="o">()))</span> <span class="o">-&gt;</span> <span class="nc">ContiguousArrayBuffer</span><span class="o">&lt;</span><span class="nc">Self</span><span class="o">.</span><span class="nc">GeneratorType</span><span class="o">.</span><span class="nc">Element</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">protocol</span> <span class="nc">Collection</span> <span class="k">:</span> <span class="k">_</span><span class="kt">Collection</span><span class="o">,</span> <span class="nc">Sequence</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">subscript</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Self.IndexType</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Self</span><span class="o">.</span><span class="nc">GeneratorType</span><span class="o">.</span><span class="nc">Element</span> <span class="o">{</span> <span class="n">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="n">func</span> <span class="o">~&gt;(</span><span class="k">_:</span> <span class="kt">Self</span><span class="o">,</span> <span class="k">_:</span> <span class="o">(</span><span class="k">_</span><span class="kt">CountElements</span><span class="o">,</span> <span class="o">()))</span> <span class="o">-&gt;</span> <span class="nc">Self</span><span class="o">.</span><span class="nc">IndexType</span><span class="o">.</span><span class="nc">DistanceType</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">protocol</span> <span class="nc">ForwardIndex</span> <span class="k">:</span> <span class="k">_</span><span class="kt">ForwardIndex</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">func</span> <span class="kt">~&gt;</span><span class="o">(</span><span class="kt">start:</span> <span class="kt">Self</span><span class="o">,</span> <span class="k">_</span><span class="kt">:</span> <span class="o">(</span><span class="k">_</span><span class="kt">Distance</span><span class="o">,</span> <span class="kt">Self</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="nc">Self</span><span class="o">.</span><span class="nc">DistanceType</span>
</span><span class='line'>  <span class="n">func</span> <span class="o">~&gt;(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Self</span><span class="o">,</span> <span class="k">_:</span> <span class="o">(</span><span class="k">_</span><span class="kt">Advance</span><span class="o">,</span> <span class="kt">Self.DistanceType</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="nc">Self</span>
</span><span class='line'>  <span class="n">func</span> <span class="o">~&gt;(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Self</span><span class="o">,</span> <span class="k">_:</span> <span class="o">(</span><span class="k">_</span><span class="kt">Advance</span><span class="o">,</span> <span class="o">(</span><span class="kt">Self.DistanceType</span><span class="o">,</span> <span class="kt">Self</span><span class="o">)))</span> <span class="o">-&gt;</span> <span class="nc">Self</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>相关更多声明代码信息请参考 我的 Github : <a href="https://github.com/andelf/Defines-Swift">andelf/Defines-Swift</a> 。</p>

<h2>总结</h2>

<p>通过 <code>~&gt;</code> 和 <code>protocol</code> 可以自定义编译器的行为。相当于 hook 标准库函数。由于内部实现未知，还不能继续断言它还有什么作用。</p>

<p>但是和直接用 extension 实现协议的方法相比，这个有什么好处呢？待考。</p>

<h2>更新</h2>

<p>可以避免 <code>protocol</code> 中的静态函数混淆空间，如果用全局函数，那么相当于全局函数去调用静态函数。</p>

<p>还有就是在使用操作符的时候，如果定义多个，那么需要编译器去寻找可用的一个版本。</p>

<p>仔细查看目前的 <code>protocol</code> 实现，发现还是有点 BUG ，类型限制还是不清楚，表述高阶类型的时候。</p>

<p>为了描述 <code>~&gt;</code> 的用法，我写了个 <a href="https://gist.github.com/andelf/6a8432ef0820de9991f6">Monad.swift</a> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont/"/>
    <updated>2014-06-25T21:20:55+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont</id>
    <content type="html"><![CDATA[<p>声明： 转载注明我或者 SwiftChina, 请在方便的情况下情尽量告知. <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文的发现基于个人研究。请尊重原创。</p>

<h2>摘要</h2>

<p>本文提出了一种可以编译 Swift 静态链接模块的方法，通过对 swift 编译命令行参数的控制，生成可以自由分发的静态链接库和 swift module 描述文件。同时还提出了导出 objC 头文件供 Objective-C 调用的可能。</p>

<p>关键词： Swift 模块 静态链接库</p>

<p>上次一篇文章 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a> 中提到：</p>

<blockquote><p>静态链接库 .a 目前还没有找到方法， -Xlinker -static 会报错。</p></blockquote>

<p>最近摸索了下用 Swift 创建静态链接库的方法。有所收获，这里记录下。</p>

<h2>废话</h2>

<p>我们中的很多人都知道，编译器编译的最后一个步骤一般都是链接，一般都是调用 <code>ld</code>。经过仔细分析，之前为什么不能生成 <code>.a</code> 静态链接库的原因，发现有如下问题：</p>

<ul>
<li><code>-Xlinker -static</code> 参数传递的时候， swift 命令本身不能识别，讲 <code>-dylib</code> 与 <code>-static</code> 一起传递（这倒不是问题，参数优先级，静态盖掉了动态）</li>
<li>链接到 <code>-lSystem</code> 时候，这个库没有静态链接。</li>
</ul>


<p>所以总会报错。</p>

<h3>思考</h3>

<p>实际上之前的方法是走了弯路，根本没有必要去调用 <code>ld</code>，作为一个合格的 <code>.a</code> 静态链接库，只要有对应的 <code>.o</code> 就可以了，没必要去链接 <code>-lSystem</code>，也许是 swift 本身没有编译为静态链接库的参数支持。</p>

<p>检查 Swift 标准库中的静态链接库，果然只包含对应 <code>.swift</code> 代码编译后的 <code>.o</code> 文件。（检查方法是用 <code>ar -t libName.a</code>）</p>

<p>说到底， Swift 静态链接库的目标很简单，就是包含对应 Swift 模块的所有代码，这样就避免了对应动态链接库的引入。和什么 <code>-lSystem</code> 没啥相干。</p>

<h2>解决方法 HOWTO</h2>

<p>以 lingoer 的 <a href="https://github.com/lingoer/SwiftyJSON">SwiftyJSON</a> 为例。</p>

<p>我们的目标很简单，就是生成 <code>ModName.swiftmodule</code>、<code>ModName.swiftdoc</code>(可选)、<code>libswiftModName.a</code> 三个文件。</p>

<h3>编译</h3>

<h4>生成 <code>.swiftmodule</code> <code>.swiftdoc</code></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) SwiftyJSON.swift -emit-library -emit-module -module-name SwiftyJSON -v -o libswiftSwiftyJSON.dylib -module-link-name swiftSwiftyJSON</span></code></pre></td></tr></table></div></figure>


<h4>生成 <code>.o</code></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) -c SwiftyJSON.swift -parse-as-library -module-name SwiftyJSON -v -o SwiftyJSON.o</span></code></pre></td></tr></table></div></figure>


<h4>生成 <code>.a</code></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ar rvs libswiftSwiftyJSON.a SwiftyJSON.o</span></code></pre></td></tr></table></div></figure>


<p>大功告成。</p>

<p>同时应该也可以用 <code>lipo</code> 来合成不同平台下的 <code>.a</code> 链接库。</p>

<h3>使用</h3>

<p>和静态链接库类似，需要 <code>-I</code> 包含 <code>.swiftmodule</code> 所在目录， <code>-L</code> 包含 <code>.a</code> 所在目录。</p>

<p>如果动态链接库和静态链接库两者同时存在，可以依靠不同目录来区分。</p>

<h2>你丫闲的！</h2>

<p>可能不少人要群嘲，你这意义是啥。你丫闲的。</p>

<p>其实在分发 library 的时候，很多时候我们需要二进制分发，希望别人可以方便地使用。这种情况下，静态链接更佳（虽然新的 iOS 8 支持动态链接，但是看起来是基于 Framework 的，略复杂些。）</p>

<p>甚至我们可以用 <code>lipo</code> 创建全平台可用的静态链接库。多赞。</p>

<h2>补充</h2>

<p>多个 Swift 文件可以分别编译为 <code>.o</code> 然后用 <code>ar</code> 合并。</p>

<p>对于 CocoaPods ，也许可以按照这个逻辑将 Swift 模块暴露出去。需要多加一个参数 <code>-emit-objc-header</code> （以及 <code>-emit-objc-header-path</code>）即可。</p>

<h2>参考文献</h2>

<ul>
<li>我的另一篇 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/23/use-cocoapods-with-swift/">Use CocoaPods With Swift (在 Swift 中使用 CocoaPods）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use CocoaPods With Swift (在 Swift 中使用 CocoaPods）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/23/use-cocoapods-with-swift/"/>
    <updated>2014-06-23T20:15:39+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/23/use-cocoapods-with-swift</id>
    <content type="html"><![CDATA[<p>声明： 转载注明我或者 SwiftChina 。请在方便的情况下情尽量告知. <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文的发现基于个人研究。请尊重原创。已授权 CocoaChina 转载个人文章。</p>

<p>本文介绍如何在 Swift 项目中使用 CocoaPods 。如果你已经精通 Bridging Header 的方法，请直接跳到 &ldquo;扩展 CocoaPods&rdquo; 一节。</p>

<h2>什么是 CocoaPods</h2>

<blockquote><p>CocoaPods is the dependency manager for Objective-C projects.
It has thousands of libraries and can help you scale your projects elegantly. <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p></blockquote>

<p>从介绍看，它是主要给 Objective-C 项目用的，但是我们可以很容易地混合 Objective-C 和 Swift 到同个项目，从而利用大量的 CocoaPods 库和 Swift 漂亮舒服的语法。</p>

<p>作为 iOS 开发新手，一定是要紧跟前人脚步，学习使用 CocoaPods 。</p>

<h2>基础用法</h2>

<p>这里简单略过，请参考其他无数的文章。</p>

<h3>安装</h3>

<p>系统默认安装，可以参考其他教程<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。在命令行下执行。</p>

<pre><code>sudo gem install cocoapods
</code></pre>

<p>我的环境是 HomeBrew</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 添加 taobao Mirror 不然被墙掉没办法下载
</span><span class='line'>gem sources -a http://ruby.taobao.org/ 
</span><span class='line'># 安装
</span><span class='line'>gem install cocoapods
</span><span class='line'># 更新命令
</span><span class='line'>rbenv rehash
</span><span class='line'># 执行
</span><span class='line'>pod
</span><span class='line'># 此时一般会下载官方的所有 PodSpec 库，也可以用 pod setup 初始化环境</span></code></pre></td></tr></table></div></figure>


<p>本文不打算在安装部分耗费太多时间。希望看到这里保证你的命令行下有可用的 <code>pod</code> 命令。</p>

<h3>使用</h3>

<p>假设我们已经有个项目，叫 ProjName ，需要使用一些注明的 CocoaPods 库，比如 AFNetworking<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>首先，命令行 cd 到我们的项目目录，一般 ls 命令会看到如下几个文件夹：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ProjName
</span><span class='line'>ProjName.xcodeproj
</span><span class='line'>ProjNameTests</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>赞，就是这里，创建一个 <code>Podfile</code> 文本文件，写入如下内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>platform :ios, "8.0"
</span><span class='line'>pod "AFNetworking", "~&gt; 2.0"</span></code></pre></td></tr></table></div></figure>


<p>一般这么简单的文件都是直接 nano 写。 :)</p>

<p>直接创建 <code>Podfile</code> ， CocoaPods 会创建一个项目同名的 WorkSpace ，然后添加一个叫 Pods 的项目，这个项目编译结果是一个叫 <code>libPods.a</code>的链接库，
它会添加到我们之前的 ProjName 项目中作为编译依赖。</p>

<p>当然，通过命令行执行 <code>pod init</code> 也可以自动创建 <code>Podfile</code>，而且可以自动分析当前项目的 target ，相对来说更好，也更优雅。具体请参考官方手册。这样的好处是更细致，还可以区分多个子项目子 target 。原理大同小异。</p>

<p>然后接下来，命令行执行 <code>open ProjName.xcworkspace</code>，注意这个可不是 <code>.xcodeproj</code>，这个是 CocoaPods 为我们创建的一个 WorkSpace ，包含我们之前的项目，和 Pods 依赖。</p>

<p>开始编码过程。直接在代码里调用，比如写在某个按钮的 <code>@IBAction</code> 里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>    <span class="n">let</span> <span class="n">manager</span> <span class="k">=</span> <span class="nc">AFHTTPRequestOperationManager</span><span class="o">()</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">url</span> <span class="k">=</span> <span class="s">&quot;http://api.openweathermap.org/data/2.5/weather&quot;</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="n">params</span> <span class="k">=</span> <span class="o">[</span><span class="err">&quot;</span><span class="kt">lat</span><span class="err">&quot;</span><span class="kt">:</span> <span class="err">39</span><span class="kt">.</span><span class="err">26</span>, <span class="err">&quot;</span><span class="kt">lon</span><span class="err">&quot;</span><span class="kt">:</span> <span class="err">41</span><span class="kt">.</span><span class="err">03</span>, <span class="err">&quot;</span><span class="kt">cnt</span><span class="err">&quot;</span><span class="kt">:</span><span class="err">0</span><span class="o">]</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="n">params</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">manager</span><span class="o">.</span><span class="nc">GET</span><span class="o">(</span><span class="n">url</span><span class="o">,</span>
</span><span class='line'>        <span class="n">parameters</span><span class="k">:</span> <span class="kt">params</span><span class="o">,</span>
</span><span class='line'>        <span class="n">success</span><span class="k">:</span> <span class="o">{</span> <span class="o">(</span><span class="kt">operation:</span> <span class="kt">AFHTTPRequestOperation!</span><span class="o">,</span>
</span><span class='line'>                    <span class="kt">responseObject:</span> <span class="kt">AnyObject!</span><span class="o">)</span> <span class="kt">in</span>
</span><span class='line'>            <span class="n">println</span><span class="o">(</span><span class="s">&quot;JSON: &quot;</span> <span class="o">+</span> <span class="n">responseObject</span><span class="o">.</span><span class="n">description</span><span class="o">!)</span>
</span><span class='line'>        <span class="o">},</span>
</span><span class='line'>        <span class="n">failure</span><span class="k">:</span> <span class="o">{</span> <span class="o">(</span><span class="kt">operation:</span> <span class="kt">AFHTTPRequestOperation!</span><span class="o">,</span>
</span><span class='line'>                    <span class="kt">error:</span> <span class="kt">NSError!</span><span class="o">)</span> <span class="kt">in</span>
</span><span class='line'>            <span class="n">println</span><span class="o">(</span><span class="s">&quot;Error: &quot;</span> <span class="o">+</span> <span class="n">error</span><span class="o">.</span><span class="n">localizedDescription</span><span class="o">)</span>
</span><span class='line'>        <span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里直接抄了 JakeLin 的 SwiftWeather 代码<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，就一小段，希望他不会打我。</p>

<h4>Swift 坑爹了</h4>

<p>看起来貌似我们已经可以在 Swift 中使用 <code>AFNetworking</code> 了。结果刚写几句代码一堆类和变量找不到定义，而且坑爹的是很多时候我们只能靠猜测，判断这些 Objective-C 的定义转换成 Swift 定义是什么样子，用起来就是完全靠蒙！</p>

<p>这不科学！</p>

<p>这都三礼拜了，所以大家都摸索出了调用的方法，那就是按照和 Objective-C 代码混编的例子，添加 Bridging Header ！</p>

<h4>继续</h4>

<p>之前简单介绍过和  Objective-C 交互的内容<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>，大家可以去围观。</p>

<p>一般说来，你在 Swift 项目新建 Objective-C 类的时候，直接弹出是否创建 Bridge Header 的窗口，点 YES 就是了，这时候一般多出来个 <code>ProjectName-Bridging-Header.h</code> 。然后删掉这个类， Bridging Header 头文件还在。</p>

<p>在这个 Bridging Header 文件里写入要导入的 CocoaPods 库，就可以在 Swift 中使用了。</p>

<pre><code>#import &lt;AFNetworking/AFNetworking.h&gt;
</code></pre>

<p>如果没有自动创建头文件的话，这个配置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。</p>

<p>创建一个头文件，指定为 Bridging Header 也可以。</p>

<p>然后编译，成功执行！</p>

<h4>这就完事了？</h4>

<p>实际上，前两天刚写一篇 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Swift 的模块系统</a> ， 把任意 Objective-C 库当做 Swift Module 是可行的。当时就觉得这个东西应该是可能完全进入 CocoaPods 的，但是在官方 repo 找了下发现，以前有人提过增加 <code>module.map</code> 支持，结果 CocoaPods 的人认为这个是 llvm 内部特性， issue 被关闭了。<a href="https://github.com/CocoaPods/CocoaPods/issues/2216">#2216</a> 最近又被提起，我在后面提了下 Swift 支持，希望官方靠谱。</p>

<p>所以下面的内容，就是，我们是否可以在 CocoaPods 上加入 <code>module.map</code> 支持，然后直接在 Swift 中 <code>import ModuleName</code> ？</p>

<h2>扩展 CocoaPods</h2>

<p>考虑了多种方式，最后选择了 Hook 的方式。如果 Ruby 技术足够好，或许可以直接写个插件。或者直接改官方代码给官方提交。但是实在能力有限。相关的 <code>module.map</code> 语法参考 llvm 官方手册 <a href="http://clang.llvm.org/docs/Modules.html">Modules – Clang 3.5 documentation</a>。用了最简单的功能。也许遇到复杂的 PodSpec 就不起作用了，但是原理如此，相信小伙伴们已经知道怎么做了。</p>

<p>目前我的 <code>Podfile</code> 大概是这个样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s2">&quot;8.0&quot;</span>
</span><span class='line'><span class="n">pod</span> <span class="s2">&quot;AFNetworking&quot;</span><span class="p">,</span> <span class="s2">&quot;~&gt; 2.0&quot;</span>
</span><span class='line'><span class="n">pod</span> <span class="s2">&quot;Baidu-Maps-iOS-SDK&quot;</span><span class="p">,</span> <span class="s2">&quot;~&gt; 2.0&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">post_install</span> <span class="k">do</span> <span class="o">|</span><span class="n">installer</span><span class="o">|</span>
</span><span class='line'>  <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">installer</span><span class="o">.</span><span class="n">sandbox_root</span><span class="si">}</span><span class="s2">/Headers/module.map&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">fp</span><span class="o">|</span>
</span><span class='line'>    <span class="n">installer</span><span class="o">.</span><span class="n">pods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">pod</span><span class="o">|</span>
</span><span class='line'>      <span class="n">normalized_pod_name</span> <span class="o">=</span> <span class="n">pod</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</span><span class='line'>      <span class="n">fp</span><span class="o">.</span><span class="n">write</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span>
</span><span class='line'><span class="sh">module #{normalized_pod_name} [system] {</span>
</span><span class='line'><span class="sh">  umbrella &quot;#{pod.name}&quot;</span>
</span><span class='line'><span class="sh">  export *</span>
</span><span class='line'><span class="sh">}</span>
</span><span class='line'><span class="no">EOF</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;Generating Swift Module </span><span class="si">#{</span><span class="n">normalized_pod_name</span><span class="o">.</span><span class="n">green</span><span class="si">}</span><span class="s2"> for </span><span class="si">#{</span><span class="n">pod</span><span class="si">}</span><span class="s2"> OK!&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>post_install</code> 是 <code>Podfile</code> 的一种 hook 机制，可以用来加入自定义操作。我在这里的写的逻辑就是，针对所有的 Pod 生成一个 <code>module.map</code> 文件。
位于 <code>Pods/Headers/</code>，这个目录被 CocoaPods 自动设置为项目的 Header Search Path 所以不需要额外处理。默认我们的 Swift 文件就找得到。</p>

<p>其中 <code>normalized_pod_name</code> 用于处理百度地图 API SDK 这一类名字带减号的库，因为他们不能作为 Module Name ，实际上或许有更好的方法来处理。</p>

<h3>实际效果</h3>

<p>实测发现完全没有问题，直接 <code>import AFNetworking</code> 或者 <code>import BaiduMapsiOSSDK</code> 都可以。</p>

<p>而且很不错的一点是，按住 Command 键，然后鼠标点击模块名、类名等，会跳转到 Swift 定义。</p>

<h3>坑</h3>

<p>遇到提示 <code>.pcm</code> 文件 outdate 的情况下需要你删除 <code>$HOME/Library/Developer/Xcode/DerivedData/ModuleCache</code> 目录，这个目录保存的是预编译模块，类似于预编译头文件。</p>

<p>目前 Swift 还是有很多 BUG 的，调用 <code>NSObject</code> 也许会让编译器直接 segment fault ，不带任何出错信息。很伤情。此时请第一时间检查语法是否有诡异，其次将所有用到字符串或者 <code>Optional</code> 的地方都额外用变量处理，避免用字面常量。（个人经验）</p>

<p>如果多次调用 <code>pod install</code> 并在其中修改过 <code>Podfile</code>，那么有可能你的项目依赖会乱掉，多了不存在的 <code>.a</code> 文件到依赖或者多次包含。手工在项目树和项目选项里删除就可以了。此类编译错误都是链接错误。</p>

<h2>总结</h2>

<p>本文提出了一种 Bridging Header 之外的使用 CocoaPods 库的方法。利用有限的 Ruby 知识写了个 Hook 。目前测试 OK 。</p>

<h2>参考</h2>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://cocoapods.org/">CocoaPods Offical Site</a> CocoaPods 官网<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.cocoachina.com/applenews/devnews/2014/0623/8917.html">CocoaPods - CocoaChina</a> CocoaChina 对 CocoaPods 的介绍<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking - Github</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><a href="https://github.com/JakeLin/SwiftWeather/blob/master/Swift%20Weather/ViewController.swift">SwiftWeather</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p><a href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/">Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)</a><a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Reflection （Swift 的反射）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/20/swift-reflection/"/>
    <updated>2014-06-20T23:48:51+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/20/swift-reflection</id>
    <content type="html"><![CDATA[<p>Swift 其实是支持反射的，不过功能略弱。本文介绍基本的反射用法和相关类型。</p>

<h2>MetaType 和 Type 语法</h2>

<blockquote><p>The metatype of a class, structure, or enumeration type is the name of that type followed by .Type. The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by .Protocol. For example, the metatype of the class type SomeClass is SomeClass.Type and the metatype of the protocol SomeProtocol is SomeProtocol.Protocol.</p>

<p>You can use the postfix self expression to access a type as a value. For example, SomeClass.self returns SomeClass itself, not an instance of SomeClass. And SomeProtocol.self returns SomeProtocol itself, not an instance of a type that conforms to SomeProtocol at runtime.</p></blockquote>

<ul>
<li>metatype-type -> <code>type</code>.<strong>Type</strong> | <code>type</code>.<strong>Protocol</strong></li>
<li>type-as-value -> <code>type</code>.self</li>
</ul>


<p>其中 metatype-type 出现在代码中需要类型的地方， type-as-value 出现在代码中需要值、变量的地方。</p>

<p><code>Any.Type</code> 类型大家可以猜下它表示什么。</p>

<h2>基础定义</h2>

<p>反射信息用 <code>Mirror</code> 类型表示，类型协议是 <code>Reflectable</code>，但实际看起来 <code>Reflectable</code> 没有任何作用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Reflectable {
</span><span class='line'>  func getMirror() -&gt; Mirror
</span><span class='line'>}
</span><span class='line'>protocol Mirror {
</span><span class='line'>  var value: Any { get }
</span><span class='line'>  var valueType: Any.Type { get }
</span><span class='line'>  var objectIdentifier: ObjectIdentifier? { get }
</span><span class='line'>  var count: Int { get }
</span><span class='line'>  subscript (i: Int) -&gt; (String, Mirror) { get }
</span><span class='line'>  var summary: String { get }
</span><span class='line'>  var quickLookObject: QuickLookObject? { get }
</span><span class='line'>  var disposition: MirrorDisposition { get }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>实际上所有类型都实现了 <code>Reflectable</code>。</p>

<p><code>Mirror</code> 协议相关字段：</p>

<ul>
<li><code>value</code> 相当于变量的 <code>as Any</code> 操作</li>
<li><code>valueType</code> 获得变量类型</li>
<li><code>objectIdentifier</code> 相当于一个 UInt 作用未知，可能是 metadata 表用到</li>
<li><code>count</code> 子项目个数（可以是类、结构体的成员变量，也可以是字典，数组的数据）</li>
<li><code>subscript(Int)</code> 访问子项目, 和子项目的名字</li>
<li><code>summary</code> 相当于 <code>description</code></li>
<li><code>quickLookObject</code> 是一个枚举，这个在 WWDC 有讲到，就是 Playground 代码右边栏的显示内容，比如常见类型，颜色，视图都可以</li>
<li><code>disposition</code> 表示变量类型的性质，基础类型 or 结构 or 类 or 枚举 or 索引对象 or &hellip; 如下</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum MirrorDisposition {
</span><span class='line'>  case Struct // 结构体
</span><span class='line'>  case Class // 类
</span><span class='line'>  case Enum // 枚举
</span><span class='line'>  case Tuple // 元组
</span><span class='line'>  case Aggregate // 基础类型
</span><span class='line'>  case IndexContainer // 索引对象
</span><span class='line'>  case KeyContainer // 键-值对象
</span><span class='line'>  case MembershipContainer // 未知
</span><span class='line'>  case Container // 未知
</span><span class='line'>  case Optional // Type?
</span><span class='line'>  var hashValue: Int { get }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过函数 <code>func reflect&lt;T&gt;(x: T) -&gt; Mirror</code> 可以获得反射对象 <code>Mirror</code> 。它定义在 <code>Any</code> 上，所有类型均可用。</p>

<h2>实际操作</h2>

<h3><code>.valueType</code> 处理</h3>

<p><code>Any.Type</code> 是所有类型的元类型，所以 <code>.valueType</code> 属性表示类型。实际使用的时候还真是有点诡异：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let mir = reflect(someVal)
</span><span class='line'>swith mir.valueType {
</span><span class='line'>case _ as String.Type:
</span><span class='line'>    println("type = string")
</span><span class='line'>case _ as Range&lt;Int&gt;.Type:
</span><span class='line'>    println("type = range of int")
</span><span class='line'>case _ as Dictionary&lt;Int, Int&gt;.Type:
</span><span class='line'>    println("type = dict of int")
</span><span class='line'>case _ as Point.Type:
</span><span class='line'>    println("type = a point struct")
</span><span class='line'>default:
</span><span class='line'>    println("unkown type")
</span><span class='line'>}    </span></code></pre></td></tr></table></div></figure>


<p>或者使用 <code>is</code> 判断：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if mir.valueType is String.Type {
</span><span class='line'>    println("!!!type =&gt; String")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>勘误： 这里之前笔误了。遗漏了 <code>.valueType</code> 。</p>

<p><code>is String</code> 判断变量是否是 String 类型，而 <code>is String.Type</code> 这里用来判断类型是否是 String 类型。</p>

<h3><code>subscript(Int)</code> 处理</h3>

<p>实测发现直接用 <code>mir[0]</code> 访问偶尔会出错，也许是 beta 的原因。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for r in 0..mir.count {
</span><span class='line'>    let (name, subref) = mir[r]
</span><span class='line'>    prtln("name: \(name)")
</span><span class='line'>    // visit sub Mirror here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过上面的方法，基本上可以遍历大部分结构。</p>

<h2>不同类型的处理</h2>

<h3>Struct 结构体、 Class 类</h3>

<ul>
<li><code>.count</code> 为字段个数。</li>
<li><code>subscript(Int)</code> 返回 （字段名，字段值反射 <code>Mirror</code>） 元组</li>
<li><code>summary</code> 为 mangled name</li>
</ul>


<h3>Tuple 元组</h3>

<ul>
<li><code>.count</code> 为元组子元素个数</li>
<li><code>subscript(Int)</code> 的 name 为 &ldquo;.0&rdquo;, &ldquo;.1&rdquo; &hellip;</li>
</ul>


<h3>Aggregate 基础类型</h3>

<p>包括数字、字符串（含 <code>NSString</code>）、函数、部分 Foundation 类型、 MetaType 。</p>

<p>很奇怪一点是测试发现枚举也被反射为基础类型。怀疑是没实现完。</p>

<ul>
<li><code>.count</code> 为 0</li>
</ul>


<h3>IndexContainer 索引对象</h3>

<p>包括 <code>Array&lt;T&gt;</code>, <code>T[]</code>, <code>NSArray</code> 等。可以通过 subscript 访问。</p>

<ul>
<li><code>.count</code> 为元组子元素个数</li>
<li><code>subscript(Int)</code> 的 name 为 &ldquo;[0]&rdquo;, &ldquo;[1]&rdquo; &hellip;</li>
</ul>


<h3>KeyContainer 键-值对象</h3>

<p>包括 <code>Dictionary&lt;T, U&gt;</code>、<code>NSDictionary</code></p>

<ul>
<li><code>.count</code> 为元组子元素个数</li>
<li><code>subscript(Int)</code> 的 name 为 &ldquo;[0]&rdquo;, &ldquo;[1]&rdquo; &hellip; 实际访问是 <code>(name, (reflect(key), reflect(val)))</code></li>
</ul>


<h3>Optional Type?</h3>

<p>只包括 <code>Type?</code>，不包括 <code>Type!</code>。</p>

<ul>
<li><code>.count</code> 为 0 或者 1 (对应 nil 和有值的情况)</li>
<li><code>subscript(Int)</code> , name 为 &ldquo;Some&rdquo;</li>
</ul>


<h3>其他</h3>

<ul>
<li>Enum 枚举 看起来是未使用</li>
<li>MembershipContainer // 未知</li>
<li>Container // 未知</li>
</ul>


<h2>示例代码</h2>

<p><a href="https://gist.github.com/anonymous/190fc7ecee30e83a5dca">Gist</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Module System of Swift (简析 Swift 的模块系统)]]></title>
    <link href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/"/>
    <updated>2014-06-19T15:14:31+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/19/modules-for-swift</id>
    <content type="html"><![CDATA[<p>声明： 转载注明我或者 SwiftChina, 请在方便的情况下情尽量告知. <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文的发现基于个人研究。请尊重原创。</p>

<h2>引子</h2>

<blockquote><p>你之所以认为 Swift 最像 Scala, 那是因为你还没学过 Rust. &mdash;- 猫·仁波切</p></blockquote>

<p>Swift 中模块是什么？当写下 Swift 中一句 <code>import Cocoa</code> 的时候到底整了个什么玩意？官方 ibook 很含糊只是提了半页不到。</p>

<p>本文解决如下问题</p>

<ul>
<li>介绍 Swift 中两种可 import 的模块</li>
<li>如何用 Swift 写一个可被其他 Swift 代码使用的模块</li>
<li>分析 Swift 的标准库实现方式</li>
</ul>


<h2>第一部分 Clang 模块（系统模块）</h2>

<p>Clang 模块是来自系统底层的模块，一般是 C/ObjC 的头文件。原始 API 通过它们暴露给 Swift ，编译时需要链接到对应的 Library。</p>

<p>例如 <code>UIKit</code>、<code>Foundation</code> 模块，从这些模块 dump 出的定义来看，几乎是完全自动生成的。当然， <code>Foundation</code> 模块更像是自动生成 + 人工扩展（我是说其中的隐式类型转换定义、对 Swift 对象的扩展等，以及 <code>@availability</code> 禁用掉部分函数。）。相关函数声明可以从 <a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a> 获得。</p>

<p>我可不觉得这些定义全部都是官方生成后给封装进去的。所以在整个 Xcode-6 beta2 目录树里进行了探索。</p>

<p>在 Xcode 目录寻找相关信息，最后目标锁定到了一个特殊的文件名 <code>module.map</code>。</p>

<p>原来这个文件叫 Module map(这个名字还真是缺乏想象力)，属于 llvm 的 Module 系统。本来是用来颠覆传统的 C/C++/Objc 中的 <code>#include</code> 和 <code>#import</code>。最早在 2012 年 11 月的 LLVM DevMeeting 中由 Apple 的 Doug Gregor 提出 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。相关内容 CSDN 也有文章介绍，不过是直译版，没有提出自己见解 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p>

<h3>关于 llvm Module 系统</h3>

<p>2012 年提出概念，所以其实这个东西已经很早就实现了 。简单说就是用树形的结构化描述来取代以往的平坦式 <code>#include</code>， 例如传统的 <code>#include &lt;stdio.h&gt;</code> 现在变成了 <code>import std.io;</code>， 逼格更高。主要好处有：</p>

<ul>
<li>语义上完整描述了一个框架的作用</li>
<li>提高编译时可扩展性，只编译或 include 一次。避免头文件多次引用，只解析一次头文件甚至不需要解析（类似预编译头文件）</li>
<li>减少碎片化，每个 module 只处理一次，环境的变化不会导致不一致</li>
<li>对工具友好，工具（语言编译器）可以获取更多关于 module 的信息，比如链接库，比如语言是 C++ 还是 C</li>
<li>等等</li>
</ul>


<p>所以这么好的一个东西， Apple 作为 llvm 的主力，在它的下一代语言中采用几乎是一定的。</p>

<p>算了，我是个半路出家的，之前没接触过 iOS / MacOSX 开发，其实 2013 年的 WWDC， Apple 为 Objective-C 加入的 <code>@import</code> 语法就是它。可以认为，这是第一次这个 Module 系统得到应用。</p>

<h4>module.map 文件</h4>

<p><code>module.map</code> 文件就是对一个框架，一个库的所有头文件的结构化描述。通过这个描述，桥接了新语言特性和老的头文件。默认文件名是 <code>module.modulemap</code>，<code>module.map</code> 其实是为了兼容老标准，不过现在 Xcode 里的还都是这个文件名，相信以后会改成新名字。</p>

<p>文件的内容以 <code>Module Map Language</code> 描述，大概语法我从 llvm 官方文档 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 摘录一段，大家体会一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module MyLib {
</span><span class='line'>  explicit module A {
</span><span class='line'>    header "A.h"
</span><span class='line'>    export *
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  explicit module B {
</span><span class='line'>    header "B.h"
</span><span class='line'>    export *
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>类似上面的语法，描述了 <code>MyLib</code>、<code>MyLib.A</code>、<code>MyLib.B</code> 这样的模块结构。</p>

<p>官方文档 [^3] 中有更多相关内容，可以描述框架，描述系统头文件，控制导出的范围，描述依赖关系，链接参数等等。这里不多叙述，举个 libcurl 的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module curl [system] [extern_c] {
</span><span class='line'>    header "/usr/include/curl/curl.h"
</span><span class='line'>    link "curl"    
</span><span class='line'>    export *
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>将此 <code>module.map</code> 文件放入任意文件夹，通过 Xcode 选项或者命令行参数，添加路径到 import search path （swift 的 -I 参数）。
然后就可以在 Swift 代码里直接通过 <code>import curl</code> 导入所有的接口函数、结构体、常量等，(实测，发现 <code>curl_easy_setopt</code>
无法自动导入，看起来是声明语法太复杂导致）。甚至可以直接从 swift repl 调用，体验脚本语言解释器般的快感（因为我们已经指定了链接到 curl 库）。</p>

<p>Xcode 选项位于 Build Settings 下面的 Swift Compiler - Search Paths 。添加路劲即可。</p>

<p>再举个复杂点的 <code>SDL2.framework</code> 的例子，看看如何实现树形的模块结构，这个需要把 <code>module.map</code> 放到 <code>.framework</code> 目录里</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>framework module SDL2 [system] {
</span><span class='line'>  umbrella header "SDL.h"
</span><span class='line'>  link -framework SDL2
</span><span class='line'>
</span><span class='line'>  module Version {
</span><span class='line'>    header "SDL_version.h"
</span><span class='line'>    export *
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  module Event {
</span><span class='line'>    header "SDL_events.h"
</span><span class='line'>    export *
</span><span class='line'>  }
</span><span class='line'>  // ....
</span><span class='line'>  export *
</span><span class='line'>  module * {
</span><span class='line'>    export *
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>小结</h3>

<p>Swift 的 C 模块（也是它的标准库部分）完全就是 llvm 的 Module 系统，在 import search path 的所有 module.map 中的模块都可以被识别，唯一缺点可能是如果有过于复杂用到太多高级 C 或者黑暗 C 语法的函数，无法很好识别，相信以后的版本会有所改善。</p>

<p>所以当有人问 Swift 到底有多少标准库的时候，答案就是，基本上系统里所有的 Objective-C 和 C 头文件都可以调用。自 iOS 7 时代，这些头文件就已经被组织为 Module 了，包括标准 C 库 <code>Darwin.C</code>。同样因为 Module 系统来自于传统的 C/C++/Objc 头文件，所以 Swift 虽然可以有 <code>import ModA.ModB.ModC</code> 的语句，但是整个模块函数名字空间还是平坦的。</p>

<p>一些有意思的模块可以探索探索，比如 <code>simd</code>，比如 <code>Python</code>（没错是的，直接调用 Python 解释器）等。</p>

<p>另外 Swift 的 <code>-module-cache-path</code> 参数可以控制这类模块预编译头的存放位置（ .pcm 文件： pre compiled module）。</p>

<p>Xcode 项目的 Build Settings ， Apple LLVM 6.0 - Language - Modules 有项目对 Module 支持的相关选项，默认是打开的。</p>

<h2>第二部分 Swift 模块</h2>

<p>说完了系统模块，该说 Swift 模块了。 Swift 自身的这个系统还是很赞的。</p>

<p>本节介绍怎样用 Swift 创建一个可 import 的模块。</p>

<h3>几个文件类型</h3>

<p>先清楚几个文件类型。假设 <code>ModName.swift</code> 是我们的 Swift 源码文件。</p>

<ul>
<li><code>ModName.swiftmodule</code> Swift 的模块文件，有了它，才能 import</li>
<li><code>ModName.swiftdoc</code> 保存了从源码获得的文档注释

<ul>
<li>文档注释以 <code>///</code> 开头</li>
</ul>
</li>
<li><code>libswiftModName.dylib</code> 动态链接库</li>
<li><code>libswiftModName.a</code>  静态链接库</li>
</ul>


<p>TODO: 目前有个疑问就是 <code>.swiftmodule</code> 和链接库到底什么时候用哪个，以及具体作用。</p>

<h4>.swift 源码文件</h4>

<p>先明确一个概念，一个 .swift 文件执行是从它的第一条非声明语句（表达式、控制结构）开始的，同时包括声明中的赋值部分（对应为 mov 指令或者 lea 指令），所有这些语句，构成了该 .swift 文件的 <code>top_level_code()</code> 函数。</p>

<p>而所有的声明，包括结构体、类、枚举及其方法，都不属于 <code>top_level_code()</code> 代码部分，其中的代码逻辑，包含在其他区域，<code>top_level_code()</code> 可以直接调用他们。</p>

<p>程序的入口是隐含的一个 <code>main(argc, argv)</code> 函数，该函数执行逻辑是设置全局变量 <code>C_ARGC</code> <code>C_ARGV</code>，然后调用 <code>top_level_code()</code>。</p>

<p>不是所有的 .swift 文件都可以作为模块，目前看，任何包含表达式语句和控制控制的 .swift 文件都不可以作为模块。正常情况下模块可以包含全局变量(<code>var</code>)、全局常量(<code>let</code>)、结构体(<code>struct</code>)、类(<code>class</code>)、枚举(<code>enum</code>)、协议(<code>protocol</code>)、扩展(<code>extension</code>)、函数(func)、以及全局属性(<code>var { get set }</code>)。这里的全局，指的是定义在 top level 。</p>

<p>这里说的表达式指 expression ，语句指 statement ，声明指 declaration 。可能和有些人对相关概念的定义不同。实际上我特无奈有些人纠结于概念问题，而不是问题本身，本来翻译过来的舶来品就有可能有误差，当你明白那指的是什么的时候，就可以了。</p>

<h3>模块编译方法</h3>

<p>这里先以命令行操作为例，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) ModName.swift -emit-library -emit-module -module-name ModName -v -o libswiftModName.dylib -module-link-name swiftModName</span></code></pre></td></tr></table></div></figure>


<p>执行后获得 <code>ModName.swiftdoc</code>、<code>ModName.swiftmodule</code>、<code>libswiftModName.dylib</code>.</p>

<p>这三个文件就可以表示一个可 import 的 Swift 模块。目前看起来 dylib 是必须得有的，否则链接过程报错。实际感觉 <code>.swiftmodule</code> 文件所包含的信息还需要继续挖掘挖掘。</p>

<p>多个源码文件直接依次传递所有文件名即可。</p>

<p>静态链接库 <code>.a</code> 目前还没有找到方法， <code>-Xlinker -static</code> 会报错。</p>

<h4>命令行参数解释</h4>

<p>相关命令行参数：</p>

<ul>
<li><code>-module-name &lt;value&gt;</code>       Name of the module to build 模块名</li>
<li><code>-emit-library</code>              编译为链接库文件</li>
<li><code>-emit-module-path &lt;path&gt;</code>   Emit an importable module to <path> 编译模块到路径（全路径，包含文件名）</li>
<li><code>-emit-module</code>               Emit an importable module</li>
<li><code>-module-link-name &lt;value&gt;</code>  Library to link against when using this module 该模块的链接库名，就是 <code>libswiftModName.dylib</code>，这个信息会直接写入到 <code>.swiftmodule</code></li>
</ul>


<h3>使用模块</h3>

<p>使用模块就很简单了，记住两个参数：</p>

<p><code>-I</code> 表示 import search path ，前面介绍过，保证 <code>.swiftmodule</code> 文件可以在 import search path 找到（这点很类似 module.map 文件，找得到这个就可以 import 可以编译）</p>

<p><code>-L</code> 表示 链接库搜索路径，保证 <code>.dylib</code> 文件可以在其中找到，如果已经在系统链接库目录中，就不需要这个参数。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) mymodtest.swift -I. -L.</span></code></pre></td></tr></table></div></figure>


<p>此时表示所有 module 文件都在当前目录。</p>

<p>这两个选项都可以在 Xcode 中指定，所以如果你有小伙伴编译好的 module 想在你的项目里用是完全 ok 的。</p>

<h3>For Xcode</h3>

<p>很不幸，没能在 Xcode 中找到编译模块的相关方法。等我发现如何搞定的时候我会补上这个坑。</p>

<p>不过在任何含 Swift 项目的编译过程中， <code>.swiftmodule</code> 文件总是伴随着 <code>.o</code> 文件传递。</p>

<h2>第三部分 瞎分析 .swiftmodule 文件</h2>

<p>简单分析下一个 .swiftmodule 所包含的信息。</p>

<h3>Foundation</h3>

<p>这里先以标准库的 <code>Foundation.swiftmodule</code> 下手。</p>

<p>用 hexdump 查看发现它包含所有导出符号，以及 mangled name 。还有个文件列表，表示它是从哪些文件获得的（可以是 .swift 也可以是 .swiftmodule ）。</p>

<p>用 strings 列出内容，发现 Foundation 库有如下特征:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>...
</span><span class='line'>Foundation
</span><span class='line'>LLVM 3.5svn
</span><span class='line'>/SourceCache/compiler_KLONDIKE/compiler_KLONDIKE-600.0.34.4.8/src/tools/swift/stdlib/objc/Foundation/Foundation.swift
</span><span class='line'>/SourceCache/compiler_KLONDIKE/compiler_KLONDIKE-600.0.34.4.8/src/tools/swift/stdlib/objc/Foundation/KVO.swift
</span><span class='line'>/SourceCache/compiler_KLONDIKE/compiler_KLONDIKE-600.0.34.4.8/src/tools/swift/stdlib/objc/Foundation/NSStringAPI.swift
</span><span class='line'>CoreFoundation
</span><span class='line'>Foundation
</span><span class='line'>Swift
</span><span class='line'>swiftFoundation
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>可以大胆猜测对应下：</p>

<ul>
<li><code>-module-name</code> => <code>Foundation</code></li>
<li>编译环境 => LLVM 3.5svn</li>
<li>源文件列表 => &hellip;</li>
<li>依赖列表 => <code>CoreFoundation</code>, <code>Foundation</code>, <code>Swift</code></li>
<li><code>-module-link-name</code> => <code>swiftFoundation</code></li>
</ul>


<p>我由此猜测， <code>Foundation</code> 的确是只有少量 Swift 代码做桥接。然后通过 Clang 模块将剩下工作交到底层。</p>

<p>分析其他类似模块也得到相同结果。</p>

<h3>Swift 标准库</h3>

<p>接下来有点好奇标准库 Swift 是怎么实现的。得到如下结果。</p>

<p>节选重要部分到 <a href="https://gist.github.com/andelf/8f28ead66cdc3637f978">我的 Gist</a></p>

<p>里面有些很有意思的信息，有兴趣的同学可以去看看。</p>

<p>依赖模块 SwiftShims 是一个 <code>module.map</code> 定义的模块，桥接的部分头文件。源文件有相关信息和注释。大致意思是用来实现几个底层接口对象，比如 <code>NSRange</code> 邓。</p>

<p>其中<code>-module-link-name</code> 是 <code>swift_stdlib_core</code>。</p>

<h2>结论</h2>

<p>LLVM Module 作为 Apple 提出的特性，已经被 Swift 完全采用，直接在它基础上建立了自己的模块系统。我相信它会影响到我们处理第三方库的方式方法。相信不久就会有相关工具基于它来管理依赖关系，比如老的 cocoapods<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 可以加入新特性。</p>

<p>用 Swift 写模块目前并没有很好的 IDE 支持，所以不是很方便。基于猜测验证，上面的方法可以实现在 Swift 里 import Swift 模块，方法和结果看起来完全和官方模块相同。</p>

<p>Swift 的标准库完全是上面两种模块的结合体，用 Swift 模块封装 Clang 模块。这就解决了文章一开始提出的问题：为什么标准库大部分看起来是自动生成代码，少部分又好像是人工写的接口代码。</p>

<h2>参考文献</h2>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Modules - Doug Gregor, Apple, 2012 LLVM DevMeeting <a href="http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf">PDF</a> <a href="http://llvm.org/devmtg/2012-11/videos/Gregor-Modules.mp4">Video</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.csdn.net/article/2012-11-28/2812274-module-replace-C-based-languages-headers">为什么应该用模块取代C/C++中的头文件？</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://clang.llvm.org/docs/Modules.html">Modules - Clang 3.5 documentation</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><a href="http://cocoapods.org/">CocoaPods</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift and C Interop Cont. (简析 Swift 和 C 的交互，Part 二)]]></title>
    <link href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/"/>
    <updated>2014-06-18T23:38:01+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont</id>
    <content type="html"><![CDATA[<p>声明： 转载注明我或者 SwiftChina . <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文的发现基于个人研究，目测是官方外的首创。请尊重原创。</p>

<p>本文是讲述 Swift 与 C 交互操作系列文章的第二部分。解决之前的所有遗留问题。</p>

<p>第一部分请参考 <a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">Swift and C Interop 简析Swift和C的交互</a></p>

<p>本文将介绍实际应用过程中会遇到的各类情况。</p>

<h2>再看类型对应</h2>

<p>标准类型这里就不提了，上面的文章讲的很明白了。</p>

<h3>7 种指针类型</h3>

<p>从代码看，我认为 Swift 对应 C 的指针时候，存在一个最原始的类型 <code>RawPointer</code>，但是它是内部表示，不可以直接使用。所以略过。但它是基础，可以认为它相当于 <code>Word</code> 类型（机器字长）。</p>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。</p>

<h4>COpaquePointer</h4>

<p>不透明指针。之前我以为它很少会用到，不过现在看来想错了，虽然类型不安全，但是很多场合只能用它。它是直接对应 <code>RawPointer</code> 的。字长相等。</p>

<blockquote><p>In computer programming, an opaque pointer is a special case of an opaque data type, a datatype declared to be a pointer to a record or data structure of some unspecified type. - 来自 Wikipedia</p></blockquote>

<p>几乎没有任何操作方法，不带类型，主要用于 Bridging Header 中表示 C 中的复杂结构指针</p>

<p>比如一个例子， libcurl 中的 <code>CURL *</code> 的处理，其实就是对应为 <code>COpaquePointer</code>。</p>

<h4>UnsafePointer<T></h4>

<p>泛型指针。直接对应 <code>RawPointer</code>。字长相等。</p>

<p>处理指针的主力类型。常量中的 <code>C_ARGV</code> 的类型也是它 <code>UnsafePointer&lt;CString&gt;</code>。</p>

<p>支持大量操作方法：</p>

<ul>
<li>通过 <code>.memory</code> 属性 <code>{ get set }</code> 操作指针指向的内容</li>
<li>支持 subscript ，直接对应于 C 的数组，例如 <code>C_ARGV[1]</code></li>
<li>通过 <code>alloc(num: Int)</code> 分配数组空间</li>
<li><code>initialize(val: T)</code> 直接初始化</li>
<li>offset 操作 <code>.succ()</code> <code>.pred()</code></li>
<li>可以从任意一种指针直接调用构造函数获得</li>
<li>隐式类型转换为非 <code>COpaquePointer</code> 之外的任意一种指针</li>
</ul>


<h4>AutoreleasingUnsafePointer<T></h4>

<p>之前特地写文介绍过这个指针类型。<code>NSError</code> 的处理就主要用它。传送门： <a href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a></p>

<p>内部实现用了语言内置特性，从名字也可以看出来，这个应该是非常棒的一个指针，可以帮助管理内存，逼格也高。内存直接对应 <code>RawPointer</code> 可以传递给 C 函数。</p>

<ul>
<li>通过 <code>.memory</code> 属性 <code>{ get set }</code> 操作指针指向的内容</li>
<li>直接从 <code>&amp;T</code> 类型获得，使用方法比较诡异，建议参考文章</li>
</ul>


<h4>CMutablePointer<T> CConstPointer<T></h4>

<p>分别对应于 C 中的 <code>T *</code>、<code>const T *</code>。不可直接传递给 C 函数，因为表示结构里还有一个 <code>owner</code> 域，应该是用来自动管理生命周期的。<code>sizeof</code> 操作返回 16。但是可以有隐式类型转换。</p>

<p>操作方法主要是 <code>func withUnsafePointer&lt;U&gt;(f: UnsafePointer&lt;T&gt; -&gt; U) -&gt; U</code>，用 Trailing Closure 语法非常方便。</p>

<h4>CMutableVoidPointer CConstVoidPointer</h4>

<p>分别对应于 C 中的 <code>void *</code>、<code>const void *</code>。其他内容同上一种。</p>

<h4>小结指针</h4>

<p>以上 7 种指针类型可以分未两类，我给他们起名为 第一类指针 和 第二类指针 。（你看我在黑马克思耶，算了这个梗太深，参考马克思主义政治经济学）</p>

<ul>
<li>可以直接用于 C 函数声明的 第一类指针

<ul>
<li><code>COpaquePointer</code> <code>UnsafePointer&lt;T&gt;</code> <code>AutoreleasingUnsafePointer&lt;T&gt;</code></li>
<li>是对 <code>RawPointer</code> 的封装，直接对应于 C 的指针，它们的 <code>sizeof</code> 都是单位字长</li>
</ul>
</li>
<li>不可用于声明 第二类指针

<ul>
<li><code>CMutablePointer&lt;T&gt; CConstPointer&lt;T&gt; CMutableVoidPointer CConstVoidPointer</code></li>
<li>直接从 Swift 对象的引用获得（一个隐藏特性，引用隐式转换）（主要构造方法）</li>
<li>包含了一个 <code>owner</code> 字段，可以管理生命周期，理论上在 Swift 中使用</li>
<li>通过 <code>.withUnsafePointer</code> 方法调用</li>
</ul>
</li>
</ul>


<p>所有指针都实现了 <code>LogicValue</code> 协议，可以直接 <code>if a_pointer</code> 判断是否为 <code>NULL</code>。</p>

<p><code>nil</code> 类型实现了到所有指针类型的隐式类型转换，等价于 C 中的 <code>`NULL</code>，可以直接判断。</p>

<p>什么时候用什么？这个问题我也在考虑中，以下是我的建议。</p>

<ul>
<li>对应复杂结构体，不操作结构体字段的： <code>COpaquePointer</code> 例如 <code>CURL *</code></li>
<li>日常操作： <code>UnsafePointer&lt;T&gt;</code></li>
<li>同时需要在 Swift 和 C 中操作结构体字段，由 Swift 管理内存：<code>AutoreleasingUnsafePointer&lt;T&gt;</code></li>
<li>Swift 中创建对象，传递给 C： 第二类指针</li>
</ul>


<h2>工具类型</h2>

<h3>CVarArg CVaListPointer VaListBuilder</h3>

<p>用于处理 C 语言中的可变参数 valist 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">protocol</span> <span class="nc">CVarArg</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">encode</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Word</span><span class="o">[]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>表示该类型可以作为可变参数，相当多的类型都实现了这个。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">struct</span> <span class="nc">CVaListPointer</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">UnsafePointer&lt;Void&gt;</span>
</span><span class='line'>    <span class="n">init</span><span class="o">(</span><span class="n">fromUnsafePointer</span> <span class="n">from</span><span class="k">:</span> <span class="kt">UnsafePointer&lt;Void&gt;</span><span class="o">)</span>
</span><span class='line'>    <span class="nd">@conversion</span> <span class="n">func</span> <span class="nc">__conversion</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">CMutableVoidPointer</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应于 C，直接给 C 函数传递，声明、定义时使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">VaListBuilder</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">init</span><span class="o">()</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">append</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">CVarArg</span><span class="o">)</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">va_list</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">CVaListPointer</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>工具类，方便地创建 <code>CVaListPointer</code>。</p>

<p>还有一些工具函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">func</span> <span class="n">getVaList</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">CVarArg</span><span class="o">[])</span> <span class="o">-&gt;</span> <span class="nc">CVaListPointer</span>
</span><span class='line'><span class="n">func</span> <span class="n">withVaList</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;(</span><span class="n">args</span><span class="k">:</span> <span class="kt">CVarArg</span><span class="o">[],</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">CVaListPointer</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">R</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">R</span>
</span><span class='line'><span class="n">func</span> <span class="n">withVaList</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;(</span><span class="n">builder</span><span class="k">:</span> <span class="kt">VaListBuilder</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">CVaListPointer</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">R</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">R</span>
</span></code></pre></td></tr></table></div></figure>


<p>非常方便。</p>

<h3>UnsafeArray<T></h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">struct</span> <span class="nc">UnsafeArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">:</span> <span class="kt">Collection</span><span class="o">,</span> <span class="nc">Generator</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">startIndex</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">var</span> <span class="kt">endIndex:</span> <span class="kt">Int</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">subscript</span> <span class="o">(</span><span class="kt">i:</span> <span class="kt">Int</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">T</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
</span><span class='line'>  <span class="kt">init</span><span class="o">(</span><span class="kt">start:</span> <span class="kt">UnsafePointer&lt;T&gt;</span><span class="o">,</span> <span class="kt">length:</span> <span class="kt">Int</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">next</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">?</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">generate</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">UnsafeArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>处理 C 数组的工具类型，可以直接 for-in 处理。当然，只读的，略可惜。</p>

<h3>Unmanaged<T></h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">struct</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="nc">_value</span><span class="k">:</span> <span class="kt">T</span>
</span><span class='line'>  <span class="n">init</span><span class="o">(</span><span class="nc">_private</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">fromOpaque</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">COpaquePointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">toOpaque</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">COpaquePointer</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">passRetained</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="n">passUnretained</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">takeUnretainedValue</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="n">T</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">takeRetainedValue</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="n">T</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">retain</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">release</span><span class="o">()</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">autorelease</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Unmanaged</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>顾名思义，手动管理 RC 的。避免 Swift 插入的 ARC 代码影响程序逻辑。</p>

<h2>C 头文件的导入行为</h2>

<h3>宏定义</h3>

<p>数字常量 CInt, CDouble (带类型后缀则为对应类型，如 1.0f ）
字符常量 CString
其他宏 展开后，无定义</p>

<h3>枚举 enum</h3>

<p>创建 enum 类型，并继承自 <code>CUnsignedInt</code> 或 <code>CInt</code> （enum 是否有负初始值）</p>

<p>可以通过 <code>.value</code> 访问。</p>

<h3>结构体 struct</h3>

<p>创建 struct 类型，只有默认 init ，需要加上所有结构体字段名创建。</p>

<h3>可变参数函数</h3>

<p>转为 <code>CVaListPointer</code>。手动重声明更好。这里举 <code>Darwin</code> 模块的例子说。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">func</span> <span class="n">vprintf</span><span class="o">(</span><span class="k">_:</span> <span class="kt">CString</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">CVaListPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CInt</span>
</span></code></pre></td></tr></table></div></figure>


<h2>从 C 调用 Swift</h2>

<p>只能调用函数。</p>

<p>之前说过，用 <code>@asmname("name")</code> 指定 mangled name 即可。</p>

<p>然后 C 语言中人工声明下函数。很可惜自动导出头文件不适用于 C 语言，只适用于 Objective-C 。</p>

<p>目测暂时无法导出结构体，因为 Swift 闭源不提供相关头文件。靠猜有风险。</p>

<p>全局变量不支持用 <code>@asmname("name")</code> 控制导出符号名。目测可以尝试用 mangled name 访问，但是很不方便。</p>

<h2>示例</h2>

<p>我尝试调用了下 libcurl 。</p>

<p>项目地址在 <a href="https://github.com/andelf/curl-swift">andelf/curl-swift</a> 包含编译脚本（就一句命令）。</p>

<p>Bridging Header 只写入 <code>#include&lt;curl/curl.h&gt;</code> 即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@asmname</span><span class="o">(</span><span class="s">&quot;curl_easy_setopt&quot;</span><span class="o">)</span> <span class="n">func</span> <span class="n">curl_easy_setopt</span><span class="o">(</span><span class="n">curl</span><span class="k">:</span> <span class="kt">COpaquePointer</span><span class="o">,</span> <span class="n">option</span><span class="k">:</span> <span class="kt">CURLoption</span><span class="o">,</span> <span class="n">param</span><span class="k">:</span> <span class="kt">CString</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CURLcode</span>
</span><span class='line'><span class="nd">@asmname</span><span class="o">(</span><span class="s">&quot;curl_easy_setopt&quot;</span><span class="o">)</span> <span class="n">func</span> <span class="n">curl_easy_setopt</span><span class="o">(</span><span class="n">curl</span><span class="k">:</span> <span class="kt">COpaquePointer</span><span class="o">,</span> <span class="n">option</span><span class="k">:</span> <span class="kt">CURLoption</span><span class="o">,</span> <span class="n">param</span><span class="k">:</span> <span class="kt">CBool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CURLcode</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">handle</span> <span class="k">=</span> <span class="n">curl_easy_init</span><span class="o">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// this should be a const c string. curl_easy_perform() will use this.</span>
</span><span class='line'><span class="n">let</span> <span class="n">url</span><span class="k">:</span> <span class="kt">CString</span> <span class="o">=</span> <span class="s">&quot;http://www.baidu.com&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">curl_easy_setopt</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="nc">CURLOPT_URL</span><span class="o">,</span> <span class="n">url</span><span class="o">)</span>
</span><span class='line'><span class="n">curl_easy_setopt</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="nc">CURLOPT_VERBOSE</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">ret</span> <span class="k">=</span> <span class="n">curl_easy_perform</span><span class="o">(</span><span class="n">handle</span><span class="o">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">error</span> <span class="k">=</span> <span class="n">curl_easy_strerror</span><span class="o">(</span><span class="n">ret</span><span class="o">)</span>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="s">&quot;error = \(error)&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>值得注意的是其中对单个函数的多态声明， <code>curl_easy_setopt</code> 实际上第三个参数是 <code>void *</code>。</p>

<p>以及对 <code>url</code> 的处理，实际上 libcurl 要求设置的 url 参数一直保持到 <code>curl_easy_perform</code> 时，所以这里用 <code>withUnsafePointer</code> 或者
<code>withCString</code> 是不太可取的方法。实际上或许可以用 <code>Unmanaged&lt;T&gt;</code> 来解决。</p>

<h2>总结</h2>

<p>我觉得说这么多。。。</p>

<p>调用 C 已经再没有别的内容可说了。其他的就是编程经验的问题，比如如何实现 C 回调 Swift 或者 Swift 回调 C 。可以参考其他语言的做法。解决方法不只一种。</p>

<h2>参考文献</h2>

<ul>
<li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a>。</li>
<li><a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">Swift and C Interop 简析Swift和C的交互 第一部分</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSObject Pattern Match in Swift (简析 Swift 中的 Pattern Match)]]></title>
    <link href="http://andelf.github.io/blog/2014/06/17/nsobject-pattern-match-in-swift/"/>
    <updated>2014-06-17T09:29:48+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/17/nsobject-pattern-match-in-swift</id>
    <content type="html"><![CDATA[<p>本文正式标题是：简析 Swift 中的 Pattern Match</p>

<p>副标题是：妈蛋 Swift 你又用黑属性坑大家了: 为什么 switch case 可以用数字匹配字符</p>

<p>声明： 原创发现，原创内容。转载注明我或者 SwiftChina . <a href="http://weibo.com/234632333">weibo</a></p>

<h2>问题的提出</h2>

<p>故事是这样的，昨天有人在论坛上发了个帖子，虽然不太规范而且含糊，不过还是能看出来他在问什么。<a href="http://swift.sh/topic/151/switch-case10/">传送门</a></p>

<p>重新把问题简化搬运过来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">let</span> <span class="n">count</span> <span class="k">=</span> <span class="s">&quot;0&quot;</span>
</span><span class='line'><span class="n">switch</span> <span class="n">count</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">1</span><span class="k">:</span>
</span><span class='line'>    <span class="kt">println</span><span class="o">(</span><span class="err">&quot;</span><span class="kt">location</span> <span class="err">1&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="kt">case</span> <span class="err">0</span><span class="kt">:</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="s">&quot;location 2&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="s">&quot;1&quot;</span><span class="k">:</span>
</span><span class='line'>    <span class="kt">println</span><span class="o">(</span><span class="err">&quot;</span><span class="kt">location</span> <span class="err">3&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="kt">default:</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="s">&quot;location 4&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么上面的代码可以通过编译？</p>

<h2>问题验证</h2>

<p>这几天说了很多了， Swift 是强类型语言，所以类型不同肯定不能在一起。直觉上，这段代码肯定不可能编译通过，错误一定是类型错误。</p>

<p>果断扔代码到文件，然后编译（我个人习惯用命令行直接编译）:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// 填入 test.swift</span>
</span><span class='line'><span class="n">xcrun</span> <span class="n">swift</span> <span class="o">-</span><span class="n">g</span> <span class="n">test</span><span class="o">.</span><span class="n">swift</span>
</span></code></pre></td></tr></table></div></figure>


<p>果然出错，不过出错信息略诡异：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">test</span><span class="o">.</span><span class="n">swift</span><span class="k">:</span><span class="err">4</span><span class="kt">:</span><span class="err">6</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">an</span> <span class="kt">overload</span> <span class="kt">for</span> <span class="err">&#39;</span><span class="kt">~=</span><span class="err">&#39;</span> <span class="kt">that</span> <span class="kt">accepts</span> <span class="kt">the</span> <span class="kt">supplied</span> <span class="kt">arguments</span>
</span><span class='line'><span class="k">case</span> <span class="mi">1</span><span class="k">:</span>
</span><span class='line'>     <span class="kt">^</span>
</span></code></pre></td></tr></table></div></figure>


<p>故事到这里也许完事了。嗯，不可以编译，问题也许是 Xcode 6 beta 版的 BUG 什么的。微博上的 <a href="http://weibo.com/owenzx">@肇鑫</a> 也提到， 用 Playground 编译也是出错，出错信息同上。</p>

<p>看起来暂时是无法重现问题。</p>

<h3>出错信息</h3>

<p>先解释下这个出错信息，熟读那本 ibook 的同学，可能会记得，在 swift case 那节是有讲到 <code>~=</code> 这个运算符的，也讲到了如何自定义它。</p>

<blockquote><p>Expression Pattern</p>

<p>An expression pattern represents the value of an expression. Expression patterns appear only in switch statement case labels.</p>

<p>The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator. The matches succeeds if the ~= operator returns true. By default, the ~= operator compares two values of the same type using the == operator. It can also match an integer value with a range of integers in an Range object.</p></blockquote>

<p>所以其实 <code>~=</code> 是一个匹配运算符(Pattern Match Operator)，专门用在 Pattern Match 的地方，比如 switch 的 case 。一般情况下它直接调用 <code>==</code> 运算符。</p>

<p>原书还写道：</p>

<blockquote><p>You can overload the ~= operator to provide custom expression matching behavior. For example, you can rewrite the above example to compare the point expression with a string representations of points.</p></blockquote>

<p>说明 Pattern Match 的行为是可以通过重载 <code>~=</code> 控制的。书中有重载的例子，小伙伴们可以看看。</p>

<p>深入下，来看看 <code>~=</code> 到底是什么东西：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@transparent</span> <span class="n">func</span> <span class="o">~=&lt;</span><span class="n">T</span> <span class="k">:</span> <span class="kt">Equatable&gt;</span><span class="o">(</span><span class="kt">a:</span> <span class="kt">T</span><span class="o">,</span> <span class="kt">b:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span><span class='line'><span class="n">func</span> <span class="o">~=&lt;</span><span class="n">T</span> <span class="k">:</span> <span class="kt">RandomAccessIndex</span> <span class="kt">where</span> <span class="kt">T.DistanceType</span> <span class="kt">:</span> <span class="kt">SignedInteger&gt;</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">Range&lt;T&gt;</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，首先它可以匹配两个相同类型的 Equatable，而且是 <code>@transparent</code>，说明没有额外开销， inline 函数，从书中看，完全等价于调用 <code>==</code>，不深究了。</p>

<p>然后，它可以匹配一个 <code>Rnage&lt;T&gt;</code> 和 <code>T</code>，这也就是我们在 switch case 里写的 <code>case 1..18: println("未成年")</code> 背后的奥秘，略有开销。</p>

<p>以上说明了为什么出错信息提示为什么是 <code>~=</code> 运算符重载失败，而不是类型错误（其实也算是一种类型错误，没有找到适合运算符的类型）。</p>

<h3>再次尝试重现</h3>

<p>有了上面的线索，是不是怀疑我们遗漏了什么？回到原问题提出的地方：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">override</span> <span class="n">func</span> <span class="n">viewDidLoad</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'><span class="k">super</span><span class="o">.</span><span class="n">viewDidLoad</span><span class="o">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">count</span> <span class="k">=</span> <span class="s">&quot;0&quot;</span>
</span><span class='line'><span class="o">....</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来，他是在 App 环境下调用的，这也许就是问题的根源。之前有介绍过， Cocoa 框架给 Swift 语言添加了很多东西，包括一大批的 <code>extension</code>，还有一堆隐式类型转换。</p>

<p>我们在 <code>test.swift</code> 第一行加入 <code>import Cocoa</code>，重新编译。结果正常通过编译。代码执行结果符合预期，走 default 分支。</p>

<h3>这也不科学!</h3>

<p>小伙伴们惊呆了，看起来 <code>count</code> 变量明明是一个 <code>Character</code>，结果竟然能匹配 <code>Character</code> 和 <code>Int</code>。</p>

<h2>祭出 lldb</h2>

<p>lldb 挂上 exe ，看看汇编代码是怎么样的。带上注释。我摘录最能说明问题的一段。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='gas'><span class='line'>   <span class="err">;</span> <span class="err">这里是</span> <span class="nf">case</span> <span class="mi">1</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d1a:</span>  <span class="nf">movabsq</span> <span class="no">$0x01</span><span class="p">,</span> <span class="nv">%rdi</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d24:</span>  <span class="nf">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x148</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>   <span class="err">;</span> <span class="err">将</span> <span class="err">1</span> <span class="err">转换为</span> <span class="nf">NSNumber</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d2b:</span>  <span class="nf">callq</span>  <span class="mi">0x100003f32</span>               <span class="err">;</span> <span class="no">symbol</span> <span class="no">stub</span> <span class="no">for</span><span class="p">:</span> <span class="no">Swift.Int.__conversion</span> <span class="p">(</span><span class="no">Swift.Int</span><span class="p">)()</span> <span class="p">-</span><span class="err">&gt;</span> <span class="no">ObjectiveC.NSNumber</span>
</span><span class='line'>
</span><span class='line'>   <span class="err">;</span> <span class="err">此处省略调用</span> <span class="nf">ARC</span> <span class="err">代码若干</span>
</span><span class='line'>   <span class="na">....</span>
</span><span class='line'>
</span><span class='line'>   <span class="err">;</span> <span class="err">这里其实是</span> <span class="nl">count:</span> <span class="nf">String</span> <span class="p">,</span> <span class="err">三个寄存器表示</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">检查</span> <span class="nf">String</span> <span class="err">大小你会发现</span> <span class="no">sizeof</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="err">是</span> <span class="mi">24</span><span class="err">，三个</span> <span class="mi">64</span><span class="no">bit</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">熟悉</span> <span class="nf">Rust</span> <span class="err">的同学知道，字符串实现，无非三个</span> <span class="no">field</span> <span class="err">：</span> <span class="no">size</span> <span class="err">、</span> <span class="no">capacity</span> <span class="err">、</span><span class="no">pointer</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">猜测</span> <span class="nf">Swift</span> <span class="err">完全相同因为它大量借鉴了</span> <span class="no">Rust</span> <span class="err">（不服来喷）</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d43:</span>  <span class="nf">movq</span>   <span class="p">-</span><span class="mi">0x128</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d4a:</span>  <span class="nf">movq</span>   <span class="p">-</span><span class="mi">0x130</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rsi</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d51:</span>  <span class="nf">movq</span>   <span class="p">-</span><span class="mi">0x138</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdx</span>
</span><span class='line'>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d58:</span>  <span class="nf">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x158</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">这里将</span> <span class="nl">count:</span> <span class="nf">String</span> <span class="err">转换为</span> <span class="no">NSString</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d5f:</span>  <span class="nf">callq</span>  <span class="mi">0x100003f26</span>               <span class="err">;</span> <span class="no">symbol</span> <span class="no">stub</span> <span class="no">for</span><span class="p">:</span> <span class="no">Swift.String.__conversion</span> <span class="p">(</span><span class="no">Swift.String</span><span class="p">)()</span> <span class="p">-</span><span class="err">&gt;</span> <span class="no">ObjectiveC.NSString</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d64:</span>  <span class="nf">movq</span>   <span class="p">-</span><span class="mi">0x150</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d6b:</span>  <span class="nf">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rsi</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">**最最神奇的地方来了，这里调用了</span> <span class="err">~=</span> <span class="nf">ObjectiveC</span> <span class="err">版，比较两个</span> <span class="no">NSObject</span> <span class="err">的版本。</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100001d6e:</span>  <span class="nf">callq</span>  <span class="mi">0x100003f20</span>               <span class="err">;</span> <span class="no">symbol</span> <span class="no">stub</span> <span class="no">for</span><span class="p">:</span> <span class="no">ObjectiveC.</span><span class="err">~=</span> <span class="err">@</span><span class="no">infix</span> <span class="p">(</span><span class="no">ObjectiveC.NSObject</span><span class="p">,</span> <span class="no">ObjectiveC.NSObject</span><span class="p">)</span> <span class="p">-</span><span class="err">&gt;</span> <span class="no">Swift.Bool</span>
</span></code></pre></td></tr></table></div></figure>


<h2>分析</h2>

<p>上面一堆看不懂没关系，这里再复述下在 Cocoa 环境（或者说 Foundation 环境下）第一条 <code>case 1:</code> 的流程:</p>

<ul>
<li>将 1 转换为 <code>NSNumber</code>，通过隐式类型转换实现</li>
<li>将 <code>count</code> 转换为 <code>NSString</code>，通过隐式类型转换实现</li>
<li>调用 <code>NSObject</code> 重载版的 <code>~=</code> 运算符进行比较</li>
</ul>


<p>这么看起来明了多了。但是，我们的 <code>Character</code> 哪里去了？为什么 count 的类型变了？</p>

<p>直接下断点然后 repl 命令检查，果然，我们没有指定类型的 <code>count</code> 在这个版本中变成了一个 <code>String</code>。</p>

<p>从标准库定义看， <code>Character</code> 和 <code>String</code> 都实现了 <code>ExtendedGraphemeClusterLiteralConvertible</code> 协议，保证他们能从字符字面常量获得。所以实际上每当我们写 <code>let foo = "a"</code> 其实是完全依赖编译器的类型推导，选择到底是 <code>Character</code> 还是 <code>String</code>。</p>

<p>说明 Swift 编译器高大上，可以从当前加载的所有类型中推导出合法合理能编译的类型组合。来自 Haskell 背景的同学一定笑而不语，当然那种怎么改都凑不对类型的痛苦也是其他同学无法理解和感同身受的。</p>

<p>回头再看看 <code>ObjectiveC.~=</code> 这个运算符重载：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">func</span> <span class="o">~=(</span><span class="n">x</span><span class="k">:</span> <span class="kt">NSObject</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">NSObject</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义在 ObjectiveC 模块里，使用 <code>import ObjectiveC</code> 可以加载。这个模块是 Swift 到 Objective-C 的一些映射模块，基础的 <code>NSObject</code> 方法还有一些运行时控制函数。</p>

<p>当然 <code>Foundation</code>, <code>Cocoa</code> 这些都会加载它，所以理论上写应用的时候不需要指定，只要你用到了 <code>NSObject</code> 就一定有它。</p>

<p>实际上 WWDC 某一集里讲到（忘记了，等我再找到会补上），对比 <code>NSObject</code> 的时候，Swift 会选择调用 <code>isEqual</code> 方法。我们反汇编验证下。简单加点注释。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='gas'><span class='line'><span class="err">(</span><span class="nf">lldb</span><span class="p">)</span> <span class="no">dis</span> <span class="p">-</span><span class="no">a</span> <span class="mi">0x100003f20</span>
</span><span class='line'><span class="nf">asmtest</span><span class="err">`</span><span class="no">symbol</span> <span class="no">stub</span> <span class="no">for</span><span class="p">:</span> <span class="no">ObjectiveC.</span><span class="err">~=</span> <span class="err">@</span><span class="no">infix</span> <span class="p">(</span><span class="no">ObjectiveC.NSObject</span><span class="p">,</span> <span class="no">ObjectiveC.NSObject</span><span class="p">)</span> <span class="p">-</span><span class="err">&gt;</span> <span class="no">Swift.Bool</span><span class="p">:</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x100003f20:</span>  <span class="nf">jmpq</span>   <span class="p">*</span><span class="mi">0x1252</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>             <span class="err">;</span> <span class="p">(</span><span class="no">void</span> <span class="p">*)</span><span class="mi">0x00000001000e88d0</span><span class="p">:</span> <span class="no">ObjectiveC.</span><span class="err">~=</span> <span class="err">@</span><span class="no">infix</span> <span class="p">(</span><span class="no">ObjectiveC.NSObject</span><span class="p">,</span> <span class="no">ObjectiveC.NSObject</span><span class="p">)</span> <span class="p">-</span><span class="err">&gt;</span> <span class="no">Swift.Bool</span>
</span><span class='line'><span class="err">(</span><span class="nf">lldb</span><span class="p">)</span> <span class="no">dis</span> <span class="p">-</span><span class="no">a</span> <span class="mi">0x00000001000e88d0</span>
</span><span class='line'><span class="nf">libswiftObjectiveC.dylib</span><span class="err">`</span><span class="no">ObjectiveC.</span><span class="err">~=</span> <span class="err">@</span><span class="no">infix</span> <span class="p">(</span><span class="no">ObjectiveC.NSObject</span><span class="p">,</span> <span class="no">ObjectiveC.NSObject</span><span class="p">)</span> <span class="p">-</span><span class="err">&gt;</span> <span class="no">Swift.Bool</span><span class="p">:</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88d0:</span>  <span class="nf">pushq</span>  <span class="nv">%rbp</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88d1:</span>  <span class="nf">movq</span>   <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%rbp</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88d4:</span>  <span class="nf">pushq</span>  <span class="nv">%r15</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88d6:</span>  <span class="nf">pushq</span>  <span class="nv">%r14</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88d8:</span>  <span class="nf">pushq</span>  <span class="nv">%rbx</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88d9:</span>  <span class="nf">pushq</span>  <span class="nv">%rax</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">64位</span> <span class="err">寄存器传参</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88da:</span>  <span class="nf">movq</span>   <span class="nv">%rsi</span><span class="p">,</span> <span class="nv">%rbx</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88dd:</span>  <span class="nf">movq</span>   <span class="nv">%rdi</span><span class="p">,</span> <span class="nv">%r14</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88e0:</span>  <span class="nf">movq</span>   <span class="mi">0x3da1</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span>        <span class="err">;</span> <span class="err">&quot;</span><span class="no">isEqual</span><span class="p">:</span><span class="err">&quot;</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88e7:</span>  <span class="nf">movq</span>   <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rdx</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88ea:</span>  <span class="nf">callq</span>  <span class="mi">0x1000eb670</span>               <span class="err">;</span> <span class="no">symbol</span> <span class="no">stub</span> <span class="no">for</span><span class="p">:</span> <span class="no">objc_msgSend</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">测试</span> <span class="nl">isEqual:</span> <span class="err">调用的返回值，存到</span> <span class="err">%</span><span class="nf">r16b</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88ef:</span>  <span class="nf">testb</span>  <span class="nv">%al</span><span class="p">,</span> <span class="nv">%al</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88f1:</span>  <span class="nf">setne</span>  <span class="nv">%r15b</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88f5:</span>  <span class="nf">movq</span>   <span class="nv">%rbx</span><span class="p">,</span> <span class="nv">%rdi</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88f8:</span>  <span class="nf">callq</span>  <span class="mi">0x1000eb676</span>               <span class="err">;</span> <span class="no">symbol</span> <span class="no">stub</span> <span class="no">for</span><span class="p">:</span> <span class="no">objc_release</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e88fd:</span>  <span class="nf">movq</span>   <span class="nv">%r14</span><span class="p">,</span> <span class="nv">%rdi</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e8900:</span>  <span class="nf">callq</span>  <span class="mi">0x1000eb676</span>               <span class="err">;</span> <span class="no">symbol</span> <span class="no">stub</span> <span class="no">for</span><span class="p">:</span> <span class="no">objc_release</span>
</span><span class='line'>   <span class="err">;</span> <span class="err">本运算符函数返回值</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e8905:</span>  <span class="nf">movb</span>   <span class="nv">%r15b</span><span class="p">,</span> <span class="nv">%al</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e8908:</span>  <span class="nf">addq</span>   <span class="no">$0x8</span><span class="p">,</span> <span class="nv">%rsp</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e890c:</span>  <span class="nf">popq</span>   <span class="nv">%rbx</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e890d:</span>  <span class="nf">popq</span>   <span class="nv">%r14</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e890f:</span>  <span class="nf">popq</span>   <span class="nv">%r15</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e8911:</span>  <span class="nf">popq</span>   <span class="nv">%rbp</span>
</span><span class='line'>   <span class="err">0</span><span class="nl">x1000e8912:</span>  <span class="nf">retq</span>
</span></code></pre></td></tr></table></div></figure>


<p>啧啧， Instruction Pointer Relative Addressing 用的飞起。 64 位名字也特好听。 RIP 。 对了， MacOSX 下都是 PIC 位置无关代码。</p>

<p>从上面看，果然是调用了 Objective-C 的 <code>isEqual:</code>。</p>

<h2>总结</h2>

<ul>
<li>Swift 的编译器会根据大范围的代码推导类型，遍历 AST 然后用树或者图算法填充未指定的类型

<ul>
<li><code>"c"</code> 可以是任意 <code>ExtendedGraphemeClusterLiteralConvertible</code> 类型，包括 <code>Character</code>、<code>String</code>、<code>CString</code>、<code>UnicodeScalar</code>、<code>StaticString</code> 等</li>
</ul>
</li>
<li>swith case 语句使用 <code>~=</code> 运算符执行匹配操作

<ul>
<li>非 Foundation 环境下，相当于 <code>==</code> 运算符</li>
<li>在 Foundation 环境下，如果是 <code>NSObject</code> 及其子类，相当于 <code>isEqual:</code> 方法</li>
<li><code>a..b</code> 这样的匹配也是通过 <code>~=</code> 运算符实现，也可以重载后自定义</li>
</ul>
</li>
<li>在 Foundation 环境下，隐式类型转换遍地都是</li>
</ul>


<h2>教训</h2>

<ul>
<li>真用到字符类型 <code>Character</code> 的时候，还是显式指定吧</li>
<li>需要额外注意能隐式类型转换到 <code>NSObject</code> 的几个类型，避免非预期行为</li>
</ul>


<h2>参考文献</h2>

<ul>
<li>Apple Inc. “The Swift Programming Language”。 iBooks. <a href="https://itun.es/cn/jEUH0.l">https://itun.es/cn/jEUH0.l</a></li>
<li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">隐式类型转换</a></li>
<li>WWDC 某集讲到的 <code>isEqual:</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift NSError Internals（解析 Swift 对 NSError 操作）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/"/>
    <updated>2014-06-16T14:45:15+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/16/swift-nserror-internals</id>
    <content type="html"><![CDATA[<p>声明： 原创发现，原创内容。转载注明我或者 SwiftChina . <a href="http://weibo.com/234632333">weibo</a></p>

<p>其中基础部分借鉴了 WWDC 407 部分的介绍。</p>

<p>相关的分析主要基于我 dump 出的 Swift 标准库声明代码，位于 <a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a>。</p>

<h2>引子</h2>

<p>WWDC 407 中简单提到了 NSError 在 Swift 中的处理方法，说<code>NSErrorPointer is Swift’s version of NSError **</code>，其中大概内容是：</p>

<ul>
<li>Foundation 的所有函数中的 <code>NSError **</code> 都被对应为 Swift 中的 <code>NSErrorPointer</code> (自定义函数也应如此)</li>
<li>调用时候使用下面的方式：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">var</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSError?</span>
</span><span class='line'><span class="n">foobar</span><span class="o">(....,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">&amp;error</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这里一定要用 <code>var</code>，只有 var 才有引用的概念，才可以作为左值</li>
<li>定义时（重载一些带 NSError 参数的函数）(注意其中的 <code>.memory</code> 部分。)：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">override</span> <span class="n">func</span> <span class="n">contentsForType</span><span class="o">(</span><span class="n">typeName</span><span class="k">:</span> <span class="kt">String!</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span><span class="o">)</span><span class="err"> </span> <span class="o">-&gt;</span> <span class="nc">AnyObject</span><span class="o">!</span> <span class="o">{</span><span class="err"> </span>
</span><span class='line'>    <span class="k">if</span> <span class="n">cannotProduceContentsForType</span><span class="o">(</span><span class="n">typeName</span><span class="o">)</span> <span class="o">{</span><span class="err"> </span> <span class="k">if</span> <span class="n">error</span> <span class="o">{</span><span class="err"> </span>
</span><span class='line'>        <span class="n">error</span><span class="o">.</span><span class="n">memory</span> <span class="k">=</span> <span class="nc">NSError</span><span class="o">(</span><span class="n">domain</span><span class="k">:</span> <span class="kt">domain</span><span class="o">,</span> <span class="n">code</span><span class="k">:</span> <span class="kt">code</span><span class="o">,</span> <span class="n">userInfo</span><span class="k">:</span> <span class="err">[</span><span class="kt">:</span><span class="err">]</span><span class="o">)</span><span class="err"> </span> <span class="o">}</span><span class="err"> </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">nil</span><span class="err"> </span> <span class="o">}</span><span class="err"> </span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>到这里，基本怎么在 Swift 使用 <code>NSError</code> 已经足够了。但是本着探究妈蛋 Swift 到底藏起了多少黑魔法的伟(er)大(bi)精神，我继续分析下这里面的槽点。</p>

<h2>这不科学！</h2>

<p>我们知道 Swift 是强类型语言。类型不同怎么能在一起？直接出错才对。</p>

<p>当然也可能是之前提到过的“隐式类型转换”，所以这里探索下 <code>NSError</code> 和 <code>NSErrorPointer</code> 的关系，到底是如何实现了 Objective-C 中的 <code>NSError **</code>。</p>

<p>而且有一个逆天的地方是，<code>NSErrorPointer</code> 没有被标记为 <code>inout</code>，但传递参数时候需要传递 <code>NSError</code> 的引用。</p>

<h2>上代码</h2>

<p>这里给出 Swift 中 <code>NSError</code>、<code>NSErrorPointer</code> 及相关类型的声明代码。(部分）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@objc</span><span class="o">(</span><span class="nc">NSError</span><span class="o">)</span> <span class="k">class</span> <span class="nc">NSError</span> <span class="k">:</span> <span class="kt">NSObject</span><span class="o">,</span> <span class="nc">NSCopying</span><span class="o">,</span> <span class="nc">NSSecureCoding</span><span class="o">,</span> <span class="nc">NSCoding</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@objc</span><span class="o">(</span><span class="n">initWithDomain</span><span class="k">:</span><span class="kt">code:userInfo:</span><span class="o">)</span> <span class="n">init</span><span class="o">(</span><span class="n">domain</span><span class="k">:</span> <span class="kt">String!</span><span class="o">,</span> <span class="n">code</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">userInfo</span> <span class="n">dict</span><span class="k">:</span> <span class="kt">NSDictionary!</span><span class="o">)</span>
</span><span class='line'>  <span class="nd">@objc</span><span class="o">(</span><span class="n">errorWithDomain</span><span class="k">:</span><span class="kt">code:userInfo:</span><span class="o">)</span> <span class="k">class</span> <span class="nc">func</span> <span class="n">errorWithDomain</span><span class="o">(</span><span class="n">domain</span><span class="k">:</span> <span class="kt">String!</span><span class="o">,</span> <span class="n">code</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">userInfo</span> <span class="n">dict</span><span class="k">:</span> <span class="kt">NSDictionary!</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Self</span><span class="o">!</span>
</span><span class='line'>  <span class="nd">@objc</span> <span class="k">var</span> <span class="n">domain</span><span class="k">:</span> <span class="kt">String!</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">@objc</span><span class="o">(</span><span class="kt">domain</span><span class="o">)</span> <span class="kt">get</span> <span class="o">{}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kt">@objc</span><span class="o">(</span><span class="kt">init</span><span class="o">)</span> <span class="kt">convenience</span> <span class="kt">init</span><span class="o">()</span>
</span><span class='line'>  <span class="kt">....</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">typealias</span> <span class="nc">NSErrorPointer</span> <span class="k">=</span> <span class="nc">AutoreleasingUnsafePointer</span><span class="o">&lt;</span><span class="nc">NSError</span><span class="o">?&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">struct</span> <span class="nc">AutoreleasingUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">:</span> <span class="kt">Equatable</span><span class="o">,</span> <span class="nc">LogicValue</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">value</span><span class="k">:</span> <span class="kt">RawPointer</span>
</span><span class='line'>  <span class="nd">@transparent</span> <span class="n">init</span><span class="o">(</span><span class="k">_</span> <span class="n">value</span><span class="k">:</span> <span class="kt">RawPointer</span><span class="o">)</span>
</span><span class='line'>  <span class="nd">@transparent</span> <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion_get</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">RawPointer</span>
</span><span class='line'>  <span class="nd">@transparent</span> <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion_set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">RawPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">T</span>
</span><span class='line'>  <span class="nd">@transparent</span> <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion</span><span class="o">(</span><span class="n">inout</span> <span class="n">autoreleasingTemp</span><span class="k">:</span> <span class="kt">RawPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">AutoreleasingUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">var</span> <span class="nc">_isNull</span><span class="k">:</span> <span class="kt">Bool</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">@transparent</span> <span class="kt">get</span> <span class="o">{}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kt">@transparent</span> <span class="kt">func</span> <span class="kt">getLogicValue</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">memory</span><span class="k">:</span> <span class="kt">T</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">@transparent</span> <span class="kt">get</span> <span class="o">{}</span>
</span><span class='line'>    <span class="kt">@transparent</span> <span class="kt">set</span> <span class="o">{}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>分析</h2>

<p>由以上代码可以知道，<code>NSErrorPointer</code> 实际上是 <code>AutoreleasingUnsafePointer&lt;Optional&lt;NSError&gt;&gt;</code> 类型（这里我顺便展开了 <code>Type?</code>），
<code>AutoreleasingUnsafePointer&lt;T&gt;</code> 封装了一个 <code>RawPointer</code>，发挥想象力，差不多知道它就是个 <code>void *</code>，指向类型 <code>T</code>。在本例中，指向 <code>NSError?</code>。</p>

<p>一般情况下 Swift 的 <code>NSError!</code> 被用于对应 Objective-C 的 <code>NSError *</code>， 一层指针，可 nil. 所以这里，两层指针算是对应上了（一层 RawPointer, 一层靠语言本身的特性实现，这里暂时不考虑 <code>Type!</code> 和 <code>Type?</code> 的差异性，使用时候多注意就可以）。</p>

<p>然后就是棘手的问题，这里的类型转换是如何实现的？这里没有看到标准的隐式类型转换。但是有 <code>__writeback_conversion*</code> 一系列 static 函数。应该是他们起到了转换的作用（再次说明，Swift 是强类型语言，所以必然这样的特性有黑魔法）。</p>

<p>从名字和标准库的定义看，这三个函数应该是同时起作用，用于表述三个类型的关联关系。我写了个例子。</p>

<h3>示例代码</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">struct</span> <span class="nc">Foobar</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="k">val:</span> <span class="kt">Int</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@transparent</span> <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion_get</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Int</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">println</span><span class="o">(</span><span class="s">&quot;location 1&quot;</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">v</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toInt</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">v</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="nd">@transparent</span> <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion_set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">println</span><span class="o">(</span><span class="s">&quot;location 2&quot;</span><span class="o">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">toString</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">10000</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="nd">@transparent</span> <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion</span><span class="o">(</span><span class="n">inout</span> <span class="n">temp</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Foobar</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">println</span><span class="o">(</span><span class="s">&quot;location 3&quot;</span><span class="o">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nc">Foobar</span><span class="o">(</span><span class="k">val:</span> <span class="kt">temp</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">test_foobar</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Foobar</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">dump</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="err">&quot;</span><span class="kt">dump</span> <span class="kt">from</span> <span class="kt">test_foobar</span><span class="err">&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">word</span> <span class="k">=</span> <span class="s">&quot;9527&quot;</span>
</span><span class='line'><span class="n">test_foobar</span><span class="o">(&amp;</span><span class="n">word</span><span class="o">)</span>
</span><span class='line'><span class="n">dump</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="err">&quot;</span><span class="kt">word</span><span class="err">&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上，代码输出是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">location</span> <span class="mi">1</span>
</span><span class='line'><span class="n">location</span> <span class="mi">3</span>
</span><span class='line'><span class="o">▿</span> <span class="n">dump</span> <span class="n">from</span> <span class="n">test_foobar</span><span class="k">:</span> <span class="kt">V5trans6Foobar</span> <span class="o">(</span><span class="kt">has</span> <span class="err">1</span> <span class="kt">child</span><span class="o">)</span>
</span><span class='line'>  <span class="kt">-</span> <span class="kt">val:</span> <span class="err">9527</span>
</span><span class='line'><span class="kt">location</span> <span class="err">2</span>
</span><span class='line'><span class="kt">-</span> <span class="kt">word:</span> <span class="err">19527</span>
</span></code></pre></td></tr></table></div></figure>


<p>这三个函数在一次隐式调用中，全部都用到了，调用顺序如上。看起来隐藏在背后的关系明了了一些，流程大概是：</p>

<ul>
<li>用 <code>word</code> 调用 <code>Foobar.__writeback_conversion_get</code>，获得一个 <code>Int</code></li>
<li>用 <code>Int</code> 调用 <code>Foobar.__writeback_conversion</code>，构造了一个 <code>Foobar</code> 对象</li>
<li>将 <code>Foobar</code> 交给 <code>test_foobar</code> 函数内部处理</li>
<li>函数逻辑结束后，调用 <code>Foobar.__writeback_conversion_set</code>，获得字符串，赋值给 <code>word</code></li>
</ul>


<p>我返回到 <code>NSError</code> 说。</p>

<h3>回到 NSError 说</h3>

<p>最简删节版代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// T = NSError? = Optional&lt;NSError&gt;</span>
</span><span class='line'><span class="n">struct</span> <span class="nc">AutoreleasingUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">value</span><span class="k">:</span> <span class="kt">RawPointer</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion_get</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">RawPointer</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion_set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">RawPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">T</span>
</span><span class='line'>  <span class="n">static</span> <span class="n">func</span> <span class="nc">__writeback_conversion</span><span class="o">(</span><span class="n">inout</span> <span class="n">autoreleasingTemp</span><span class="k">:</span> <span class="kt">RawPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">AutoreleasingUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">memory</span><span class="k">:</span> <span class="kt">T</span> <span class="o">{</span> <span class="kt">get</span> <span class="kt">set</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当一个函数接受 <code>AutoreleasingUnsafePointer&lt;T&gt;</code> 作为参数的时候，我们可以直接传递 T 的引用 <code>&amp;T</code>，然后整个流程自动转换为</p>

<ul>
<li>用该引用参数调用 <code>__writeback_conversion_get</code> 获得一个 <code>RawPointer</code></li>
<li>调用 <code>__writeback_conversion</code> 获得一个 <code>AutoreleasingUnsafePointer&lt;T&gt;</code> 对象</li>
<li>将这个对象交给函数内部处里，调用相关方法</li>
<li>函数返回时，调用 <code>__writeback_conversion_set</code>，然后将结果赋值给一开始的引用参数，类型 <code>&amp;T</code> 的那个。</li>
</ul>


<p>如果是 <code>NSError</code> 的情况, 情况如下：</p>

<ul>
<li>某库函数接受 <code>NSErrorPointer</code> 作为参数，我们直接传递 <code>NSError?</code> 的引用 <code>&amp;error</code></li>
<li><code>error</code> 作为参数调用 <code>__writeback_conversion_get</code>， 获得 <code>RawPointer</code></li>
<li>用这个 <code>RawPointer</code> 调用 <code>__writeback_conversion</code>，获得一个 <code>NSErrorPointer</code> 对象</li>
<li>函数进行相关处理。对于 NSError 来说，这里一般是 Foundation 代码或者是 override 后的代码，在出错或者异常时访问 <code>.memory</code>，设置相应的错误</li>
<li>函数返回。用之前的 <code>RawPointer</code> 调用 <code>__writeback_conversion_set</code>，获得 <code>NSError?</code> 然后赋值给引用 error</li>
<li>接下来代码中可以对 error 进行判断，处理异常</li>
</ul>


<p>其中 <code>RawPointer</code> 之前我们已经讨论过，是指针，在整个过程中值不变，指针指向的内存，就是 <code>.memory</code> 属性操作的部分，才是可变的部分，不属于 <code>AutoreleasingUnsafePointer&lt;T&gt;</code> 的成员访问控制范围，所以这就是为什么函数参数中的 <code>NSErrorPointer</code> 为什么没有标记为 <code>inout</code> 的原因。</p>

<h2>总结</h2>

<p>这三个 static 函数合起来组成了整体功能。我觉得可以把这个功能叫做“引用的隐式类型转换”或者"隐式引用类型转换"。</p>

<p>当然，它的强大之处在于用隐藏了二重指针的细节，同时这个特性也可以有其他作用。比如。。。（我没想好）</p>

<h2>参考文献</h2>

<ul>
<li>WWDC 407</li>
<li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">隐式类型转换</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
