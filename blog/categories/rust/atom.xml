<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | 猫·仁波切]]></title>
  <link href="http://andelf.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://andelf.github.io/"/>
  <updated>2016-09-29T19:14:08+08:00</updated>
  <id>http://andelf.github.io/</id>
  <author>
    <name><![CDATA[猫·仁波切 (Feather)]]></name>
    <email><![CDATA[andelf@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rust Pattern Match(Rust中的模式匹配)]]></title>
    <link href="http://andelf.github.io/blog/2016/03/22/rust-pattern-match/"/>
    <updated>2016-03-22T23:35:19+08:00</updated>
    <id>http://andelf.github.io/blog/2016/03/22/rust-pattern-match</id>
    <content type="html"><![CDATA[<h1>模式匹配</h1>

<p>汉语字典中对“模式”的解释是：事物的标准样式。在计算机科学中，它指特定类型的数据（往往是序列或是树形结构）满足某一特定结构或格式。“匹配”本身是指一个判断寻找过程。最早的模式匹配用于文本编辑器中的正则字符串搜索，之后才作为编程语言特性。</p>

<h2>模式匹配基础</h2>

<p>模式匹配在计算机科学领域有两层意思。其一，可以特指字符串匹配算法，例如为人熟知的 KMP 字符串匹配算法、命令行工具 grep 等。
其二，特指在一些语言中作为一种以结构的方式处理数据的工具，此时的匹配过程往往是树形匹配，与此相伴的往往还有一个特性叫 guard（守卫）。</p>

<p>Rust 中模式匹配随处可见，例如在<code>let</code>变量绑定语句、<code>match</code>匹配语句中等。利用好模式匹配这一特性可以使代码更简洁易懂。<code>Rust</code>支持模式匹配中的变量绑定、结构体/元组解构、守卫条件判断、数值范围匹配等特性。</p>

<h3>原始匹配</h3>

<p><code>match</code> 语句中可以直接匹配字面常量，下划线<code>_</code>匹配任意情形。</p>

<pre><code class="rust">let x = 1;

match x {
    1 =&gt; println!("one"),
    2 =&gt; println!("two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}
</code></pre>

<p>以上代码会打印出<code>one</code>。</p>

<h3>结构匹配</h3>

<p><code>match</code> 用于匹配一个表达式的值，寻找满足条件的子分支(<code>arm</code>)并执行。每个子分支包含三部分：一系列模式、可选的守卫条件以及主体代码块。</p>

<h3>多个模式</h3>

<p>每个子分支可以是多个模式，通过 <code>|</code> 符号分割：</p>

<pre><code class="rust">let x = 1;

match x {
    1 | 2 =&gt; println!("one or two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}
</code></pre>

<p>以上代码打印出<code>one or two</code>。</p>

<h3>守卫条件</h3>

<p>通过<code>if</code>引入子分支的守卫条件：</p>

<pre><code class="rust">enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!("Got an int bigger than five!"),
    OptionalInt::Value(..) =&gt; println!("Got an int!"),
    OptionalInt::Missing =&gt; println!("No such luck."),
}
</code></pre>

<h2>模式匹配进阶</h2>

<p>其实进阶，不如直接从<code>libsyntax</code>源码看看到底模式匹配是如何实现。<code>syntax::ast::Pat</code>。</p>

<p>从AST源码中寻找语法要素屋外户两个要点，其一，语法要素是如何表达为对应AST的；其二，对应AST在哪些父AST中出现。</p>

<p>Rust中使用<code>syntax::ast::Pat</code>枚举来表示一个模式匹配。</p>

<pre><code class="rust">pub struct Pat {
    pub id: NodeId,
    pub node: PatKind,
    pub span: Span,
}

pub enum PatKind {
    /// Represents a wildcard pattern (`_`)
    /// 表示通配，下划线
    Wild,

    /// A `PatKind::Ident` may either be a new bound variable,
    /// or a unit struct/variant pattern, or a const pattern (in the last two cases
    /// the third field must be `None`).
    ///
    /// In the unit or const pattern case, the parser can't determine
    /// which it is. The resolver determines this, and
    /// records this pattern's `NodeId` in an auxiliary
    /// set (of "PatIdents that refer to unit patterns or constants").
    Ident(BindingMode, SpannedIdent, Option&lt;P&lt;Pat&gt;&gt;),

    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.
    /// The `bool` is `true` in the presence of a `..`.
    Struct(Path, Vec&lt;Spanned&lt;FieldPat&gt;&gt;, bool),

    /// A tuple struct/variant pattern `Variant(x, y, z)`.
    /// "None" means a `Variant(..)` pattern where we don't bind the fields to names.
    TupleStruct(Path, Option&lt;Vec&lt;P&lt;Pat&gt;&gt;&gt;),

    /// A path pattern.
    /// Such pattern can be resolved to a unit struct/variant or a constant.
    Path(Path),

    /// An associated const named using the qualified path `&lt;T&gt;::CONST` or
    /// `&lt;T as Trait&gt;::CONST`. Associated consts from inherent impls can be
    /// referred to as simply `T::CONST`, in which case they will end up as
    /// PatKind::Path, and the resolver will have to sort that out.
    QPath(QSelf, Path),

    /// A tuple pattern `(a, b)`
    Tup(Vec&lt;P&lt;Pat&gt;&gt;),
    /// A `box` pattern
    Box(P&lt;Pat&gt;),
    /// A reference pattern, e.g. `&amp;mut (a, b)`
    Ref(P&lt;Pat&gt;, Mutability),
    /// A literal
    Lit(P&lt;Expr&gt;),
    /// A range pattern, e.g. `1...2`
    Range(P&lt;Expr&gt;, P&lt;Expr&gt;),
    /// `[a, b, ..i, y, z]` is represented as:
    ///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`
    Vec(Vec&lt;P&lt;Pat&gt;&gt;, Option&lt;P&lt;Pat&gt;&gt;, Vec&lt;P&lt;Pat&gt;&gt;),
    /// A macro pattern; pre-expansion
    Mac(Mac),
}
</code></pre>

<p>以上AST定义，即说明，到底什么被认为是一个“模式”。</p>

<p>以下介绍<code>Pat</code>在哪些AST中出现。</p>

<h3>全局 Item</h3>

<p>全局 Item 中，使用模式匹配的均为函数参数。</p>

<h4>ItemKind::Fn</h4>

<p><code>Fn</code> 全局函数 -> <code>FnDecl</code> 函数声明 -> <code>[Arg]</code> 函数头参数声明。</p>

<h4>ItemKind::Trait</h4>

<p><code>Trait</code> -> <code>[TraitItem]</code> -> <code>TraitItemKind::Method</code> -> <code>MethodSig</code> -> <code>FnDecl</code> 方法声明，同上。</p>

<h4>ItemKind::Impl</h4>

<p><code>Impl</code> -> <code>[ImplItem]</code> -> <code>ImplItemKind::Method</code> -> <code>MethodSig</code> -> <code>FnDecl</code>。</p>

<h3>ast::Stmt 语句</h3>

<h4>StmtKind::Decl</h4>

<p><code>Decl</code> -> <code>DeclKind::Local</code>。</p>

<p>即 <code>let</code> 语句 <code>let &lt;pat&gt;:&lt;ty&gt; = &lt;expr&gt;;</code>。</p>

<h4>StmtKind::Expr 表达式</h4>

<p>见下。</p>

<h3>ast::Expr</h3>

<p>除<code>match</code>外，<code>if let</code>、<code>while let</code>、<code>for</code>控制语句支持同时进行模式匹配。具体实现是一种<code>desugared</code>过程，即，去语法糖化。</p>

<p>同时类似于函数定义，闭包参数也支持模式匹配。</p>

<h4>if let</h4>

<p><code>IfLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;P&lt;Expr&gt;&gt;)</code></p>

<p><code>if let pat = expr { block } else { expr }</code></p>

<p>This is desugared to a match expression.</p>

<h4>while let</h4>

<p><code>WhileLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code>'label: while let pat = expr { block }</code></p>

<h4>for</h4>

<p><code>ForLoop(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code>'label: for pat in expr { block }</code></p>

<h4>match</h4>

<p><code>Match(P&lt;Expr&gt;, Vec&lt;Arm&gt;)</code></p>

<p><code>match</code> 语句，在 <code>Arm</code> 中出现，其中 <code>Arm</code> 定义为</p>

<pre><code>pub struct Arm {
    pub attrs: Vec&lt;Attribute&gt;,
    pub pats: Vec&lt;P&lt;Pat&gt;&gt;,
    pub guard: Option&lt;P&lt;Expr&gt;&gt;,
    pub body: P&lt;Expr&gt;,
}
</code></pre>

<h4>闭包</h4>

<p><code>Closure(CaptureBy, P&lt;FnDecl&gt;, P&lt;Block&gt;)</code></p>

<p>闭包，例如 <code>move |a, b, c| {a + b + c}</code>。</p>

<h2>相关 feature gate</h2>

<p><code>advanced_slice_patterns</code> - See the match expressions section for discussion; the exact semantics of slice patterns are subject to change, so some types are still unstable.</p>

<p><code>slice_patterns</code> - OK, actually, slice patterns are just scary and completely unstable.</p>

<p><code>box_patterns</code> - Allows box patterns, the exact semantics of which is subject to change.</p>

<h2>参考</h2>

<p><a href="https://doc.rust-lang.org/book/patterns.html">https://doc.rust-lang.org/book/patterns.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust Tips]]></title>
    <link href="http://andelf.github.io/blog/2014/05/15/rust-tips/"/>
    <updated>2014-05-15T11:08:59+08:00</updated>
    <id>http://andelf.github.io/blog/2014/05/15/rust-tips</id>
    <content type="html"><![CDATA[<h2>extern crate</h2>

<pre><code class="rust">extern crate sdl2 = "github.com/andelf/rust-sdl2";
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Rustdoc Plugin]]></title>
    <link href="http://andelf.github.io/blog/2014/04/29/a-rustdoc-plugin/"/>
    <updated>2014-04-29T02:26:48+08:00</updated>
    <id>http://andelf.github.io/blog/2014/04/29/a-rustdoc-plugin</id>
    <content type="html"><![CDATA[<p>Run with</p>

<pre><code>rustdoc -L. --plugin-path . --plugins dummy rust-sdl2/src/sdl2/lib.rs
</code></pre>

<pre><code class="rust">#![crate_id = "dummy#0.1"]
#![crate_type = "dylib"]


extern crate rustdoc;

use rustdoc::clean;

use rustdoc::plugins::{PluginCallback, PluginResult, PluginJson};

#[no_mangle]
pub fn rustdoc_plugin_entrypoint(c: clean::Crate) -&gt; PluginResult {
    println!("loading extension ok!");
    println!("crate =&gt; {}", c.name);
    (c, None)
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust Tokenizer]]></title>
    <link href="http://andelf.github.io/blog/2014/04/29/rust-tokenizer/"/>
    <updated>2014-04-29T01:06:38+08:00</updated>
    <id>http://andelf.github.io/blog/2014/04/29/rust-tokenizer</id>
    <content type="html"><![CDATA[<p>A rust tokenizer from rust standard library.</p>

<pre><code class="rust">extern crate syntax;

use syntax::parse;
use syntax::ast;

fn main() {
    let sess = parse::new_parse_sess();
    let cfg = Vec::new();
    let mut p = parse::new_parser_from_file(&amp;sess, cfg, &amp;Path::new("./mytest.rs"));
    while p.token != parse::token::EOF {
        p.bump();
        println!("debug =&gt; {}", parse::token::to_str(&amp;p.token));
    }
}
</code></pre>

<p>DONE!</p>

<p><code>p.parse_token_tree()</code> will return a <code>TokenTree</code>, which is a nested
token list.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust Syntax Extensions]]></title>
    <link href="http://andelf.github.io/blog/2014/04/23/rust-syntax-extensions/"/>
    <updated>2014-04-23T23:44:43+08:00</updated>
    <id>http://andelf.github.io/blog/2014/04/23/rust-syntax-extensions</id>
    <content type="html"><![CDATA[<p>All rust ASTs are in <code>syntax::ast</code>. And extensions are in
<code>syntax::ext</code>.</p>

<pre><code class="rust">#![feature(macro_registrar, managed_boxes)];

extern crate syntax;

use syntax::ast;
use syntax::ast::Name;
use syntax::ext::base::SyntaxExtension;

#[macro_registrar]
pub fn macro_registrar(register: |Name, SyntaxExtension|);
</code></pre>

<p>Managed boxes, the <code>@-pointer</code> is still used in rust compiler, so it
is essential to enable this feature.</p>

<p>where the doc says:</p>

<pre><code class="rust">/// A name is a part of an identifier, representing a string or
gensym. It's the result of interning.
/// created by token::intern()
type Name = u32;

/// An enum representing the different kinds of syntax extensions.
pub enum SyntaxExtension {
    /// A syntax extension that is attached to an item and creates new items
    /// based upon it.
    ///
    /// `#[deriving(...)]` is an `ItemDecorator`.
    ItemDecorator(ItemDecorator),

    /// A syntax extension that is attached to an item and modifies it
    /// in-place.
    ItemModifier(ItemModifier),

    /// A normal, function-like syntax extension.
    ///
    /// `bytes!` is a `NormalTT`.
    NormalTT(~MacroExpander:'static, Option&lt;Span&gt;),

    /// A function-like syntax extension that has an extra ident before
    /// the block.
    ///
    /// `macro_rules!` is an `IdentTT`.
    IdentTT(~IdentMacroExpander:'static, Option&lt;Span&gt;),
}

type ItemDecorator = fn(&amp;mut ExtCtxt, Span, @MetaItem, @Item, |@Item|);
type ItemModifier = fn(&amp;mut ExtCtxt, Span, @MetaItem, @Item) -&gt; @Item;

pub trait MacroExpander {
    fn expand(&amp;self, ecx: &amp;mut ExtCtxt, span: Span, token_tree: &amp;[TokenTree]) -&gt; ~MacResult;
}

pub trait IdentMacroExpander {
    fn expand(&amp;self, cx: &amp;mut ExtCtxt, sp: Span, ident: Ident, token_tree: Vec&lt;TokenTree&gt;) -&gt; ~MacResult;
}

/// The result of a macro expansion. The return values of the various
/// methods are spliced into the AST at the callsite of the macro (or
/// just into the compiler's internal macro table, for `make_def`).
pub trait MacResult {
    /// Define a new macro.
    fn make_def(&amp;self) -&gt; Option&lt;MacroDef&gt; {
        None
    }
    /// Create an expression.
    fn make_expr(&amp;self) -&gt; Option&lt;@ast::Expr&gt; {
        None
    }
    /// Create zero or more items.
    fn make_items(&amp;self) -&gt; Option&lt;SmallVector&lt;@ast::Item&gt;&gt; {
        None
    }

    /// Create a statement.
    ///
    /// By default this attempts to create an expression statement,
    /// returning None if that fails.
    fn make_stmt(&amp;self) -&gt; Option&lt;@ast::Stmt&gt; {
        self.make_expr()
            .map(|e| @codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))
    }
}
</code></pre>

<h2>How to call</h2>

<pre><code class="rust">use syntax::parse::token;

#[macro_registrar]
pub fn registrar(register: |Name, SyntaxExtension|) {
    register(token::intern("your_ext_name"), your_extension);
}
</code></pre>

<p>Note: <code>registrar</code> is not <code>register</code>.</p>

<p>How to create each part:</p>

<p><code>Name</code> is generated from
<code>syntax::parse::token::intern()</code>.</p>

<p>For different SyntaxExtension Enum, write the function, and wrap in Enum constructor.</p>

<h3>ItemDecorator</h3>

<p><code>src/libsyntax/ext/deriving/mod.rs</code>. The
<code>#[deriving(...)</code>.</p>

<p>To make items from an existing item.</p>

<h3>ItemModifier</h3>

<p><code>src/test/auxiliary/macro_crate_test.rs</code></p>

<p>Modify existing item.</p>

<h3>NormalTT</h3>

<p>Builtin sample in: <code>src/libsyntax/ext/base.rs</code> and sub dirs.
Normal <code>macro_name!(...)</code> call.</p>

<h3>IdentTT</h3>

<p>Builtin sample in: <code>src/libsyntax/ext/tt/macro_rules.rs</code>, <code>pub fn add_new_extension</code>.</p>

<pre><code>macro_name! ident(
    whatever here...
)
</code></pre>

<h2>Aux</h2>

<p>The <code>quote</code> feature.</p>

<pre><code>#![feature(quote, phase)]
</code></pre>

<p>This enables <code>quote_expr!(ExtCtxt, [Code])</code>, <code>quote_tokens!</code>,
<code>quote_item!</code>, <code>quote_pat!</code>, <code>quote_stmt!</code>, <code>quote_ty!</code> macros,
and generates corresponding ast type.</p>
]]></content>
  </entry>
  
</feed>
