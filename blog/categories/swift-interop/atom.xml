<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift-interop | 猫·仁波切]]></title>
  <link href="http://andelf.github.io/blog/categories/swift-interop/atom.xml" rel="self"/>
  <link href="http://andelf.github.io/"/>
  <updated>2016-03-23T00:26:03+08:00</updated>
  <id>http://andelf.github.io/</id>
  <author>
    <name><![CDATA[猫·仁波切 (Feather)]]></name>
    <email><![CDATA[andelf@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Interop With C/ObjC Part 3 (Swift 与 ObjC 和 C 的交互，第三部分）]]></title>
    <link href="http://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc/"/>
    <updated>2014-06-28T21:58:35+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc</id>
    <content type="html"><![CDATA[<p>声明： 转载请注明，方便的情况下请知会本人. <a href="http://weibo.com/234632333">weibo</a></p>

<p>之前说那是最后一篇。可惜越来越发现有很多东西还没介绍到。事不过三。再坑一篇。</p>

<h2>前言</h2>

<p>本文解决如下问题</p>

<ul>
<li>ObjC/C 中定义的某个类型、结构体，通过 Bridge Header 或者 Module 对应到 Swift 到底是什么类型</li>
<li>指针间的转换问题</li>
</ul>


<p>补充之前没解决的一些问题，比如提到 <code>CMutablePointer</code> 的 <code>sizeof</code> 是两个字长，那么在函数调用中是如何对应到 C 的指针的？</p>

<p>预备内容：</p>

<ul>
<li><a href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/">Swift 与 Objective-C 之间的交互</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">简析Swift和C的交互</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">简析 Swift 和 C 的交互，Part 二</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">Swift 的隐式类型转换</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/06/swift-attributes/">Swift Attributes</a></li>
</ul>


<h2>C/ObjC to Swift 对应规则</h2>

<p>以下内容均适合 Objective-C 。第一部分适合 C 。</p>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。</p>

<h3>for C</h3>

<h4>可导出的类型定义</h4>

<p>函数、枚举、结构体、常量定义、宏定义。</p>

<p>结构体定义支持：</p>

<pre><code class="c">typedef struct Name {...} Name;
typedef struct Name_t {...} Name;
struct Name { ... };
</code></pre>

<p>其中无法处理的结构体、函数类型、 varargs 定义不导出。预计以后版本会修复。带 bit field 的结构体也无法识别。</p>

<h4>类型对应关系</h4>

<p>仔细分析发现，诡异情况还很多。基础类型请参考上几篇。</p>

<p>在函数定义参数中：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">类型 </th>
<th style="text-align:center;"> 对应为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"><code>void *</code> </td>
<td style="text-align:center;"> <code>CMutableVoidPointer</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>Type *</code>、<code>Type[]</code> </td>
<td style="text-align:center;"> <code>CMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>const char *</code> </td>
<td style="text-align:center;"> <code>CString</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>const Type *</code> </td>
<td style="text-align:center;"> <code>CConstPointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>const void *</code> </td>
<td style="text-align:center;"> <code>CConstVoidPointer</code></td>
</tr>
</tbody>
</table>


<p>在函数返回、结构体字段中：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">类型 </th>
<th style="text-align:center;"> 对应为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"><code>const char *</code> </td>
<td style="text-align:center;"> <code>CString</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>Type *</code>、<code>const Type *</code> </td>
<td style="text-align:center;"> <code>UnsafePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center;"><code>void *</code>、<code>const void *</code> </td>
<td style="text-align:center;"> <code>COpaquePointer</code></td>
</tr>
<tr>
<td style="text-align:center;">无法识别的结构指针  </td>
<td style="text-align:center;"> <code>COpaquePointer</code></td>
</tr>
</tbody>
</table>


<p>另外还有如下情况：</p>

<p>全局变量、全局常量(<code>const</code>)、宏定义常量(<code>#define</code>) 均使用 <code>var</code>，常量不带 <code>set</code>。</p>

<p>结构体中的数组，对应为元祖，例如 <code>int data[2]</code> 对应为 <code>(CInt, CInt)</code>，所以也许。。会很长。数组有多少元素就是几元祖。</p>

<h3>for ObjC</h3>

<p>ObjC 明显情况要好的多，官方文档也很详细。</p>

<p>除了 <code>NSError **</code> 转为 <code>NSErrorPointer</code> 外，需要注意的就是：</p>

<p>函数参数、返回中的 <code>NSString *</code> 被替换为 <code>String!</code>、<code>NSArray *</code> 被替换为 <code>AnyObject[]!</code>。</p>

<p>而全局变量、常量的 <code>NSString *</code> 不变。</p>

<h2>关于 <code>CMutablePointer</code> 的行为</h2>

<p>上回说到 <code>CMutablePointer</code>、<code>CConstPointer</code>、<code>CMutableVoidPointer</code>、<code>CConstVoidPointer</code>
四个指针类型的字长是 2，也就是说，不可以直接对应为 C 中的指针。但是前面说类型对应关系的时候， C 函数声明转为 Swift
时候又用到了这些类型，所以看起来自相矛盾。仔细分析了 lldb 反汇编代码后发现，有如下隐藏行为:</p>

<h3>in Swift</h3>

<p>在纯 Swift 环境下，函数定义等等、这些类型字长都为 2，不会有任何意外情况出现。</p>

<h3>in C/ObjC</h3>

<p>当一个函数的声明是由 Bridge Header 或者 LLVM Module 隐式转换而来，且用到了这四个指针类型，那么代码编译过程中类型转换规则、隐式转换调用等规则依然有效。只不过在代码最生成一步，会插入以下私有函数调用之一：</p>

<pre><code class="scala">@transparent func _convertCMutablePointerToUnsafePointer&lt;T&gt;(p: CMutablePointer&lt;T&gt;) -&gt; UnsafePointer&lt;T&gt;
@transparent func _convertCConstPointerToUnsafePointer&lt;T&gt;(p: CConstPointer&lt;T&gt;) -&gt; UnsafePointer&lt;T&gt;
@transparent func _convertCMutableVoidPointerToCOpaquePointer(p: CMutableVoidPointer) -&gt; COpaquePointer
@transparent func _convertCConstVoidPointerToCOpaquePointer(p: CConstVoidPointer) -&gt; COpaquePointer
</code></pre>

<p>这个过程是背后隐藏的。然后将转换的结果传参给对应的 C/ObjC 函数。实现了指针类型字长正确、一致。</p>

<h3>结论</h3>

<p>作为程序员，需要保证调用 C 函数的时候类型一致。如果有特殊需求重新声明了对应的 C 函数，那么以上规则不起作用，所以重声明 C 中的函数时表示指针不可以使用这四个指针类型。</p>

<h2>再说指针</h2>

<p><img class="left" src="/images/attachments/swift-pointers.png" title="&lsquo;Swift Pointers&rsquo;" ></p>

<p>虚线表示直接隐式类型转换。其中 <code>UnsafePointer&lt;T&gt;</code> 可以通过用其他任何指针调用构造函数获得。</p>

<p><code>CMutablePointer&lt;T&gt;</code> 和 <code>CMutableVoidPointer</code> 也可以通过 <code>Array&lt;T&gt;</code> 的引用隐式类型转换获得 （ <code>&amp;arr</code> ）。</p>

<p>椭圆表示类型 <code>sizeof</code> 为字长，可以用于声明 C 函数。</p>

<p>四大指针可以用 <code>withUnsafePointer</code> 操作。转换为 <code>UnsafePointer&lt;T&gt;</code>。上一节提到的私有转换函数请不要使用。</p>

<h2>字符串</h2>

<p>之前的文章已经介绍过怎么从 <code>CString</code> 获取 <code>String</code> （静态方法 <code>String.fromCString</code>）。</p>

<p>从 <code>String</code> 获取 <code>CString</code> 也说过， 是用 <code>withCString</code>。</p>

<p>也可以从 <code>CString(UnsafePointer.alloc(100))</code> 来分配空数组。</p>

<h2>参考</h2>

<ul>
<li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift and C Interop Cont. (简析 Swift 和 C 的交互，Part 二)]]></title>
    <link href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/"/>
    <updated>2014-06-18T23:38:01+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont</id>
    <content type="html"><![CDATA[<p>声明： 转载注明我或者 SwiftChina . <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文的发现基于个人研究，目测是官方外的首创。请尊重原创。</p>

<p>本文是讲述 Swift 与 C 交互操作系列文章的第二部分。解决之前的所有遗留问题。</p>

<p>第一部分请参考 <a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">Swift and C Interop 简析Swift和C的交互</a></p>

<p>本文将介绍实际应用过程中会遇到的各类情况。</p>

<h2>再看类型对应</h2>

<p>标准类型这里就不提了，上面的文章讲的很明白了。</p>

<h3>7 种指针类型</h3>

<p>从代码看，我认为 Swift 对应 C 的指针时候，存在一个最原始的类型 <code>RawPointer</code>，但是它是内部表示，不可以直接使用。所以略过。但它是基础，可以认为它相当于 <code>Word</code> 类型（机器字长）。</p>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。</p>

<h4>COpaquePointer</h4>

<p>不透明指针。之前我以为它很少会用到，不过现在看来想错了，虽然类型不安全，但是很多场合只能用它。它是直接对应 <code>RawPointer</code> 的。字长相等。</p>

<blockquote><p>In computer programming, an opaque pointer is a special case of an opaque data type, a datatype declared to be a pointer to a record or data structure of some unspecified type. - 来自 Wikipedia</p></blockquote>

<p>几乎没有任何操作方法，不带类型，主要用于 Bridging Header 中表示 C 中的复杂结构指针</p>

<p>比如一个例子， libcurl 中的 <code>CURL *</code> 的处理，其实就是对应为 <code>COpaquePointer</code>。</p>

<h4>UnsafePointer<T></h4>

<p>泛型指针。直接对应 <code>RawPointer</code>。字长相等。</p>

<p>处理指针的主力类型。常量中的 <code>C_ARGV</code> 的类型也是它 <code>UnsafePointer&lt;CString&gt;</code>。</p>

<p>支持大量操作方法：</p>

<ul>
<li>通过 <code>.memory</code> 属性 <code>{ get set }</code> 操作指针指向的内容</li>
<li>支持 subscript ，直接对应于 C 的数组，例如 <code>C_ARGV[1]</code></li>
<li>通过 <code>alloc(num: Int)</code> 分配数组空间</li>
<li><code>initialize(val: T)</code> 直接初始化</li>
<li>offset 操作 <code>.succ()</code> <code>.pred()</code></li>
<li>可以从任意一种指针直接调用构造函数获得</li>
<li>隐式类型转换为非 <code>COpaquePointer</code> 之外的任意一种指针</li>
</ul>


<h4>AutoreleasingUnsafePointer<T></h4>

<p>之前特地写文介绍过这个指针类型。<code>NSError</code> 的处理就主要用它。传送门： <a href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a></p>

<p>内部实现用了语言内置特性，从名字也可以看出来，这个应该是非常棒的一个指针，可以帮助管理内存，逼格也高。内存直接对应 <code>RawPointer</code> 可以传递给 C 函数。</p>

<ul>
<li>通过 <code>.memory</code> 属性 <code>{ get set }</code> 操作指针指向的内容</li>
<li>直接从 <code>&amp;T</code> 类型获得，使用方法比较诡异，建议参考文章</li>
</ul>


<h4>CMutablePointer<T> CConstPointer<T></h4>

<p>分别对应于 C 中的 <code>T *</code>、<code>const T *</code>。不可直接传递给 C 函数，因为表示结构里还有一个 <code>owner</code> 域，应该是用来自动管理生命周期的。<code>sizeof</code> 操作返回 16。但是可以有隐式类型转换。</p>

<p>操作方法主要是 <code>func withUnsafePointer&lt;U&gt;(f: UnsafePointer&lt;T&gt; -&gt; U) -&gt; U</code>，用 Trailing Closure 语法非常方便。</p>

<h4>CMutableVoidPointer CConstVoidPointer</h4>

<p>分别对应于 C 中的 <code>void *</code>、<code>const void *</code>。其他内容同上一种。</p>

<h4>小结指针</h4>

<p>以上 7 种指针类型可以分未两类，我给他们起名为 第一类指针 和 第二类指针 。（你看我在黑马克思耶，算了这个梗太深，参考马克思主义政治经济学）</p>

<ul>
<li>可以直接用于 C 函数声明的 第一类指针

<ul>
<li><code>COpaquePointer</code> <code>UnsafePointer&lt;T&gt;</code> <code>AutoreleasingUnsafePointer&lt;T&gt;</code></li>
<li>是对 <code>RawPointer</code> 的封装，直接对应于 C 的指针，它们的 <code>sizeof</code> 都是单位字长</li>
</ul>
</li>
<li>不可用于声明 第二类指针

<ul>
<li><code>CMutablePointer&lt;T&gt; CConstPointer&lt;T&gt; CMutableVoidPointer CConstVoidPointer</code></li>
<li>直接从 Swift 对象的引用获得（一个隐藏特性，引用隐式转换）（主要构造方法）</li>
<li>包含了一个 <code>owner</code> 字段，可以管理生命周期，理论上在 Swift 中使用</li>
<li>通过 <code>.withUnsafePointer</code> 方法调用</li>
</ul>
</li>
</ul>


<p>所有指针都实现了 <code>LogicValue</code> 协议，可以直接 <code>if a_pointer</code> 判断是否为 <code>NULL</code>。</p>

<p><code>nil</code> 类型实现了到所有指针类型的隐式类型转换，等价于 C 中的 <code>`NULL</code>，可以直接判断。</p>

<p>什么时候用什么？这个问题我也在考虑中，以下是我的建议。</p>

<ul>
<li>对应复杂结构体，不操作结构体字段的： <code>COpaquePointer</code> 例如 <code>CURL *</code></li>
<li>日常操作： <code>UnsafePointer&lt;T&gt;</code></li>
<li>同时需要在 Swift 和 C 中操作结构体字段，由 Swift 管理内存：<code>AutoreleasingUnsafePointer&lt;T&gt;</code></li>
<li>Swift 中创建对象，传递给 C： 第二类指针</li>
</ul>


<h2>工具类型</h2>

<h3>CVarArg CVaListPointer VaListBuilder</h3>

<p>用于处理 C 语言中的可变参数 valist 函数。</p>

<pre><code class="scala">protocol CVarArg {
  func encode() -&gt; Word[]
}
</code></pre>

<p>表示该类型可以作为可变参数，相当多的类型都实现了这个。</p>

<pre><code class="scala">struct CVaListPointer {
    var value: UnsafePointer&lt;Void&gt;
    init(fromUnsafePointer from: UnsafePointer&lt;Void&gt;)
    @conversion func __conversion() -&gt; CMutableVoidPointer
}
</code></pre>

<p>对应于 C，直接给 C 函数传递，声明、定义时使用。</p>

<pre><code class="scala">class VaListBuilder {
    init()
    func append(arg: CVarArg)
    func va_list() -&gt; CVaListPointer
}
</code></pre>

<p>工具类，方便地创建 <code>CVaListPointer</code>。</p>

<p>还有一些工具函数：</p>

<pre><code class="scala">func getVaList(args: CVarArg[]) -&gt; CVaListPointer
func withVaList&lt;R&gt;(args: CVarArg[], f: (CVaListPointer) -&gt; R) -&gt; R
func withVaList&lt;R&gt;(builder: VaListBuilder, f: (CVaListPointer) -&gt; R) -&gt; R
</code></pre>

<p>非常方便。</p>

<h3>UnsafeArray<T></h3>

<pre><code class="scala">struct UnsafeArray&lt;T&gt; : Collection, Generator {
  var startIndex: Int { get }
  var endIndex: Int { get }
  subscript (i: Int) -&gt; T { get }
  init(start: UnsafePointer&lt;T&gt;, length: Int)
  func next() -&gt; T?
  func generate() -&gt; UnsafeArray&lt;T&gt;
}
</code></pre>

<p>处理 C 数组的工具类型，可以直接 for-in 处理。当然，只读的，略可惜。</p>

<h3>Unmanaged<T></h3>

<pre><code class="scala">struct Unmanaged&lt;T&gt; {
  var _value: T
  init(_private: T)
  func fromOpaque(value: COpaquePointer) -&gt; Unmanaged&lt;T&gt;
  func toOpaque() -&gt; COpaquePointer
  static func passRetained(value: T) -&gt; Unmanaged&lt;T&gt;
  static func passUnretained(value: T) -&gt; Unmanaged&lt;T&gt;
  func takeUnretainedValue() -&gt; T
  func takeRetainedValue() -&gt; T
  func retain() -&gt; Unmanaged&lt;T&gt;
  func release()
  func autorelease() -&gt; Unmanaged&lt;T&gt;
}
</code></pre>

<p>顾名思义，手动管理 RC 的。避免 Swift 插入的 ARC 代码影响程序逻辑。</p>

<h2>C 头文件的导入行为</h2>

<h3>宏定义</h3>

<p>数字常量 CInt, CDouble (带类型后缀则为对应类型，如 1.0f ）
字符常量 CString
其他宏 展开后，无定义</p>

<h3>枚举 enum</h3>

<p>创建 enum 类型，并继承自 <code>CUnsignedInt</code> 或 <code>CInt</code> （enum 是否有负初始值）</p>

<p>可以通过 <code>.value</code> 访问。</p>

<h3>结构体 struct</h3>

<p>创建 struct 类型，只有默认 init ，需要加上所有结构体字段名创建。</p>

<h3>可变参数函数</h3>

<p>转为 <code>CVaListPointer</code>。手动重声明更好。这里举 <code>Darwin</code> 模块的例子说。</p>

<pre><code>func vprintf(_: CString, _: CVaListPointer) -&gt; CInt
</code></pre>

<h2>从 C 调用 Swift</h2>

<p>只能调用函数。</p>

<p>之前说过，用 <code>@asmname("name")</code> 指定 mangled name 即可。</p>

<p>然后 C 语言中人工声明下函数。很可惜自动导出头文件不适用于 C 语言，只适用于 Objective-C 。</p>

<p>目测暂时无法导出结构体，因为 Swift 闭源不提供相关头文件。靠猜有风险。</p>

<p>全局变量不支持用 <code>@asmname("name")</code> 控制导出符号名。目测可以尝试用 mangled name 访问，但是很不方便。</p>

<h2>示例</h2>

<p>我尝试调用了下 libcurl 。</p>

<p>项目地址在 <a href="https://github.com/andelf/curl-swift">andelf/curl-swift</a> 包含编译脚本（就一句命令）。</p>

<p>Bridging Header 只写入 <code>#include&lt;curl/curl.h&gt;</code> 即可。</p>

<pre><code class="scala">@asmname("curl_easy_setopt") func curl_easy_setopt(curl: COpaquePointer, option: CURLoption, param: CString) -&gt; CURLcode
@asmname("curl_easy_setopt") func curl_easy_setopt(curl: COpaquePointer, option: CURLoption, param: CBool) -&gt; CURLcode

let handle = curl_easy_init()

// this should be a const c string. curl_easy_perform() will use this.
let url: CString = "http://www.baidu.com"

curl_easy_setopt(handle, CURLOPT_URL, url)
curl_easy_setopt(handle, CURLOPT_VERBOSE, true)

let ret = curl_easy_perform(handle)
let error = curl_easy_strerror(ret)
println("error = \(error)")
</code></pre>

<p>值得注意的是其中对单个函数的多态声明， <code>curl_easy_setopt</code> 实际上第三个参数是 <code>void *</code>。</p>

<p>以及对 <code>url</code> 的处理，实际上 libcurl 要求设置的 url 参数一直保持到 <code>curl_easy_perform</code> 时，所以这里用 <code>withUnsafePointer</code> 或者
<code>withCString</code> 是不太可取的方法。实际上或许可以用 <code>Unmanaged&lt;T&gt;</code> 来解决。</p>

<h2>总结</h2>

<p>我觉得说这么多。。。</p>

<p>调用 C 已经再没有别的内容可说了。其他的就是编程经验的问题，比如如何实现 C 回调 Swift 或者 Swift 回调 C 。可以参考其他语言的做法。解决方法不只一种。</p>

<h2>参考文献</h2>

<ul>
<li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a>。</li>
<li><a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">Swift and C Interop 简析Swift和C的交互 第一部分</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift and C Interop(简析Swift和C的交互)]]></title>
    <link href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/"/>
    <updated>2014-06-15T00:11:44+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/15/swift-and-c-interop</id>
    <content type="html"><![CDATA[<p>声明： 转载注明我或者 SwiftChina . <a href="http://weibo.com/234632333">weibo</a></p>

<p>其中 <code>@asmname</code> 的两个用法源于我的猜测验证，用到了 Xcode, lldb, nm, llvm ir 等工具或格式。</p>

<p>其中 name mangling 部分源自 WWDC。</p>

<p>相关的分析主要基于我 dump 出的 Swift 标准库声明代码，位于 <a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a>。</p>

<p>目前有两个小部分还未完成。</p>

<p>之前好像简单说过 Swift 和 Objective-C 的交互问题。其实我们也可以用 Swift 调用纯 C 代码或者基于 C 的第三方库。（这里不会也永远不会考虑 C++ 的情况，因为不支持，不过可以用 C 写 wrapper, 这个没有任何问题。）</p>

<p>Swift 官方文档中，以及那本已经被迅速翻译为中文的 ibooks 书中，都提到了 Swift 调用 Objective-C 和 C 是有很好支持的。不过没有细节。</p>

<p><del>这里不会考虑如何用 C 调用 Swift, 暂时，看心情。：）</del> 本内容包括 Swift 调用 C 和相应的 C 调用 Swift，项目混编。</p>

<p>这里主要面向 MacOSX 应用。iOS 或许可以适用。</p>

<p>先复习下区别。</p>

<h2>第一部分 预备知识</h2>

<h3>语言区别</h3>

<p>说到底就是 C 少了很多东西。但是多了个指针。</p>

<p>对于 C 来说，最头疼的莫过于指针，而 Swift 是一门没有指针的语言。是不是要吐血？相对来说指针不但代表者指针操作传参，还有指针运算等等。</p>

<h2>第二部分 调用 C</h2>

<p>这里主要讨论函数的调用。对于结构、枚举、类的兼容性暂时没尝试。</p>

<h3>C 标准库</h3>

<p>好消息是，对于标准库中的 C 函数，根本不需要考虑太多导入头文件神马的。比如 <code>strlen</code>、<code>putchar</code>、<code>vprintf</code>。当然 <code>vprintf</code> 需要多说几句，后面说。</p>

<p>请直接 <code>import Darwin</code> 模块。</p>

<p>这些标准库函数表示为 <code>Darwin.C.HEADER.name</code>。</p>

<p>实际上由于 Swift 模块结构是平坦的，他们均位于 <code>Darwin</code> 中，所以基本上是直接用的。</p>

<p>然后 <code>CoreFoundation</code> 用到了 <code>Darwin</code> ( @exported 导入，所以相当于这些名字也在 <code>CoreFoundation</code> 中)。</p>

<p>然后 <code>Foundation</code> 用到了 <code>CoreFoundation</code> （也是 @exported 导入。）</p>

<p>所以其实你导入 <code>Foundation</code> 的时候，这些 C 函数都是直接可用的。比如 <code>putchar</code> 一类。</p>

<p>多说一句，<code>Cocoa</code> 当然也包含 <code>Foundation</code>。</p>

<h3>C 函数</h3>

<p>好吧假设你有个牛逼到顶天的算法是 C 写的，不对，假设是别人写的，牛逼到你只能凑合用却看不懂然后自己也写不出没空迁移的地步。</p>

<p>我们直接创建一个 Swift 项目，然后 New File，添加一个 <code>.c</code> 文件。</p>

<p>这时候 Xcode 会弹出对话框询问是否配置 Bridge Header，确认就可以了。也可以手动添加 Bridge Header，位置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。指向你的 Bridge Header 文件名就可以了。</p>

<p>一般这个文件是 <code>ProjectName-Bridging-Header.h</code>。情况基本和与 Objective-C 混编没区别。</p>

<p>剩下的工作就很简单了。在 <code>.c</code> 文件填上传说中的牛逼算法。在 <code>ProjectName-Bridging-Header.h</code> 中加上该函数原型或者引入相关的头文件。</p>

<p>在 Swift 中调用的名字和 C 名字一样就可以了，比如你定义了一个 <code>int mycsort()</code> 那么在 Swift 中就是 <code>func mycsort() -&gt; CInt</code>。</p>

<p>这时候问题来了。一个漂亮的问题。</p>

<p>我的 C 函数名字和 Swift 标准库冲突怎么办？比如我定义了一个函数就叫 <code>println</code>，我们知道 Swift 里也有个 <code>println</code>。</p>

<p>这样，如果直接调用会提示 <code>Ambiguous use of 'println'</code>。没辙了么？</p>

<p>这里有个我发现的 Undocumented Featuer 或者说是 Undocumented Attribute。你转载好歹提下我好吧。（发现方法是通过 Xcode 查看定义，然后通过 nm 命令发现符号, 对照 llvm ir 确认的。)</p>

<p>那就是 <code>@asmname("func_name_in_c")</code>。用于函数声明前。使用方法：</p>

<pre><code class="c">int println() { .... }
</code></pre>

<pre><code>@asmname("println") func c_println() -&gt; CInt // 声明，不需要 {} 函数体
c_println() // 调用
</code></pre>

<p>也就是 C 中的同名函数，我们可以给赋予一个别名，然后正常调用。这么一看就基本没有问题了。至于类型问题，待会说，详细说。</p>

<h3>C Framework</h3>

<p>很多时候我们拿到的是第三方库，格式大概是个 Framework。比如 <code>SDL2.framework</code>。举这个例子是因为我想对来说比较熟悉 SDL2。</p>

<p>直接用 Finder 找到这个 <code>.framework</code> 文件，拖动到当前项目的文件列表里，这样它将作为一个可以展开的文件夹样式存在于我们的项目中。</p>

<p>在 <code>ProjectName-Bridging-Header.h</code> 中引入其中需要的 <code>.h</code>。</p>

<p>比如我们引入 <code>SDL2.framework</code>，那么我们就需要写上 <code>#import &lt;SDL2/SDL.h&gt;</code>。</p>

<p>然后在 Swift 文件里正常调用就好了。</p>

<p>所以其实说到底核心就是那个 <code>ProjectName-Bridging-Header.h</code>，因为它是作为参数传递给 Swift 编译器的，所以 Swit 文件里可以从它找到定义的符号。</p>

<p>但是，这个桥接头文件的一切都是隐式的，类型自动对应，所以很多时候需要我们在 Swift 里调用并封装。或者使用 <code>@asmname(...)</code> 避免名字冲突。</p>

<h2>第三部分 类型转换</h2>

<p>前面说到了 C 中有指针，而 Swift 中没有，同时基本类型还有很多不同。所以混编难免需要在两种语言的不同类型之间进行转换。</p>

<p>牢记一个万能函数 <code>reinterpretCast&lt;T, U&gt;(T) -&gt; U</code>，只要 T, U sizeof 运算相等就可以直接转换。这个在之前的标准库函数里有提到。调用 C 代码的利器！</p>

<h3>基本类型对应</h3>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。简言之，不在对应为 C 别名类型，而是直接对应到 Siwft 类型。而指针类型简化为 <code>UnsafePointer&lt;T&gt;</code> 和 <code>ConstUnsafePointer&lt;T&gt;</code> 两种， <code>COpaquePointer</code> 依然存在。另新增了 <code>CFunctionPointer&lt;T&gt;</code>。</p>

<ul>
<li>int => CInt</li>
<li>char => CChar / CSignedChar</li>
<li>char* => CString</li>
<li>unsigned long = > CUnsignedLong</li>
<li>wchar_t => CWideChar</li>
<li>double => CDouble</li>
<li>T* => CMutablePointer<T></li>
<li>void* => CMutableVoidPointer</li>
<li>const T* => CConstPointer<T></li>
<li>const void* => CConstVoidPointer</li>
<li>&hellip;</li>
</ul>


<p>继续这个列表，你肯定会想这么多数值类型，怎么搞。其实大都是被 <code>typealias</code> 定义到 <code>UInt8</code>，<code>Double</code> 这些的。放心。C 中数值类型全部被明确地用别名定义到带 size 的 Swift 数值类型上。完全是一样用的。</p>

<p>其实真正的 Pointer 类型只是 <code>UnsafePointer&lt;T&gt;</code>，大小与 C 保证一致，而对于这里不同类型的 Pointer，其实都是 <code>UnsafePointer</code>
到它们的隐式类型转换。<del>还有个指针相关类型是 <code>COpaquePointer</code>，不过没试验怎么用</del>。</p>

<p>UPDATE: 我们在调用的时候，更多地用到 <code>COpaquePointer</code>，我将再坑一篇介绍它。</p>

<p>同时 <code>NilType</code>，也就是 <code>nil</code> 有到这些指针的隐式类型转换。所以可以当做任何一种指针的 <code>NULL</code> 用。</p>

<p>还有个需要提到的类型是 CString, 他的内存 layout 等于 <code>UnsafePointer&lt;UInt8&gt;</code>，下面说。</p>

<h3>CString</h3>

<p>用于表示 <code>char *</code>，<code>\0</code> 结尾的 c 字符串，实际上似乎还看到了判断是否 ASCII 的选项，但是没试出来用法。</p>

<p>实现了 <code>StringLiteralConvertible</code> 和 <code>LogicValue</code>。可以从字符串常量直接赋值获得 <code>CString</code>。<code>LogicValue</code> 也就是是 <code>if a_c_str {}</code>，实际是用于判断是否为 <code>NULL</code>，可用，但是不稳定，老 crash。</p>

<p>运算符支持 <code>==</code>，判断两字符串是否相当，猜测实际是 <code>strcmp</code> 实现，对比 NULL 会 crash。Orz。</p>

<p>CString 和 String 的转换通过一个 extension 实现，也是很方便。</p>

<pre><code class="scala">extension String {
  static func fromCString(cs: CString) -&gt; String
  static func fromCString(up: UnsafePointer&lt;CChar&gt;) -&gt; String
}
// 还有两个方便的工具方法。 Rust 背景的同学一定仰天长啸。太相似了。
extension String {
  func withCString&lt;Result&gt;(f: (CString) -&gt; Result) -&gt; Result
  func withCString&lt;Result&gt;(f: (UnsafePointer&lt;CChar&gt;) -&gt; Result) -&gt; Result
}
</code></pre>

<p>在我们的 Bridging Header 头文件中 <code>char *</code> 的类型会对应为 <code>UnsafePointer&lt;CChar&gt;</code>，而实际上 <code>CString</code> 更适合。所以在 Swift 代码中，往往我们要再次申明下这个函数。或者用一个函数封装下，转换成我们需要的类型。</p>

<p>例如，假设在 Bridging Header 中我们声明了 <code>char * foo();</code>，那么，在 Swift 代码中我们可以用上面提到的方法：</p>

<pre><code>@asmname("foo") func c_foo() -&gt; CString
// 注意这里没有 {}，只是声明
let ret = c_foo()
</code></pre>

<p>当然也可以直接调用原始函数然后类型转换：</p>

<pre><code class="scala">let raw = foo() // UnsafePointer&lt;Int8&gt; &lt;=&gt; UnsafePointer&lt;CChar&gt;
let ret = String.fromCString(ret)
</code></pre>

<p>如果这里要转成 CString 就略复杂了，因为 CString 构造函数接受的参数是 <code>UnsafePointer&lt;UInt8&gt;</code>， 而 <code>CChar</code> 是 <code>Int8</code> 的别名，所以还牵扯到 Genrics 类型转换，不够方便。</p>

<p>如果非要作为 CString 处理，可以用 <code>reinterpretCast()</code>，直接转换。但是请一定要知道自己在转换什么，确保类型的 sizeof 相同，确保转换本身有意义。</p>

<p>例如获得环境变量字符串：</p>

<pre><code>let key = "PATH"
// 这里相当于把 UnsafePointer&lt;CChar&gt; 转为了 UnsafePointer&lt;UInt8&gt; 然后到 CString
let path_str: CString = reinterpretCast(key.withCString(getenv))
</code></pre>

<h3>Unmanaged</h3>

<p>这个先挖坑，随后填上。</p>

<h3>VaList</h3>

<p>这个也是坑，随后填上。</p>

<h2>第三部分 C 调用 Swift</h2>

<p>如果项目里加入了 C 文件，那么它可以调用我们的 Swift 函数么？答案是可以的，而且令人吃惊地透明。这也许是因为 Apple 所宣传的，Small Runtime 概念吧。极小的语言运行时。</p>

<p>和 Objective-C 混编类似，配置好 Bridging Header 的项目，在 .c .h .m 文件中都可以使用一个叫做 <code>ProjectName-Swift.h</code> 的头文件，其中包含 Swift 代码导出的函数等。</p>

<p>参考之前的 Objective-C 和 C 交互我们可以知道，说到底交互就是链接过程，只要链接的时候能找到符号就可以。</p>

<p>不过不能高兴太早，Swift 是带类、枚举、协议、多态、泛型等的高级语言，符号处理明显要比 C 中的复杂的多，现代语言一般靠 name mangle 来解决这个问题。也就是说一个 Swift 函数，在编译到 .o 的时候，名字就不是原来那么简单了。比如 <code>__TFV5hello4Rectg9subscriptFOS_9DirectionSi</code> 这样的名字。</p>

<p>Xcode 自带了个工具， 可以查看这些 mangled name 到底是什么东西：</p>

<pre><code>xcrun swift-demangle __TFV5hello4Rectg9subscriptFOS_9DirectionSi
_TFV5hello4Rectg9subscriptFOS_9DirectionSi ---&gt; hello.Rect.subscript.getter (hello.Direction) -&gt; Swift.Int
</code></pre>

<p>当我们从 C 调用的时候，应该规避这样的名字。还记得前面的 <code>@asmname</code> 么？没错，它可以用于指定 Swift 函数的符号名，我猜测应该有指定 mangled name 的作用，但是不是特别确定。</p>

<p>这里随便指定个例子先。</p>

<pre><code class="scala">@asmname("say_hello") func say_hello() -&gt; Double {
    println("This is say_hello() in swift")
    return 3.14
}
</code></pre>

<p>然后在 .c 文件中：</p>

<pre><code class="scala">#include &lt;ProjectName-Swift.h&gt;

extern double say_hello();

int some_func() {
  say_hello(); // or capture its value and process it
  return 0
}
</code></pre>

<p><del>当然这里的 extern 一行是可选的，因为实际上声明会存在于 ProjectName-Swift.h 中，只是为了避免首次编译警告而已（第二次以后的编译，其实这个 Header 已经被缓存起来了，这个牵扯到 Xcode 的编译过程）。</del> 错了。</p>

<p>对于函数而言 extern 必须手动加上，对于 class  、 protocol ，会在生成的头文件里。</p>

<p>按照这个思路，其实很容易实现 Swift 调用 C 中调用了 Swift 函数的函数。这意味着，可以通过简单的方法封装支持向 C 传递 Swift block 作为回调函数。难度中上，对于有过类似扩展编写经验的人来说很简单。</p>

<h2>第四部分 编译过程</h2>

<p>其实调用基本就这么多， Objective-C 那篇文章中说的编译过程同样有效。我 C-c C-v 下：</p>

<ul>
<li>编译所有 <code>X.swift</code> 文件到 <code>X.o</code> (with <code>-emit-objc-header</code>, <code>-import-objc-header</code>) (其中包含 <code>.swiftmodule</code> 子过程)

<ul>
<li>由于选项里有 <code>-emit-objc-header</code>，所以之后的 C 文件可以直接 import 对应的 <code>ProjectName-Swift.h</code></li>
</ul>
</li>
<li>编译 <code>X.c</code> 到 <code>X.o</code></li>
<li>链接所有 <code>.o</code> 生成可执行文件</li>
</ul>


<p>仔细理解上面的简简单单四行编译过程说明，你就明白为什么 .swfit 和 .c 可以互相调用了。其中两个 Header 文件起到了媒介的作用，一个将 .c/.m 文件中的定义暴露给 Swift，另一个将 .swift 中的定义暴露给 .c/.m 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift and ObjectiveC Interop Cont. (Swift 与 Objective-C 之间的交互，续坑)]]></title>
    <link href="http://andelf.github.io/blog/2014/06/12/swift-and-objectivec-interop-cont/"/>
    <updated>2014-06-12T17:10:28+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/12/swift-and-objectivec-interop-cont</id>
    <content type="html"><![CDATA[<h2>关于 <code>_ConditionallyBridgedToObjectiveC</code></h2>

<p>When you bridge from a Swift array to an NSArray object, the elements in the Swift array must be AnyObject compatible. For example, a Swift array of type Int[] contains Int structure elements. The Int type is not an instance of a class, but because the Int type bridges to the NSNumber class, the Int type is AnyObject compatible. Therefore, you can bridge a Swift array of type Int[] to an NSArray object. If an element in a Swift array is not AnyObject compatible, a runtime error occurs when you bridge to an NSArray object.</p>

<h2>其他 Tips</h2>

<p>When you declare an outlet in Swift, the compiler automatically converts the type to a weak implicitly unwrapped optional and assigns it an initial value of nil. In effect, the compiler replaces @IBOutlet var name: Type with @IBOutlet weak var name: Type! = nil.</p>

<p>In Swift, there are no readwrite and readonly attributes. When declaring a stored property, use let to make it read-only, and use var to make it read/write. When declaring a computed property, provide a getter only to make it read-only and provide both a getter and setter to make it read/write.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)]]></title>
    <link href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/"/>
    <updated>2014-06-11T20:01:11+08:00</updated>
    <id>http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop</id>
    <content type="html"><![CDATA[<p>主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。</p>

<p>瞎写的，有错或者不明白的地方直接告诉我。转载注明我或者 SwiftChina 。</p>

<p>参考资料是 我的 Github : <a href="https://github.com/andelf/Defines-Swift">andelf/Defines-Swift</a> 是我dump出的定义。10w行swift代码。</p>

<h1>预备知识</h1>

<h2>Objective-C (Cocoa) 特色</h2>

<p>数值类型统一用 <code>NSNumber</code>，不区分具体。大量操作在指针上进行，也就隐含着一切可能出错的调用都会返回 <code>nil</code>。
没有泛型支持，字典或者数组更多用 <code>id</code> 类型。</p>

<h2>对应 Swift 特色</h2>

<p>数值类型众多 （<code>Int, UInt, Float, Double, ...</code>），无指针（<code>UnsafePointer</code> 这类用于和其他代码交互的结构不计，<code>&amp;</code> + <code>inout</code> 认为是引用。）。
<code>nil</code> 用于 <code>Type?</code>, <code>Type!</code>。字典和数组用泛型表示。</p>

<h2>一些属性</h2>

<p>有几个属性用于和 Objective-C 之间的交互。</p>

<h3><code>@objc</code> 和 <code>@objc(a_name_defined_in_objc)</code></h3>

<h3><code>@objc_block</code></h3>

<p>用于函数类型前，标记后面的 block 是 Objective-C 的。个人觉得编译器会自动转换相关的 block 类型。</p>

<p>然后需要预备下几个属性的知识。</p>

<h3><code>@conversion</code></h3>

<p>Swift 中的隐式类型转换。有另一篇文章介绍。</p>

<h3><code>@final</code></h3>

<p>就是 final 了。</p>

<h3><code>@transparent</code></h3>

<p>经过反汇编查看，相当于 <code>inline</code> 的作用。同时生成的 <code>.swiftmodule</code> 文件依然带有原函数实现。这个很高大上。保证了 <code>inline</code> 特性在包外可用。</p>

<h2>重要 Swift protocol</h2>

<h3><code>*LiteralConvertible</code></h3>

<p>表示可以从 Swift 字面常量转换而得。比如 <code>let a: Type = 100</code>, 那么 Type 必须实现 IntegerLiteralConvertible。</p>

<p>大概有 IntegerLiteralConvertible, FloatLiteralConvertible, StringLiteralConvertible, ArrayLiteralConvertible, DictionaryLiteralConvertible, CharacterLiteralConvertible 等。</p>

<h3><code>_BridgedToObjectiveC</code> <code>_ConditionallyBridgedToObjectiveC</code></h3>

<p>顾名思义。就是相当于这个 Swift 类型可以和某一 Objective-C 类型对等，可以相互转换。</p>

<p>Conditional 多了个判断函数，也就是说这个类型可能是并没有对等起来的，什么情况下用呢，目前猜测应该是带泛型参数的类型中用到，有的泛型可以对应，有的不可以。</p>

<pre><code class="scala">protocol _BridgedToObjectiveC {
  typealias ObjectiveCType
  class func getObjectiveCType() -&gt; Any.Type
  func bridgeToObjectiveC() -&gt; ObjectiveCType
  class func bridgeFromObjectiveC(source: ObjectiveCType) -&gt; Self?
}
</code></pre>

<h3><code>Reflectable</code> <code>Mirror</code></h3>

<p>这个具体暂时不清楚。反射相关的两个 protocol 。</p>

<h3><code>Sequence</code> <code>Generator</code></h3>

<p>这两个用于 Swift 的 for-in 循环，简单说就是，实现了 <code>Sequence</code> 协议的对象可以 <code>.generate()</code> 出一个 <code>Generator</code>，
然后 <code>Generator</code> 可以不断地 <code>.next()</code> 返回 <code>Type?</code>，其中 <code>Type</code> 是这个序列的泛型。</p>

<h3><code>Hashable</code> <code>Equatable</code></h3>

<p>英汉字典拿来。所以其实为了让 Objective-C 类型在 Swift 代码中正常工作，这个是必不可少的。</p>

<h1>第一部分，类型交互</h1>

<h2>For 类、方法、协议</h2>

<p>通过 <code>@objc(name)</code> 转为 Swift 定义。其中 name 为 Objective-C 下的名字。</p>

<p>例如</p>

<pre><code>@objc(NSNumber) class NSNumber : NSValue {
    @objc(init) convenience init()
    @objc var integerValue: Int {
        @objc(integerValue) get {}
    }
    ...
}
@objc(NSCopying) protocol NSCopying {
    @objc(copyWithZone:) func copyWithZone(zone: NSZone) -&gt; AnyObject!
}
</code></pre>

<p>所有可能为 <code>nil</code> 的指针类型几乎都被转为 <code>Type!</code>，由于 <code>ImplicitlyUnwrappedOptional</code> 的特性，所以几乎用起来一样。</p>

<h2>For 基础数字类型</h2>

<p><code>Int</code>, <code>UInt</code>, <code>Float</code>, <code>Double</code> 均实现了 <code>_BridgedToObjectiveC</code>, 其中类型参数 <code>ObjectiveCType</code> 均为 <code>NSNumber</code>。</p>

<p>也就是说，可以直接 <code>.getObjectiveCType()</code> 获取到 <code>NSNumber</code>，然后剩下的就很熟悉了。</p>

<p><code>NSNumber</code> 实现了 <code>FloatLiteralConvertible</code>, <code>IntegerLiteralConvertible</code>，所以其实，也可以直接从 Swift 字面常量获得。</p>

<h2>For Bool</h2>

<p>实际上 Objective-C 中的 <code>BOOL</code> 是某一数字类型，<code>YES</code>, <code>NO</code> 也分别是 1, 0 。</p>

<p>所以 Swift <code>Bool</code> 实现了 <code>_BridgedToObjectiveC</code>，对应于 <code>NSNumber</code> 类型。</p>

<h2>For String</h2>

<p><code>NSString</code> 实现了 <code>StringLiteralConvertible</code>，可以直接通过字面常量获得，同时还有到 <code>String</code> 的隐式类型转换。</p>

<p><code>String</code> 实现了 <code>_BridgedToObjectiveC</code> 对应于 <code>NSString</code>。</p>

<pre><code class="scala">extension NSString {
  @conversion func __conversion() -&gt; String
}
</code></pre>

<p>这就是为什么官方文档说 Swift 中 <code>String</code> 和 Objective-C 基本是相同操作的。其实都是背后的隐式类型转换。</p>

<p>同时 Foundation 还为 <code>String</code> 扩充了很多方法，发现几个比较有意思的是 <code>._ns</code>，直接返回 <code>NSString</code>, <code>._index(Int)</code> 返回 <code>String.Index</code>，等等。</p>

<h2>For Array</h2>

<p><code>NSArray</code> 实现了 <code>ArrayLiteralConvertible</code>， 可以从字面常量直接获得。还实现了到 <code>AnyObject[]</code> 的隐式类型转换。</p>

<p><code>Array&lt;T&gt;</code> 实现了 <code>_ConditionallyBridgedToObjectiveC</code>, 对应于 <code>NSArray</code>.</p>

<p><code>NSArray</code> 还实现了 <code>Sequence</code> 协议，也就是可以通过 for-in 操作。其中 <code>generate()</code> 返回 <code>NSFastGenerator</code> 类，这个应该是在原有 Foundation 没有的。
当然 <code>.next()</code> 返回 <code>AnyObject?</code></p>

<h2>For Dictionary</h2>

<p><code>NSDictionary</code> 实现了 <code>DictionaryLiteralConvertible</code>, <code>Sequence</code>。同时还实现了到 <code>Dictionary&lt;NSObject, AnyObject&gt;</code> 的隐式类型转换。</p>

<p><code>Dictionary&lt;KeyType, ValueType&gt;</code> 实现了到 <code>NSDictionary</code> 的隐式类型转换。实现了 <code>_ConditionallyBridgedToObjectiveC</code> 对应于 <code>NSDictionary</code>。</p>

<h2>其他扩充类型</h2>

<p>新类型 <code>NSRange</code>，实现了 <code>_BridgedToObjectiveC</code>，对应于 <code>NSValue</code>，实现了到 <code>Range&lt;Int&gt;</code> 的隐式类型转换。</p>

<p><code>NSMutableSet</code> <code>NSMutableDictionary</code> <code>NSSet</code> <code>NSMutableArray</code> 均实现了 <code>Sequence</code> 可以 for-in .</p>

<h1>第二部分：从 Swift 调用 Objective-C</h1>

<p>一般说来，你在 Swift 项目新建 Objective-C 类的时候，直接弹出是否创建 Bridge Header 的窗口，点 YES 就是了，这时候一般多出来个 <code>ProjectName-Bridging-Header.h</code> 。</p>

<p>如果没有自动的话，这个配置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。</p>

<p>说到底，其实是调用编译命令的 <code>-import-objc-header</code> 参数，后面加上这个 Header 文件。</p>

<p>然后你就可以把你的 Objective-C Class 的 .h 文件都 import 到这个 Herder 文件里了。</p>

<p>所有 Swift 代码都可以直接调用。完全透明，自动生成。</p>

<h1>第三部分：从 Objective-C 调用 Swift</h1>

<p>头文件是 <code>ProjectName-Swift.h</code>。直接 import 。</p>

<p>不要吝啬你的键盘大量地加入 <code>@objc</code> 属性就是了。</p>

<p>具体实现据我猜测是这样，先 swift 调用 <code>-emit-objc-header</code> <code>-emit-objc-header-path</code> 参数控制生成 Objective-C 的 Header，同时 swift 编译为模块，然后再编译一次。</p>

<p>头文件内容大概是会包含一堆宏定义。然后是 Swift 的类定义等。这里可以看到 Swift 的 mangling 名字。</p>

<pre><code class="scala">SWIFT_CLASS("_TtC5Hello11AppDelegate")
@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;
@property (nonatomic) UIWindow * window;
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;
- (void)applicationWillResignActive:(UIApplication *)application;
- (void)applicationDidEnterBackground:(UIApplication *)application;
- (void)applicationWillEnterForeground:(UIApplication *)application;
- (void)applicationDidBecomeActive:(UIApplication *)application;
- (void)applicationWillTerminate:(UIApplication *)application;
- (instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end
</code></pre>

<h1>第四部分：一个 Swift 和 Objective-C 混合项目的编译过程</h1>

<p>这里只先考虑一个 Swift 项目使用 Objective-C 代码的情况，这个应该暂时比较多见（使用旧的 MVC 代码，用新的 Swift 创建 ui 一类）。</p>

<ul>
<li>编译所有 <code>X.swift</code> 文件到 <code>X.o</code> (with <code>-emit-objc-header</code>, <code>-import-objc-header</code>) (其中包含 <code>.swiftmodule</code> 子过程)

<ul>
<li>由于选项里有 <code>-emit-objc-header</code>，所以之后的 Objective-C 文件可以直接 import 对应的 <code>ProjectName-Swift.h</code></li>
</ul>
</li>
<li>编译 <code>X.m</code> 到 <code>X.o</code></li>
<li>链接所有 <code>.o</code> 生成可执行文件</li>
</ul>

]]></content>
  </entry>
  
</feed>
