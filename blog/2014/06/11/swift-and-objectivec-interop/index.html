<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互) | 猫·仁波切</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。" />
<meta property="og:description" content="主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。" />
<link rel="canonical" href="https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/" />
<meta property="og:url" content="https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/" />
<meta property="og:site_name" content="猫·仁波切" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-06-11T12:01:11+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2014-06-11T12:01:11+00:00","datePublished":"2014-06-11T12:01:11+00:00","description":"主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。","headline":"Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)","mainEntityOfPage":{"@type":"WebPage","@id":"https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/"},"url":"https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://andelf.github.io/feed.xml" title="猫·仁波切" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">猫·仁波切</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-06-11T12:01:11+00:00" itemprop="datePublished">Jun 11, 2014
      </time>• <span>Tags: swift</span></p><div class="table-of-contents">
      
    </div>
    <hr />
  </header>
  <div class="post-content e-content" itemprop="articleBody">
    <p>主要介绍原有 Objective-C 中的一些类型在 Swift 中的操作问题。差不多就能知道，你在 Swift 如何对 Objective-C (Foundation) 原生类型进行操作以及和 Swift 类型互转。</p>

<p>瞎写的，有错或者不明白的地方直接告诉我。转载注明我或者 SwiftChina 。</p>

<p>参考资料是 我的 Github : <a href="https://github.com/andelf/Defines-Swift">andelf/Defines-Swift</a> 是我dump出的定义。10w行swift代码。</p>

<h1 id="预备知识">预备知识</h1>

<h2 id="objective-c-cocoa-特色">Objective-C (Cocoa) 特色</h2>

<p>数值类型统一用 <code class="language-plaintext highlighter-rouge">NSNumber</code>，不区分具体。大量操作在指针上进行，也就隐含着一切可能出错的调用都会返回 <code class="language-plaintext highlighter-rouge">nil</code>。
没有泛型支持，字典或者数组更多用 <code class="language-plaintext highlighter-rouge">id</code> 类型。</p>

<h2 id="对应-swift-特色">对应 Swift 特色</h2>

<p>数值类型众多 （<code class="language-plaintext highlighter-rouge">Int, UInt, Float, Double, ...</code>），无指针（<code class="language-plaintext highlighter-rouge">UnsafePointer</code> 这类用于和其他代码交互的结构不计，<code class="language-plaintext highlighter-rouge">&amp;</code> + <code class="language-plaintext highlighter-rouge">inout</code> 认为是引用。）。
<code class="language-plaintext highlighter-rouge">nil</code> 用于 <code class="language-plaintext highlighter-rouge">Type?</code>, <code class="language-plaintext highlighter-rouge">Type!</code>。字典和数组用泛型表示。</p>

<h2 id="一些属性">一些属性</h2>

<p>有几个属性用于和 Objective-C 之间的交互。</p>

<h3 id="objc-和-objca_name_defined_in_objc"><code class="language-plaintext highlighter-rouge">@objc</code> 和 <code class="language-plaintext highlighter-rouge">@objc(a_name_defined_in_objc)</code></h3>

<h3 id="objc_block"><code class="language-plaintext highlighter-rouge">@objc_block</code></h3>

<p>用于函数类型前，标记后面的 block 是 Objective-C 的。个人觉得编译器会自动转换相关的 block 类型。</p>

<p>然后需要预备下几个属性的知识。</p>

<h3 id="conversion"><code class="language-plaintext highlighter-rouge">@conversion</code></h3>

<p>Swift 中的隐式类型转换。有另一篇文章介绍。</p>

<h3 id="final"><code class="language-plaintext highlighter-rouge">@final</code></h3>

<p>就是 final 了。</p>

<h3 id="transparent"><code class="language-plaintext highlighter-rouge">@transparent</code></h3>

<p>经过反汇编查看，相当于 <code class="language-plaintext highlighter-rouge">inline</code> 的作用。同时生成的 <code class="language-plaintext highlighter-rouge">.swiftmodule</code> 文件依然带有原函数实现。这个很高大上。保证了 <code class="language-plaintext highlighter-rouge">inline</code> 特性在包外可用。</p>

<h2 id="重要-swift-protocol">重要 Swift protocol</h2>

<h3 id="literalconvertible"><code class="language-plaintext highlighter-rouge">*LiteralConvertible</code></h3>

<p>表示可以从 Swift 字面常量转换而得。比如 <code class="language-plaintext highlighter-rouge">let a: Type = 100</code>, 那么 Type 必须实现 IntegerLiteralConvertible。</p>

<p>大概有 IntegerLiteralConvertible, FloatLiteralConvertible, StringLiteralConvertible, ArrayLiteralConvertible, DictionaryLiteralConvertible, CharacterLiteralConvertible 等。</p>

<h3 id="_bridgedtoobjectivec-_conditionallybridgedtoobjectivec"><code class="language-plaintext highlighter-rouge">_BridgedToObjectiveC</code> <code class="language-plaintext highlighter-rouge">_ConditionallyBridgedToObjectiveC</code></h3>

<p>顾名思义。就是相当于这个 Swift 类型可以和某一 Objective-C 类型对等，可以相互转换。</p>

<p>Conditional 多了个判断函数，也就是说这个类型可能是并没有对等起来的，什么情况下用呢，目前猜测应该是带泛型参数的类型中用到，有的泛型可以对应，有的不可以。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">protocol</span> <span class="nc">_BridgedToObjectiveC</span> <span class="o">{</span>
  <span class="n">typealias</span> <span class="nc">ObjectiveCType</span>
  <span class="k">class</span> <span class="nc">func</span> <span class="nf">getObjectiveCType</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nv">Any</span><span class="o">.</span><span class="py">Type</span>
  <span class="n">func</span> <span class="nf">bridgeToObjectiveC</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">ObjectiveCType</span>
  <span class="k">class</span> <span class="nc">func</span> <span class="nf">bridgeFromObjectiveC</span><span class="o">(</span><span class="n">source</span><span class="k">:</span> <span class="kt">ObjectiveCType</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Self</span><span class="o">?</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="reflectable-mirror"><code class="language-plaintext highlighter-rouge">Reflectable</code> <code class="language-plaintext highlighter-rouge">Mirror</code></h3>

<p>这个具体暂时不清楚。反射相关的两个 protocol 。</p>

<h3 id="sequence-generator"><code class="language-plaintext highlighter-rouge">Sequence</code> <code class="language-plaintext highlighter-rouge">Generator</code></h3>

<p>这两个用于 Swift 的 for-in 循环，简单说就是，实现了 <code class="language-plaintext highlighter-rouge">Sequence</code> 协议的对象可以 <code class="language-plaintext highlighter-rouge">.generate()</code> 出一个 <code class="language-plaintext highlighter-rouge">Generator</code>，
然后 <code class="language-plaintext highlighter-rouge">Generator</code> 可以不断地 <code class="language-plaintext highlighter-rouge">.next()</code> 返回 <code class="language-plaintext highlighter-rouge">Type?</code>，其中 <code class="language-plaintext highlighter-rouge">Type</code> 是这个序列的泛型。</p>

<h3 id="hashable-equatable"><code class="language-plaintext highlighter-rouge">Hashable</code> <code class="language-plaintext highlighter-rouge">Equatable</code></h3>

<p>英汉字典拿来。所以其实为了让 Objective-C 类型在 Swift 代码中正常工作，这个是必不可少的。</p>

<h1 id="第一部分类型交互">第一部分，类型交互</h1>

<h2 id="for-类方法协议">For 类、方法、协议</h2>

<p>通过 <code class="language-plaintext highlighter-rouge">@objc(name)</code> 转为 Swift 定义。其中 name 为 Objective-C 下的名字。</p>

<p>例如</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@objc(NSNumber) class NSNumber : NSValue {
    @objc(init) convenience init()
    @objc var integerValue: Int {
        @objc(integerValue) get {}
    }
    ...
}
@objc(NSCopying) protocol NSCopying {
    @objc(copyWithZone:) func copyWithZone(zone: NSZone) -&gt; AnyObject!
}
</code></pre></div></div>

<p>所有可能为 <code class="language-plaintext highlighter-rouge">nil</code> 的指针类型几乎都被转为 <code class="language-plaintext highlighter-rouge">Type!</code>，由于 <code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional</code> 的特性，所以几乎用起来一样。</p>

<h2 id="for-基础数字类型">For 基础数字类型</h2>

<p><code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">UInt</code>, <code class="language-plaintext highlighter-rouge">Float</code>, <code class="language-plaintext highlighter-rouge">Double</code> 均实现了 <code class="language-plaintext highlighter-rouge">_BridgedToObjectiveC</code>, 其中类型参数 <code class="language-plaintext highlighter-rouge">ObjectiveCType</code> 均为 <code class="language-plaintext highlighter-rouge">NSNumber</code>。</p>

<p>也就是说，可以直接 <code class="language-plaintext highlighter-rouge">.getObjectiveCType()</code> 获取到 <code class="language-plaintext highlighter-rouge">NSNumber</code>，然后剩下的就很熟悉了。</p>

<p><code class="language-plaintext highlighter-rouge">NSNumber</code> 实现了 <code class="language-plaintext highlighter-rouge">FloatLiteralConvertible</code>, <code class="language-plaintext highlighter-rouge">IntegerLiteralConvertible</code>，所以其实，也可以直接从 Swift 字面常量获得。</p>

<h2 id="for-bool">For Bool</h2>

<p>实际上 Objective-C 中的 <code class="language-plaintext highlighter-rouge">BOOL</code> 是某一数字类型，<code class="language-plaintext highlighter-rouge">YES</code>, <code class="language-plaintext highlighter-rouge">NO</code> 也分别是 1, 0 。</p>

<p>所以 Swift <code class="language-plaintext highlighter-rouge">Bool</code> 实现了 <code class="language-plaintext highlighter-rouge">_BridgedToObjectiveC</code>，对应于 <code class="language-plaintext highlighter-rouge">NSNumber</code> 类型。</p>

<h2 id="for-string">For String</h2>

<p><code class="language-plaintext highlighter-rouge">NSString</code> 实现了 <code class="language-plaintext highlighter-rouge">StringLiteralConvertible</code>，可以直接通过字面常量获得，同时还有到 <code class="language-plaintext highlighter-rouge">String</code> 的隐式类型转换。</p>

<p><code class="language-plaintext highlighter-rouge">String</code> 实现了 <code class="language-plaintext highlighter-rouge">_BridgedToObjectiveC</code> 对应于 <code class="language-plaintext highlighter-rouge">NSString</code>。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extension</span> <span class="nc">NSString</span> <span class="o">{</span>
  <span class="nd">@conversion</span> <span class="n">func</span> <span class="nc">__conversion</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这就是为什么官方文档说 Swift 中 <code class="language-plaintext highlighter-rouge">String</code> 和 Objective-C 基本是相同操作的。其实都是背后的隐式类型转换。</p>

<p>同时 Foundation 还为 <code class="language-plaintext highlighter-rouge">String</code> 扩充了很多方法，发现几个比较有意思的是 <code class="language-plaintext highlighter-rouge">._ns</code>，直接返回 <code class="language-plaintext highlighter-rouge">NSString</code>, <code class="language-plaintext highlighter-rouge">._index(Int)</code> 返回 <code class="language-plaintext highlighter-rouge">String.Index</code>，等等。</p>

<h2 id="for-array">For Array</h2>

<p><code class="language-plaintext highlighter-rouge">NSArray</code> 实现了 <code class="language-plaintext highlighter-rouge">ArrayLiteralConvertible</code>， 可以从字面常量直接获得。还实现了到 <code class="language-plaintext highlighter-rouge">AnyObject[]</code> 的隐式类型转换。</p>

<p><code class="language-plaintext highlighter-rouge">Array&lt;T&gt;</code> 实现了 <code class="language-plaintext highlighter-rouge">_ConditionallyBridgedToObjectiveC</code>, 对应于 <code class="language-plaintext highlighter-rouge">NSArray</code>.</p>

<p><code class="language-plaintext highlighter-rouge">NSArray</code> 还实现了 <code class="language-plaintext highlighter-rouge">Sequence</code> 协议，也就是可以通过 for-in 操作。其中 <code class="language-plaintext highlighter-rouge">generate()</code> 返回 <code class="language-plaintext highlighter-rouge">NSFastGenerator</code> 类，这个应该是在原有 Foundation 没有的。
当然 <code class="language-plaintext highlighter-rouge">.next()</code> 返回 <code class="language-plaintext highlighter-rouge">AnyObject?</code></p>

<h2 id="for-dictionary">For Dictionary</h2>

<p><code class="language-plaintext highlighter-rouge">NSDictionary</code> 实现了 <code class="language-plaintext highlighter-rouge">DictionaryLiteralConvertible</code>, <code class="language-plaintext highlighter-rouge">Sequence</code>。同时还实现了到 <code class="language-plaintext highlighter-rouge">Dictionary&lt;NSObject, AnyObject&gt;</code> 的隐式类型转换。</p>

<p><code class="language-plaintext highlighter-rouge">Dictionary&lt;KeyType, ValueType&gt;</code> 实现了到 <code class="language-plaintext highlighter-rouge">NSDictionary</code> 的隐式类型转换。实现了 <code class="language-plaintext highlighter-rouge">_ConditionallyBridgedToObjectiveC</code> 对应于 <code class="language-plaintext highlighter-rouge">NSDictionary</code>。</p>

<h2 id="其他扩充类型">其他扩充类型</h2>

<p>新类型 <code class="language-plaintext highlighter-rouge">NSRange</code>，实现了 <code class="language-plaintext highlighter-rouge">_BridgedToObjectiveC</code>，对应于 <code class="language-plaintext highlighter-rouge">NSValue</code>，实现了到 <code class="language-plaintext highlighter-rouge">Range&lt;Int&gt;</code> 的隐式类型转换。</p>

<p><code class="language-plaintext highlighter-rouge">NSMutableSet</code> <code class="language-plaintext highlighter-rouge">NSMutableDictionary</code> <code class="language-plaintext highlighter-rouge">NSSet</code> <code class="language-plaintext highlighter-rouge">NSMutableArray</code> 均实现了 <code class="language-plaintext highlighter-rouge">Sequence</code> 可以 for-in .</p>

<h1 id="第二部分从-swift-调用-objective-c">第二部分：从 Swift 调用 Objective-C</h1>

<p>一般说来，你在 Swift 项目新建 Objective-C 类的时候，直接弹出是否创建 Bridge Header 的窗口，点 YES 就是了，这时候一般多出来个 <code class="language-plaintext highlighter-rouge">ProjectName-Bridging-Header.h</code> 。</p>

<p>如果没有自动的话，这个配置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。</p>

<p>说到底，其实是调用编译命令的 <code class="language-plaintext highlighter-rouge">-import-objc-header</code> 参数，后面加上这个 Header 文件。</p>

<p>然后你就可以把你的 Objective-C Class 的 .h 文件都 import 到这个 Herder 文件里了。</p>

<p>所有 Swift 代码都可以直接调用。完全透明，自动生成。</p>

<h1 id="第三部分从-objective-c-调用-swift">第三部分：从 Objective-C 调用 Swift</h1>

<p>头文件是 <code class="language-plaintext highlighter-rouge">ProjectName-Swift.h</code>。直接 import 。</p>

<p>不要吝啬你的键盘大量地加入 <code class="language-plaintext highlighter-rouge">@objc</code> 属性就是了。</p>

<p>具体实现据我猜测是这样，先 swift 调用 <code class="language-plaintext highlighter-rouge">-emit-objc-header</code> <code class="language-plaintext highlighter-rouge">-emit-objc-header-path</code> 参数控制生成 Objective-C 的 Header，同时 swift 编译为模块，然后再编译一次。</p>

<p>头文件内容大概是会包含一堆宏定义。然后是 Swift 的类定义等。这里可以看到 Swift 的 mangling 名字。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SWIFT_CLASS</span><span class="o">(</span><span class="s">"_TtC5Hello11AppDelegate"</span><span class="o">)</span>
<span class="nd">@interface</span> <span class="nc">AppDelegate</span> <span class="k">:</span> <span class="kt">UIResponder</span> <span class="kt">&lt;UIApplicationDelegate&gt;</span>
<span class="kt">@property</span> <span class="o">(</span><span class="kt">nonatomic</span><span class="o">)</span> <span class="kt">UIWindow</span> <span class="kt">*</span> <span class="kt">window</span><span class="o">;</span>
<span class="o">-</span> <span class="o">(</span><span class="nc">BOOL</span><span class="o">)</span><span class="n">application</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span> <span class="kt">didFinishLaunchingWithOptions:</span><span class="o">(</span><span class="kt">NSDictionary</span> <span class="kt">*</span><span class="o">)</span><span class="kt">launchOptions</span><span class="o">;</span>
<span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillResignActive</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
<span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationDidEnterBackground</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
<span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillEnterForeground</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
<span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationDidBecomeActive</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
<span class="o">-</span> <span class="o">(</span><span class="n">void</span><span class="o">)</span><span class="n">applicationWillTerminate</span><span class="k">:</span><span class="o">(</span><span class="kt">UIApplication</span> <span class="kt">*</span><span class="o">)</span><span class="kt">application</span><span class="o">;</span>
<span class="o">-</span> <span class="o">(</span><span class="n">instancetype</span><span class="o">)</span><span class="n">init</span> <span class="nc">OBJC_DESIGNATED_INITIALIZER</span><span class="o">;</span>
<span class="nd">@end</span>
</code></pre></div></div>

<h1 id="第四部分一个-swift-和-objective-c-混合项目的编译过程">第四部分：一个 Swift 和 Objective-C 混合项目的编译过程</h1>

<p>这里只先考虑一个 Swift 项目使用 Objective-C 代码的情况，这个应该暂时比较多见（使用旧的 MVC 代码，用新的 Swift 创建 ui 一类）。</p>

<ul>
  <li>编译所有 <code class="language-plaintext highlighter-rouge">X.swift</code> 文件到 <code class="language-plaintext highlighter-rouge">X.o</code> (with <code class="language-plaintext highlighter-rouge">-emit-objc-header</code>, <code class="language-plaintext highlighter-rouge">-import-objc-header</code>) (其中包含 <code class="language-plaintext highlighter-rouge">.swiftmodule</code> 子过程)
    <ul>
      <li>由于选项里有 <code class="language-plaintext highlighter-rouge">-emit-objc-header</code>，所以之后的 Objective-C 文件可以直接 import 对应的 <code class="language-plaintext highlighter-rouge">ProjectName-Swift.h</code></li>
    </ul>
  </li>
  <li>编译 <code class="language-plaintext highlighter-rouge">X.m</code> 到 <code class="language-plaintext highlighter-rouge">X.o</code></li>
  <li>链接所有 <code class="language-plaintext highlighter-rouge">.o</code> 生成可执行文件</li>
</ul>

  </div>

  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/';
      this.page.identifier = 'https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://andelf.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<a class="u-url" href="/blog/2014/06/11/swift-and-objectivec-interop/" hidden></a>
</article>



  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/';
      this.page.identifier = 'https://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://andelf.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>





      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">猫·仁波切</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">猫·仁波切</li><li><a class="u-email" href="mailto:andelf@gmail.com">andelf@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/andelf"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">andelf</span></a></li><li><a href="https://www.twitter.com/andelf"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">andelf</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>会研发的PM才是好OP.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
