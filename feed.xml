<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://andelf.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://andelf.github.io/" rel="alternate" type="text/html" /><updated>2024-12-25T12:57:00+00:00</updated><id>https://andelf.github.io/feed.xml</id><title type="html">猫·仁波切</title><subtitle>会研发的PM才是好OP.</subtitle><author><name>猫·仁波切</name></author><entry><title type="html">基于 Rust 的 K230 裸机嵌入式编程 - K230 Bare-Metal Embedded Programming Using Rust</title><link href="https://andelf.github.io/2024/12/09/k230-bare-metal-embedded-programming-using-rust/" rel="alternate" type="text/html" title="基于 Rust 的 K230 裸机嵌入式编程 - K230 Bare-Metal Embedded Programming Using Rust" /><published>2024-12-09T08:53:00+00:00</published><updated>2024-12-11T05:52:14+00:00</updated><id>https://andelf.github.io/2024/12/09/k230-bare-metal-embedded-programming-using-rust</id><content type="html" xml:base="https://andelf.github.io/2024/12/09/k230-bare-metal-embedded-programming-using-rust/"><![CDATA[<blockquote>
  <p>难度: 中等, 读者应具备嵌入式系统基础知识和 Rust 嵌入式开发基础</p>
</blockquote>

<p>本文记录了在 K230 芯片上进行 Rust 裸机开发的过程. 从启动流程的分析, 固件格式的解析, 到编写裸机 Rust 程序, 完善初始化代码, 再到实际的外设控制和功能实现,
和后续开发过程的优化方案, 都进行了探索.</p>

<p>本文相关代码库: <a href="https://github.com/andelf/k230-bare-metal">k230-bare-metal</a>. 建议参考早期提交记录如 <a href="https://github.com/andelf/k230-bare-metal/tree/e1596804045b95b2f639036e10653605f04c72a6">e15968040</a> 配合阅读.</p>

<h2 id="项目背景-background">项目背景 (Background)</h2>

<p>之前从立创开发板获得了 <a href="https://wiki.lckfb.com/zh-hans/lushan-pi-k230/">立创·庐山派K230-CanMV</a> 的测评机会,
另外我自己也有一块 <a href="https://wiki.youyeetoo.com/en/CanMV-K230">CanMV-K230</a> 开发板.</p>

<p>K230芯片是嘉楠科技推出的 AIoT SoC, 采用异构单元加速计算架构, 集成了 2 个 RISC-V 算核心和 AI 子系统 KPU(Knowledge Process Unit).
按照时间线, 应该是市面上最早一批支持 RV 向量扩展 RVV 1.0 的芯片之一. 主要特点:</p>

<ul>
  <li>双核 RISC-V 处理器
    <ul>
      <li>Core 0: 64位 RISC-V (RV64GCB), 800MHz</li>
      <li>Core 1: 64位 RISC-V, 1.6GHz, 支持 RVV 1.0 向量扩展</li>
    </ul>
  </li>
  <li>专用加速单元
    <ul>
      <li>KPU: AI 推理加速器, 支持 INT8/INT16</li>
      <li>DPU: 3D 结构光深度计算单元</li>
      <li>VPU: 视频编解码器, 支持 4K 分辨率</li>
    </ul>
  </li>
  <li>丰富的外设接口
    <ul>
      <li>通信接口: UART×5、I2C×5、SPI×3</li>
      <li>存储接口: USB 2.0×2、SD/eMMC</li>
      <li>其他: GPIO×72、PWM×6、WDT/RTC/Timer</li>
    </ul>
  </li>
</ul>

<p>在正常使用情况下, 开发板使用 <a href="https://github.com/kendryte/canmv_k230">CanMV</a> 固件, 该固件兼容 <a href="https://openmv.io/">OpenMV</a>, 为开发者提供了非常便捷的开发环境.
固件底层实现基于 <a href="https://github.com/RT-Thread/rt-thread">RT-Thread</a> Smart(RT-Smart), 是支持用户态应用的 RT-Thread 版本, 适用于支持 MMU 的 SoC, 例如 K230.
CanMV 实现为 RT-Thread 的一个 APP(MicroPython fork).
另外早期版本的 CanMV 固件使用 Linux + RT-Thread + Micropython. 官方也有纯 Linux 版本固件.</p>

<p>本项目旨在探索:</p>

<ol>
  <li>MPU 与 MCU 在启动方式和使用模式上的区别</li>
  <li>如何使用 Rust 进行 MPU 芯片的裸机开发</li>
  <li>K230 的底层启动机制和硬件特性</li>
</ol>

<p>对于 MPU 及多数 MCU 来说都存在一个片上 Boot ROM 用于启动系统. 通常情况下, Boot ROM 会初始化一些硬件(例如 SPI Flash, TF Card等), 将固件加载到内存
然后加载系统固件的第一行逻辑(例如 U-Boot). 之后用户提供的系统固件会初始化更多硬件及加载真正的操作系统.</p>

<p>所谓的裸机开发, 就是不使用操作系统, 直接在硬件上运行程序, 类似 MCU 直接在系统 Boot ROM 之后运行的方式.</p>

<h2 id="启动代码分析-boot-code-analysis">启动代码分析 (Boot Code Analysis)</h2>

<p>首先需要阅读官方仓库 <a href="https://github.com/kendryte/canmv_k230">CanMV</a> 的代码, 确定是否有不开源的部分. 尤其是核心的 U-Boot 和 RT-Thread/Linux 驱动部分.
对于 U-Boot 还需要确认第一阶段启动代码 SPL(Secondary Program Loader) 是否开源. 因为 SPL 往往用于初始化 DDR 等外设, 以及加载 U-Boot, 很多厂商不开源,
只提供二进制文件.</p>

<blockquote>
  <p>SPL 字面意思是 <strong>第二阶段</strong> 启动加载器, Boot ROM 一般被认为是第一阶段加载器</p>
</blockquote>

<p>好消息是, 相关的代码都在 <a href="https://github.com/kendryte/canmv_k230">CanMV</a> 仓库中, 且开源. 但是代码结构比较复杂, 需要一定时间阅读分析具体的启动流程和逻辑.
然而, 随着 ChatGPT 的出现, 我们可以更快地完成代码分析. 我曾自嘲, ChatGPT 早出现几年的话, 很多工具链都不需要存在.</p>

<p>这里只考虑 TF card 启动的情况, 系统固件在 TF 卡上, 片上 Boot ROM 加载固件到内存. 也就是我们的程序需要做到和 U-Boot 一样的事情, 包括 SPL 的功能.</p>

<blockquote>
  <p>注: TF 卡、SD 卡、eMMC 在协议层面基本相同, 本文不做严格区分/</p>
</blockquote>

<h3 id="上电复位到加载并执行用户固件">上电复位到加载并执行用户固件</h3>

<p>首先, Boot ROM 加载固件到内存。这一部分的逻辑是直接固化在芯片内部的 Boot ROM 中, 属于无法控制的部分, 因为 Boot ROM 的代码和逻辑都集成在芯片内部, 无法被用户修改或干预。Boot ROM 内部的实现机制是通过读取 BOOT0 和 BOOT1 两个引脚的状态来判断启动方式。这两个引脚的电平状态决定了芯片在启动时从何种介质加载引导程序。</p>

<p>从芯片手册看, Boot ROM 的内存映射位置位于 0x9120_0000 ~ 0x9121_0000, 使用 SRAM 的前半部分 0x8020_0000 ~ 0x8030_0000.
这些信息可以通过裸机程序读取 sp/ra 等特征确认. 例如 Boot ROM 会将堆栈指针 sp 设置为可用内存的最高地址.
Boot ROM 跳转到用户固件往往使用 call 指令, ra 会被设置为当前跳转函数的 pc.</p>

<p>Boot ROM 会按照预先设定的固定格式, 从 TF 卡中加载固件(通常是 U-Boot)到内存中。具体来说, Boot ROM 会访问 TF 卡,
读取固件区域, 将其解码并复制到指定的内存位置 0x8030_0000.</p>

<p>当固件加载完成后, Boot ROM 会将系统的执行权转移到刚刚加载到内存的固件上, 也就是跳转执行 U-Boot。这标志着启动过程从 Boot ROM 阶段进入了固件（U-Boot）阶段。U-Boot 作为一个功能更为强大的引导加载程序, 可以进一步初始化系统硬件、加载操作 RT-Thread 或 Linux Kernel, 以及执行其他用户定义的启动任务。
U-boot 分为两阶段启动, SPL 和 U-Boot, SPL 用于初始化 DDR 等外设, 加载 U-Boot, U-Boot 之后的逻辑(OpenSBI, RT-Thread Smart), 我们此次不考虑.
从固件格式看, 这部分以固件分区的方式存在, 依次由 U-Boot SPL 加载 U-Boot, U-Boot 加载 RT-Thread/Linux Kernel.</p>

<p>K230 配备了两个 CPU, 分别称为 CPU0(小核) 和 CPU1(大核), 两个核心工作在不同频率, 且 CPU1 支持 RVV 1.0 向量扩展, 属于异构多核架构.
在启动过程中, 当芯片的复位信号被解除后, Boot ROM 会在小核上开始执行. 这意味着 CPU0 是第一个被激活的核心, 它负责执行初始的引导程序, 进行系统的基本初始化.
与此同时, 大核的解除复位(de-reset)过程是由小核来控制的。也就是说, 小核完成自身初始化的同时, 还需要发送指令来解除大核的复位状态, 使其从某一位置开始运行.
小核不仅肩负着引导系统启动的重任, 还掌控着大核的启动流程, 为 SoC 整体开始工作奠定了基础.</p>

<h3 id="固件格式">固件格式</h3>

<p>为了让我们的固件被 Boot ROM 识别, 需要特定的固件格式. 各家的 SoC 此类方案不同, 有使用 FAT32 固定文件名的, 有使用特定偏移的固定格式的,
也有使用配置文件的. K230 使用的是固定偏移的固件格式.</p>

<p>K230 的 Boot ROM 会识别 TF 卡的固定偏移位置数据特征, 满足格式的固件会被加载到内存.
Boot ROM 已经初始化了 UART0, 会有简单的报错信息, 例如 “boot failed with exit code 19” 表示未找到 TF 卡, “boot failed with exit code 13” 表示固件格式错误等.</p>

<p>经过分析相关编译流程, 得到 K230 的固件格式如下:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000  +-------------+-------------+-------------+-------------+
          | ........... | ........... | ........... | ........... |  &lt;- Partition table / any other data
          | ........... | ........... | ........... | ........... |
          +-------------+-------------+-------------+-------------+
00100000  | 4b 32 33 30 | 8c fc 02 00 | 00 00 00 00 | bf 8d 0f 38 |   &lt;- Firmware header: |K230...........8|
          | MAGIC: K230 | Length      | Encryption  | SHA256 hash |   &lt;- Encryption 0: non encryption, 1: SM4, 2: AES+RSA
          +-------------+-------------+-------------+-------------+
00100010  | 03 f3 87 07 | fa 1b d8 1d | 4f a0 cd a0 | 7b 54 35 bd |.  &lt;- SHA256 hash cont.
          +-------------+-------------+-------------+-------------+
00100020  | 35 82 85 89 | 66 4d ac 27 | ca f8 56 49 | 00 00 00 00 |   &lt;- SHA256 hash cont. + Padding
          +-------------+-------------+-------------+-------------+
00100030  | 00 00 00 00 | 00 00 00 00 | 00 00 00 00 | 00 00 00 00 |   &lt;- Padding zeros
          +-------------+-------------+-------------+-------------+
          | ........... | ........... | ........... | ........... |   &lt;- Padding zeros
          +-------------+-------------+-------------+-------------+
00100210  | 00 00 00 00 | 73 25 40 f1 | 2a 82 ae 84 | 93 01 00 00 |   &lt;- Firmware data, length zero position
          | Version     | OpCodes     | Data        | Padding     |   &lt;- Version: 0
          | ........... | ........... | ........... | ........... |   &lt;- Firmware data, raw opcodes
          +-------------+-------------+-------------+-------------+
</code></pre></div></div>

<p>相关 C 结构定义位于 <a href="https://github.com/kendryte/canmv_k230">CanMV</a> <code class="language-plaintext highlighter-rouge">src/uboot/uboot/board/kendryte/common/board_common.h</code>.</p>

<p>这里我们简化处理, 不加密固件, 版本号使用 0. 编写一个 Python 脚本完成 TF 卡镜像 .img 固件文件的创建:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
# genimage.py
</span>
<span class="kn">import</span> <span class="n">hashlib</span>

<span class="n">MAGIC</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">"</span><span class="s">K230</span><span class="sh">"</span>

<span class="k">def</span> <span class="nf">sha256</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">digest</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">(</span><span class="n">message</span><span class="p">).</span><span class="nf">digest</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">digest</span>


<span class="n">VERSION</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x00\x00\x00\x00</span><span class="sh">"</span>

<span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">./firmware.bin</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rb</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>

<span class="n">intput_data</span> <span class="o">=</span> <span class="n">VERSION</span> <span class="o">+</span> <span class="n">data</span>

<span class="n">data_len</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">intput_data</span><span class="p">)</span>
<span class="n">raw_data_len</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">.</span><span class="nf">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="sh">"</span><span class="s">little</span><span class="sh">"</span><span class="p">)</span>

<span class="n">encryption_type</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">encryption_type</span> <span class="o">=</span> <span class="n">encryption_type</span><span class="p">.</span><span class="nf">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="sh">"</span><span class="s">little</span><span class="sh">"</span><span class="p">)</span>

<span class="n">hash_data</span> <span class="o">=</span> <span class="nf">sha256</span><span class="p">(</span><span class="n">intput_data</span><span class="p">)</span>

<span class="n">firmware</span> <span class="o">=</span> <span class="n">MAGIC</span> <span class="o">+</span> <span class="n">raw_data_len</span> <span class="o">+</span> <span class="n">encryption_type</span> <span class="o">+</span> <span class="n">hash_data</span>

<span class="n">firmware</span> <span class="o">+=</span> <span class="nf">bytes</span><span class="p">(</span><span class="mi">516</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span>  <span class="c1"># padding
</span><span class="n">firmware</span> <span class="o">+=</span> <span class="n">intput_data</span>

<span class="n">img</span> <span class="o">=</span> <span class="nf">bytes</span><span class="p">(</span><span class="mh">0x100000</span><span class="p">)</span> <span class="o">+</span> <span class="n">firmware</span>  <span class="c1"># image offset 0x100000
</span>
<span class="c1"># fill 512 boundary, make sure the image size is multiple of 512
</span><span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="o">%</span> <span class="mi">512</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">img</span> <span class="o">+=</span> <span class="nf">bytes</span><span class="p">(</span><span class="mi">512</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="o">%</span> <span class="mi">512</span><span class="p">)</span>

<span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">./firmware.img</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">len</span><span class="sh">"</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">firmware.bin</code> 通过 objcopy -O binary 生成:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo objcopy <span class="nt">--release</span> <span class="nt">--</span> <span class="nt">-O</span> binary firmware.bin <span class="o">&amp;&amp;</span> python3 genimage.py
</code></pre></div></div>

<p>需要注意磁盘镜像一般都是 512 字节对齐的, 所以需要填充 512 字节对齐.
固件的写入可以借助任何烧录工具, 包括 <code class="language-plaintext highlighter-rouge">dd</code> 命令.</p>

<h2 id="开始编写裸机-rust-程序-start-writing-some-bare-metal-code">开始编写裸机 Rust 程序 (Start Writing Some Bare-Metal Code)</h2>

<p>搞定了固件的加载, SoC 的控制流程就可以交给我们的程序了. 这里我们使用 Rust 语言编写裸机程序.</p>

<p>裸机 Rust 嵌入式开发的必备要素大概有:</p>

<ul>
  <li>工具链 target, 使用 <code class="language-plaintext highlighter-rouge">rustup</code> 安装: <code class="language-plaintext highlighter-rouge">rustup target add riscv64gc-unknown-none-elf</code></li>
  <li>链接脚本 linker script, <code class="language-plaintext highlighter-rouge">link.x</code>, 用于定义内存布局(也可以直接定义固件布局)</li>
  <li>启动代码, 用于初始化堆栈, 跳转到 Rust 代码, 相当于 C 嵌入式开发中的 <code class="language-plaintext highlighter-rouge">start.S</code></li>
</ul>

<p>从相关代码阅读得知, TF card 中代码被加载到了 0x80300000 ~ 0x80400000. 为了避免额外的不确定性, 可以直接使用 U-Boot 的 linker script.
确保 Rust 代码中定义的符号被加载即可.</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MEMORY</span> { .<span class="n">spl_mem</span> : <span class="n">ORIGIN</span> = <span class="m">0</span><span class="n">x80300000</span>, <span class="n">LENGTH</span> = <span class="m">0</span><span class="n">x80000</span> }
<span class="n">MEMORY</span> { .<span class="n">bss_mem</span> : <span class="n">ORIGIN</span> = <span class="m">0</span><span class="n">x80380000</span>, <span class="n">LENGTH</span> = <span class="m">0</span><span class="n">x20000</span> }

<span class="n">OUTPUT_ARCH</span>(<span class="s2">"riscv"</span>)

<span class="n">ENTRY</span>(<span class="err">_</span><span class="n">start</span>)
<span class="n">PROVIDE</span>(<span class="err">__</span><span class="n">stack_start__</span> = <span class="n">ORIGIN</span>(.<span class="n">bss_mem</span>) + <span class="n">LENGTH</span>(.<span class="n">bss_mem</span>));

/* 省略具体 <span class="n">section</span> 定义 */
</code></pre></div></div>

<p>由于缺乏芯片开发的第一手资料, 我们并不知道 Boot ROM 之后初始化的状态具体如何, 这时候只能靠猜测和尝试.</p>

<h3 id="验证裸机执行---uart">验证裸机执行 - UART</h3>

<p>对于裸机编程来说, 需要初始化设备的初始状态, 包括堆栈 sp, 系统执行模式, 中断表, 中断开启等等. 这些工作通常由 <code class="language-plaintext highlighter-rouge">start.S</code> 或 <code class="language-plaintext highlighter-rouge">crt0.c</code> 完成.
极小初始化代码往往只需要设置堆栈 sp, 保证函数可以跳转调用执行. 在 sp 非法的情况下, 如果使用堆栈, 例如函数调用, 会导致内存访问或错误指令异常,
即所谓的 “跑飞”.</p>

<p>由于没有 JTAG 调试环境(芯片支持, 我这里没有用 CK-LINK), 如何判断我们的代码是否被执行, 以及代码是否正确执行, 是一个问题.
这里我们可以使用 UART0 输出调试信息. 由于 Boot ROM 已经初始化了 UART0, 我们可以直接使用.</p>

<p>从 U-Boot 源码中的 Device Tree .dtsi 文件中可以得知, K230 大量使用了 DesignWare IP 的外设, 例如 UART0, SPI, I2C 等.
这些外设的具体寄存器手册可以从网上获得. UART 外设兼容 16550, 即我们熟悉的 PC 串口芯片. 串口0 寄存器地址为 0x9140_0000.</p>

<p>可以直接使用 <code class="language-plaintext highlighter-rouge">global_asm!</code> 来打印字符来验证固件代码是否被执行. 例如:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#![no_std]</span>
<span class="nd">#![no_main]</span>

<span class="nd">global_asm!</span><span class="p">(</span><span class="s">r#"
.section .text.start
.global _start
     la sp, _stack_start
     call _start_rust
"#</span><span class="p">);</span>

<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">_start_rust</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// UART0.THR = 'A'</span>
        <span class="nn">core</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">write_volatile</span><span class="p">(</span><span class="mi">0x9140_0000</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u32</span><span class="p">,</span> <span class="mi">0x41</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">100000000</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="nd">asm!</span><span class="p">(</span><span class="s">"nop"</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译烧录如上代码, 不出意外, 你会在串口终端看到一串 A 字符. 这说明我们的代码被成功执行了.</p>

<h3 id="访问外设寄存器---pac">访问外设寄存器 - PAC</h3>

<p>Rust 嵌入式访问外设寄存器往往通过 PAC(peripheral access crate) 的方式, 例如 <code class="language-plaintext highlighter-rouge">stm32xxxx-pac</code> crate. 但是由于 K230 是一个较新的芯片, 没有相关的 PAC crate.
同时官方也不太可能提供 SVD 文件供参考. 所这里我选择了 <a href="https://github.com/embassy-rs/chiptool">chiptool</a> 的方式, 使用 <a href="https://github.com/embedded-drivers/yaml2pac">yaml2pac</a> 工具完成 PAC crate 的生成. 手动维护外设寄存器的 YAML 定义.
关于 PAC 的访问, 请参考我 <a href="https://andelf.github.io/2024/08/23/embedded-rust-peripheral-register-access-svdtools-chiptool-and-metapac-approach/">Rust 嵌入式开发中的外设寄存器访问: 从 svd2rust 到 chiptool 和 metapac - 以 hpm-data 为例</a> 一文.</p>

<p>相关 YAML 文件完全可以通过 LLM 协助从 PDF 手册 OCR.</p>

<p>使用 <a href="https://github.com/embedded-drivers/yaml2pac">yaml2pac</a> 工具可以方便地形成我们自己的 PAC 库:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml2pac <span class="nt">-i</span> registers/uart_dw.yaml <span class="nt">-o</span> pac/src/uart_dw.rs
</code></pre></div></div>

<p>然后在 <code class="language-plaintext highlighter-rouge">lib.rs</code> 中添加具体的外设地址定义:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[path</span> <span class="nd">=</span> <span class="s">"uart_dw.rs"</span><span class="nd">]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">uart</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">const</span> <span class="n">UART0</span><span class="p">:</span> <span class="nn">uart</span><span class="p">::</span><span class="n">Uart</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">uart</span><span class="p">::</span><span class="nn">Uart</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="mi">0x9140_0000</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">())</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">UART1</span><span class="p">:</span> <span class="nn">uart</span><span class="p">::</span><span class="n">Uart</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">uart</span><span class="p">::</span><span class="nn">Uart</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="mi">0x9140_1000</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">())</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">UART2</span><span class="p">:</span> <span class="nn">uart</span><span class="p">::</span><span class="n">Uart</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">uart</span><span class="p">::</span><span class="nn">Uart</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="mi">0x9140_2000</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">())</span> <span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">UART3</span><span class="p">:</span> <span class="nn">uart</span><span class="p">::</span><span class="n">Uart</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">uart</span><span class="p">::</span><span class="nn">Uart</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="mi">0x9140_3000</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="p">())</span> <span class="p">};</span>
</code></pre></div></div>

<p>通过简单的封装, 可以方便地访问外设. PAC 的创建和维护在缺乏资料的情况下, 是比较困难的. 但是一旦完成, 可以大大提高开发效率.</p>

<h3 id="方便调试---println-宏">方便调试 - println! 宏</h3>

<p>有了外设寄存器定义, 此时可以编写完整的 UART HAL Driver, 也可以通过简单寄存器访问, 实现一个 <code class="language-plaintext highlighter-rouge">println!</code> 宏.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Console</span><span class="p">;</span>

<span class="k">impl</span> <span class="nn">core</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span> <span class="k">for</span> <span class="n">Console</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">write_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">core</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">pac</span><span class="p">::</span><span class="n">UART0</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">s</span><span class="nf">.as_bytes</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span>
                <span class="k">while</span> <span class="o">!</span><span class="n">UART0</span><span class="nf">.lsr</span><span class="p">()</span><span class="nf">.read</span><span class="p">()</span><span class="nf">.thre</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">asm!</span><span class="p">(</span><span class="s">"nop"</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">UART0</span><span class="nf">.thr</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_thr</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">println</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$arg:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$crate</span><span class="p">::</span><span class="n">Console</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$crate</span><span class="p">::</span><span class="n">Console</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>有了 <code class="language-plaintext highlighter-rouge">println!</code> 宏, 我们可以方便地输出调试信息了! 大大提高了开发效率.</p>

<h2 id="完善初始化代码-complete-initialization-code">完善初始化代码 (Complete Initialization Code)</h2>

<p>目前为止, 我们只初始化了堆栈, 其他必备要素如系统的中断, 乃至 .bss 段都没有初始化. 这些在一个完整的嵌入式程序中都是必顼的.</p>

<p>和 MCU 编程不同的是, MPU 的代码执行是被 Boot ROM 加载到内存中某一区域的, 所以 MCU <code class="language-plaintext highlighter-rouge">start.S</code> 中常见的 .data 区域 copy 是不需要的.
而 .bss 清零则依情况而定, 因为比较简单, 本节略过内存初始化部分.</p>

<h3 id="中断处理函数">中断处理函数</h3>

<p>对于 RISC-V 来说, 中断处理函数是一个特殊的函数. Rust 提供了 <code class="language-plaintext highlighter-rouge">riscv-interrupt-m</code> ABI 专门用于中断处理函数的特殊逻辑.
具体就是增加了中断处理函数的栈帧保存和恢复, 以及使用 <code class="language-plaintext highlighter-rouge">mret</code> 指令替代 <code class="language-plaintext highlighter-rouge">ret</code> 返回.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[link_section</span> <span class="nd">=</span> <span class="s">".trap"</span><span class="nd">]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"riscv-interrupt-m"</span> <span class="k">fn</span> <span class="nf">_start_trap_rust</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"trap!"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">mcause</span> <span class="o">=</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mcause</span><span class="p">::</span><span class="nf">read</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"mstatus: {:016x}"</span><span class="p">,</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mstatus</span><span class="p">::</span><span class="nf">read</span><span class="p">()</span><span class="nf">.bits</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"mcause:  {:016x}"</span><span class="p">,</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mcause</span><span class="p">::</span><span class="nf">read</span><span class="p">()</span><span class="nf">.bits</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"mtval:   {:016x}"</span><span class="p">,</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mtval</span><span class="p">::</span><span class="nf">read</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"mepc:    {:016x}"</span><span class="p">,</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mepc</span><span class="p">::</span><span class="nf">read</span><span class="p">());</span>

    <span class="k">loop</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里打印了一些中断的重要信息, 协助判断中断函数是否被正常调用.</p>

<p>使用 <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> 是为了暴露符号, 我们可以在汇编代码中使用这个符号设置中断处理入口地址.</p>

<p>使用 <code class="language-plaintext highlighter-rouge">#[link_section = ".trap"]</code> 是为了将这个函数放到 <code class="language-plaintext highlighter-rouge">.trap</code> 段, 以便于在链接脚本中处理, 尤其是内存对齐(<code class="language-plaintext highlighter-rouge">ALIGN(8)</code>).
这是写裸机代码常见错误, 因为 mtvec 寄存器的地址必须对齐(低2位由向量处理模式位占用), 否则会导致异常.</p>

<p>暂时我们不需要处理中断, 只需要观察中断是否被触发, 以及观察中断处理函数是否被执行. 所以使用 <code class="language-plaintext highlighter-rouge">loop {}</code>.</p>

<h3 id="中断初始化">中断初始化</h3>

<p>对于 RISC-V 来说, 中断的初始化大概需要如下步骤:</p>

<ul>
  <li>设置 mtvec: 中断处理入口地址</li>
  <li>设置 mstatus 的 MIE 位: 允许中断</li>
  <li>设置 mie 的 MEIE 位: 允许外部中断, 定时器中断等</li>
</ul>

<p>K230 使用了 Xuantie C908 核心, 支持 CLINT 和 PLIC 中断控制器. 相关资料可以从 C908 手册中获得.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">global_asm!</span><span class="p">(</span><span class="s">"
    .option push
    .option norelax
    la gp, __global_pointer$
    .option pop

    la t1, __stack_start__
    addi sp, t1, -16

    // 初始化中断
    la t0, _start_trap_rust
    csrw mtvec, t0

    call _early_init

    // 继续调用 _start_rust
    call _start_rust
"</span><span class="p">);</span>

<span class="nd">#[no_mangle]</span>
<span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">_early_init</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="nn">mstatus</span><span class="p">::</span><span class="nf">set_mie</span><span class="p">();</span> <span class="c1">// enable global interrupt</span>
        <span class="nn">mstatus</span><span class="p">::</span><span class="nf">set_sie</span><span class="p">();</span> <span class="c1">// and supervisor interrupt</span>
        <span class="nn">mie</span><span class="p">::</span><span class="nf">set_mext</span><span class="p">();</span> <span class="c1">// and external interrupt</span>
        <span class="nn">mie</span><span class="p">::</span><span class="nf">set_msoft</span><span class="p">();</span> <span class="c1">// and software interrupt</span>
        <span class="nn">mie</span><span class="p">::</span><span class="nf">set_mtimer</span><span class="p">();</span> <span class="c1">// and timer interrupt</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mstatus</code> 寄存器的 MIE 位用于控制中断使能, mie 寄存器的 MEXT 位用于控制外部中断使能, 即 PLIC, 用来处理外设中断.</p>

<p>这里同时初始化了 gp, 它是一个全局指针寄存器, 用于 Rust 的全局变量访问(在链接脚本中定义的特殊位置).
当然, 在使用内存区域较小较集中的时候, 很可能你不会见到使用 gp 寄存器的指令.</p>

<h3 id="其他-csr-初始化">其他 CSR 初始化</h3>

<p>基于平台不同, 还需要初始化其他硬件, 例如关闭 PMP, 初始化 FPU, 开启 <code class="language-plaintext highlighter-rouge">mcycle</code>, <code class="language-plaintext highlighter-rouge">mtime</code> 计数器等等.
其中 FPU 的初始化是必须的, 否则任意浮点数指令会导致异常. Rust 的 <code class="language-plaintext highlighter-rouge">riscv-interrupt-m</code> 实现不够智能, 无法判断 FPU 的使用情况,
所以当 target 包含 <code class="language-plaintext highlighter-rouge">+f</code>/<code class="language-plaintext highlighter-rouge">+d</code> 时, ABI 会默认使用 FPU 压栈指令.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这里省略平台特定的寄存器初始化部分</span>
<span class="c1">// 包括关闭 PMP</span>
<span class="nd">asm!</span><span class="p">(</span><span class="s">"
    li    t0, 0x00001800
    csrw  mstatus, t0"</span><span class="p">);</span>

<span class="nn">mcounteren</span><span class="p">::</span><span class="nf">set_cy</span><span class="p">();</span> <span class="c1">// enable cycle counter</span>
<span class="nn">mcounteren</span><span class="p">::</span><span class="nf">set_tm</span><span class="p">();</span> <span class="c1">// and time counter</span>

<span class="c1">// FPU init</span>
<span class="nn">mstatus</span><span class="p">::</span><span class="nf">set_fs</span><span class="p">(</span><span class="nn">mstatus</span><span class="p">::</span><span class="nn">FS</span><span class="p">::</span><span class="n">Initial</span><span class="p">);</span>
<span class="nd">asm!</span><span class="p">(</span><span class="s">"csrwi fcsr, 0"</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mstatus</code> 除了中断使能之外, 还负责当前 CPU 的运行模式, 例如 M/S/U 模式.</p>

<p>有了系统的 <code class="language-plaintext highlighter-rouge">mcycle</code> CSR, 就可以方便地使用 <code class="language-plaintext highlighter-rouge">embedded-hal</code> 生态中的 <code class="language-plaintext highlighter-rouge">Delay</code> trait, 实现较为精确的延时, 告别 <code class="language-plaintext highlighter-rouge">nop</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">CPU0_CORE_CLK</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">800_000_000</span><span class="p">;</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">delay</span> <span class="o">=</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">delay</span><span class="p">::</span><span class="nn">McycleDelay</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">CPU0_CORE_CLK</span><span class="p">);</span>
<span class="n">delay</span><span class="nf">.delay_ms</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="验证中断处理">验证中断处理</h3>

<p>我们可以通过直接触发软件中断的方式, 来验证中断处理函数是否被执行. K230 的 CLINT 中断控制器可以通过 <code class="language-plaintext highlighter-rouge">msip</code> 寄存器触发软件中断.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">pac</span><span class="p">::</span><span class="n">CLINT</span><span class="nf">.msip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_msip</span><span class="p">(</span><span class="k">true</span><span class="p">));</span> <span class="c1">// trigger software interrupt</span>
</code></pre></div></div>

<p>修改中断处理函数 <code class="language-plaintext highlighter-rouge">_start_trap_rust</code> 增加返回:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="n">mcause</span><span class="nf">.is_interrupt</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">mcause</span><span class="nf">.code</span><span class="p">()</span> <span class="o">==</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">interrupt</span><span class="p">::</span><span class="nn">Interrupt</span><span class="p">::</span><span class="n">MachineSoft</span> <span class="k">as</span> <span class="n">_</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Machine Software Interrupt"</span><span class="p">);</span>
        <span class="nn">pac</span><span class="p">::</span><span class="n">CLINT</span><span class="nf">.msip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_msip</span><span class="p">(</span><span class="k">false</span><span class="p">));</span> <span class="c1">// clear software interrupt</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>使用 <code class="language-plaintext highlighter-rouge">mtime</code>, <code class="language-plaintext highlighter-rouge">mtimecmp</code> CSR 也可以验证定时器中断. 但我在使用中发现一个坑,
K230 的 <code class="language-plaintext highlighter-rouge">CLINT</code> 的 <code class="language-plaintext highlighter-rouge">mtime</code> 无法通过 64 位 load 指令读取, 读出内容随机. 不抛出任何异常.
这导致 64 位的 <code class="language-plaintext highlighter-rouge">mtime</code> 必须通过两次 32 位读取, 然后组合成 64 位.
只有 <code class="language-plaintext highlighter-rouge">rdtime</code> 指令可以一次读取 64 位 <code class="language-plaintext highlighter-rouge">mtime</code>.</p>

<h3 id="ddr-init">DDR init</h3>

<p>DDR init / (SDRAM 初始化) 是一个比较复杂的过程, 一般需要初始化时钟, 复位控制器, PHY 训练, 芯片初始化, 时序配置, 自检等等.
这些内容往往都是厂商直接提供, 在相关的 DDR 初始化代码中, 相关寄存器写入流程也是如同天书一般.</p>

<p>所以 DDR init 代码直接通过 LLM 从 C 翻译. 不做额外解释. DDR 芯片不同, DDR init 代码也是不同的.</p>

<p>DDR init 之后, 我们就可以使用 DDR 区域的内存. 这里有一个需要注意的地方是, DDR 内存起始地址是 0x0000_0000,
然而 Rust 访问零地址有诸多限制, 多数函数会直接 panic. 程序中应该避免使用 0x0000_0000 地址.</p>

<h2 id="正式开始裸机编程-start-real-bare-metal-programming">正式开始裸机编程 (Start Real Bare-Metal Programming)</h2>

<p>有了以上的初始化基础, 我们终于可以开始正式的裸机编程了. 例如初始化其他外设, 读写外设寄存器, 甚至是实现一些简单的功能.</p>

<p>这里以两个外设为例简单展示. 相关的外设寄存器定义我已经写好在 <a href="https://github.com/andelf/k230-bare-metal">k230-bare-metal</a> 仓库中.</p>

<h3 id="gpio-点灯">GPIO 点灯</h3>

<p>无论 MCU 还是 MPU, GPIO 点灯的步骤都是类似的:</p>

<ul>
  <li>使能(或复位) GPIO 外设时钟, 电源</li>
  <li>设置引脚功能复用, 引脚模式</li>
  <li>GPIO write</li>
</ul>

<p>K230 默认情况下外设的时钟和电源信号都是开启的(检查相关寄存器可以确认). 所以我们只需要通过 IOMUX 设置复用功能, 通过 GPIO 外设设置好引脚模式即可.
相关的功能可以参考官方文档, 引脚复用的文档位于 <code class="language-plaintext highlighter-rouge">K230_PINOUT_V*.xlsx</code>.</p>

<p>IOMUX 外设是一个类似 PAD 的结构, 每个引脚通过一个 32 位寄存器设置复用功能, 上拉下拉, 输入输出使能等. 这部分定义我是通过 .dtsi 文件和 C 头文件获得,
也是交给 LLM 来转译成 YAML 定义. <code class="language-plaintext highlighter-rouge">IOMUX.pad(n).set_sel(0)</code> 即将引脚的模式设置为对应的 GPIO.</p>

<p>GPIO 外设来自 <a href="https://www.synopsys.com/dw/ipdir.php?c=DW_apb_gpio">DW_apb_gpio</a>, 熟悉 Verilog 等 HDL 的朋友一看文档就知道这个是一个最多
4 端口的可配置 GPIO IP Core. 有若干配置寄存器可以获取外设的初始参数:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GPIO0 config_reg1: num_ports=1
GPIO0 config_reg2: len(PA)=32
GPIO1 config_reg1: num_ports=2
GPIO1 config_reg2: len(PA)=32 len(PB)=8
</code></pre></div></div>

<p>一共 32 + 32 + 8 = 72 个引脚. 分两个 GPIO 控制器, 其中 GPIO1 控制器有两个 PORT. 可以完美适配 chiptool cluster/array 的定义方法.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">blinky</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// RGB LED of LCKFB</span>
    <span class="c1">// - R: GPIO62</span>
    <span class="c1">// - G: GPIO20</span>
    <span class="c1">// - B: GPIO63</span>
    <span class="k">use</span> <span class="nn">pac</span><span class="p">::{</span><span class="n">GPIO0</span><span class="p">,</span> <span class="n">GPIO1</span><span class="p">,</span> <span class="n">IOMUX</span><span class="p">};</span>

    <span class="n">IOMUX</span><span class="nf">.pad</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_sel</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// function = GPIOx</span>
    <span class="n">IOMUX</span><span class="nf">.pad</span><span class="p">(</span><span class="mi">62</span><span class="p">)</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_sel</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">IOMUX</span><span class="nf">.pad</span><span class="p">(</span><span class="mi">63</span><span class="p">)</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_sel</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

    <span class="n">GPIO0</span><span class="nf">.swport</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.ddr</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// output mode</span>
    <span class="n">GPIO1</span><span class="nf">.swport</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.ddr</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
    <span class="n">GPIO1</span><span class="nf">.swport</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.ddr</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="n">GPIO0</span><span class="nf">.swport</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.dr</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// toggle data</span>
        <span class="c1">// GPIO1.swport(0).dr().modify(|w| *w ^= 1 &lt;&lt; 30);</span>
        <span class="n">GPIO1</span><span class="nf">.swport</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.dr</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">);</span>

        <span class="nn">riscv</span><span class="p">::</span><span class="nn">delay</span><span class="p">::</span><span class="nn">McycleDelay</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">CPU0_CORE_CLK</span><span class="p">)</span><span class="nf">.delay_ms</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pwm-蜂鸣器">PWM 蜂鸣器</h3>

<p>K230 有 6 个 PWM 输出, 分两个 PWM 控制器. 每个控制器内部是 3 个 PWM 输出通道. 1 个额外的通道 0 负责配置 Reload.
庐山派开发板上的蜂鸣器是通过 PWM1 GPIO43 控制的. PWM 外设的输入时钟是 100MHz, 通过 PWMCFG.SCALE 设置 2^n 分频.</p>

<p>为了使蜂鸣器达到人耳可识别的频率, 一般 PWM 的频率设置在 1KHz 左右. 通过 PWMCFG.SCALE 和 PWMx.CMP 设置周期和占空比.
相关代码如下, 寄存器值计算请参考注释</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">buzzer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// GPIO43 - PWM1</span>
    <span class="k">use</span> <span class="nn">pac</span><span class="p">::{</span><span class="n">IOMUX</span><span class="p">,</span> <span class="n">PWM0</span><span class="p">};</span>

    <span class="c1">// PCLK, PWM use APB clock to program registers as well as to generate waveforms. The default frequency is 100MHz.</span>
    <span class="n">IOMUX</span><span class="nf">.pad</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">w</span><span class="nf">.set_sel</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// PWM = 2</span>
        <span class="n">w</span><span class="nf">.set_oe</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
        <span class="n">w</span><span class="nf">.set_ds</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// Calc:</span>
    <span class="c1">// scale = 2</span>
    <span class="c1">// period = 0x5000</span>
    <span class="c1">// freq = 100_000_000 / (1 &lt;&lt; 2) / 0x5000  = 1220.7 Hz</span>
    <span class="c1">// duty = period / 2 = 0x2800</span>
    <span class="n">PWM0</span><span class="nf">.pwmcfg</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">w</span><span class="nf">.set_zerocomp</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
        <span class="n">w</span><span class="nf">.set_scale</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="n">PWM0</span><span class="nf">.pwmcmp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="na">.0</span> <span class="o">=</span> <span class="mi">0x5000</span><span class="p">);</span> <span class="c1">// PWMCMP0: RELOAD</span>
    <span class="k">let</span> <span class="n">duty</span> <span class="o">=</span> <span class="mi">0x2800</span><span class="p">;</span>

    <span class="n">PWM0</span><span class="nf">.pwmcmp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="na">.0</span> <span class="o">=</span> <span class="n">duty</span><span class="p">);</span> <span class="c1">// PWMCMP2: PWM1</span>

    <span class="c1">// enable</span>
    <span class="n">PWM0</span><span class="nf">.pwmcfg</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_enalways</span><span class="p">(</span><span class="k">true</span><span class="p">));</span>
    <span class="nn">riscv</span><span class="p">::</span><span class="nn">delay</span><span class="p">::</span><span class="nn">McycleDelay</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">CPU0_CORE_CLK</span><span class="p">)</span><span class="nf">.delay_ms</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

    <span class="c1">// disable</span>
    <span class="n">PWM0</span><span class="nf">.pwmcfg</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_enalways</span><span class="p">(</span><span class="k">false</span><span class="p">));</span>
    <span class="nn">riscv</span><span class="p">::</span><span class="nn">delay</span><span class="p">::</span><span class="nn">McycleDelay</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">CPU0_CORE_CLK</span><span class="p">)</span><span class="nf">.delay_ms</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="一些延展思考-some-extended-thoughts">一些延展思考 (Some Extended Thoughts)</h2>

<h3 id="why-裸机">Why 裸机?</h3>

<p>裸机编程是嵌入式开发的基础, 也是最底层的开发方式. 通过裸机编程, 我们可以更好地理解硬件的工作原理, 以及操作系统的底层.
用遍全天下的库和 SDK, 不如自己写一个, 通一则通百.</p>

<h3 id="shell">SHELL?</h3>

<p>在裸机环境下, 由于没有操作系统, 没有标准输入输出, 也没有文件系统, 完整的 SHELL 是不可能的. 但是我们可以通过串口, 实现简单的命令行交互.
所需要的只是两个串口函数 <code class="language-plaintext highlighter-rouge">putchar</code> 和 <code class="language-plaintext highlighter-rouge">getchar</code>, 以及一个简单的解析器.</p>

<p><a href="https://docs.rs/noline/latest/noline/">noline</a> 是一个小巧的 no_std line-editing crate, 可以用于实现简单的命令行交互. 而且它基于 embedded-hal 生态, 可以方便地移植.
支持行历史和常见快捷键. 当然, 从头手写一个 readline 也是一个不错的练习.</p>

<p>通过实现若干 shell 命令, 我们可以实现简单的交互, 例如读写外设寄存器, 读写内存, 打印系统信息等等.</p>

<p>相关实现可以参考 <a href="https://github.com/andelf/k230-bare-metal">k230-bare-metal</a> 仓库. 最终效果如下:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>K230&gt; <span class="nb">help
</span>Available commands:
  <span class="nb">help</span> - print this <span class="nb">help
  echo</span> &lt;text&gt; - print &lt;text&gt;
  reboot - reboot the system
  mem_read &lt;address&gt; &lt;length&gt; - <span class="nb">read </span>memory
  mem_write &lt;address&gt; &lt;u32&gt; - write memory
  tsensor - <span class="nb">read </span>temperature sensor
  cpuid - print CPUID
  serialboot - enter serial boot mode
  jump &lt;address&gt; - jump to address
  jumpbig &lt;address&gt; - jump to big core and run
</code></pre></div></div>

<h3 id="download">Download?</h3>

<p>K230 的定位其实更像是 SBC(单板计算机), 烧录固件往往通过 TF 卡, 在裸机开发中极为不便, 持续插拔 TF 卡会导致接触不良, 甚至损坏.</p>

<p>联想到 <a href="https://github.com/enjoy-digital/litex">LiteX</a> 为 FPGA 软核环境提供了非常方便的 kernel/firmware 加载方式, 通过串口下载固件到某一内存位置(DDR), 甚至可以通过网络下载固件.
我尝试移植了 <code class="language-plaintext highlighter-rouge">litex_term</code> 的 UART 下载逻辑. 它内置了一个串口下载协议和串口命令行, 在检测到特殊字符串后,
自动切入下载模式, 通过串口下载固件到指定内存位置, 并跳转执行.</p>

<p>最终的效果是:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>litex_term /dev/tty.usbmodem56C40035621 <span class="nt">--kernel-adr</span> 0x01000000 <span class="nt">--kernel</span> ../firmware.img
<span class="c">......
</span><span class="go">Press Q or ESC to abort boot completely.
sL5DdSMmkekro
[LITEX-TERM] Received firmware download request from the device.
[LITEX-TERM] Uploading ../firmware.img to 0x01000000 (17400 bytes)...
[LITEX-TERM] Upload calibration... failed, switching to --safe mode.
[LITEX-TERM] Upload complete (8.7KB/s).
[LITEX-TERM] Booting the device.
[LITEX-TERM] Done.
Jumping to 0x01000000...
</span></code></pre></div></div>

<p>非常方便, 有机会单独额外介绍. 需要注意对内存区域写入固件需要处理 I-Cache 和 D-Cache 的状态, 本文编写时我选择彻底关闭 I-Cache 和 D-Cache.</p>

<h3 id="跳转大核">跳转大核</h3>

<p>前面说道, CPU1(大核) 的启动是由 CPU0(小核) 控制的. 具体启动逻辑也很简单, 设置复位向量并复位 CPU1 即可:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">write_volatile</span><span class="p">(</span><span class="mi">0x91102104</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">jump_addr</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">);</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">write_volatile</span><span class="p">(</span><span class="mi">0x9110100c</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u32</span><span class="p">,</span> <span class="mi">0x10001000</span><span class="p">);</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">write_volatile</span><span class="p">(</span><span class="mi">0x9110100c</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u32</span><span class="p">,</span> <span class="mi">0x10001</span><span class="p">);</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">write_volatile</span><span class="p">(</span><span class="mi">0x9110100c</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u32</span><span class="p">,</span> <span class="mi">0x10000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了方便开发测试, 我把跳转大核也做成了 SHELL 命令. 通过 UART0 输入 <code class="language-plaintext highlighter-rouge">jumpbig 0x01000000</code> 即可跳转大核执行内存区域代码.
尝试 dump 大核寄存器信息, 可以看到启动信息:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rust 2nd stage on CPU1
mstatus: 0000000a00001900
mie: 0000000000000000
mip: 0000000000000000
misa: 8000000000b4112f
  RV64ABCDFIMSUVX
mvendorid: 5b7
marchid: 8000000009140d00
mhartid: 0
cpuid: 09140b0d 10050000 260c0001
</code></pre></div></div>

<p>这里 <code class="language-plaintext highlighter-rouge">RV64ABCDFIMSUVX</code> 中的 <code class="language-plaintext highlighter-rouge">V</code> 表示支持 RVV 向量指令集, K230 是异构双核, 小核不支持 RVV. 可以证明我们的代码成功跳转到了大核.</p>

<p>当然有个有意思的地方, <code class="language-plaintext highlighter-rouge">mhartid</code> 是 0, 说明 K230 并没有满足 RISC-V 规范给不同的 hart 分配不同的 ID. 这个在实际开发中是需要注意的.
只能通过 misc CSR 来区分不同的 hart. 也是 K230 的一个小坑.</p>

<p>接下来就可以在大核上进行更复杂的操作, 例如 RVV 向量指令的应用等等.</p>

<h2 id="结语-conclusion">结语 (Conclusion)</h2>

<p>通过此次在 K230 芯片上的 Rust 裸机嵌入式开发, 我们深入探索了 MPU 与 MCU 在启动方式和使用模式上的区别, 掌握了使用 Rust 进行 MPU 芯片裸机开发的关键步骤,
包括启动流程、固件格式解析、中断和外设的初始化等。实践中, 我们成功实现了 UART 调试输出、GPIO 点灯、PWM 蜂鸣器等功能,
加深了对 K230 底层启动机制和硬件特性的理解。这些成果为日后在 K230 以及其他 RISC-V 芯片上开展更复杂的嵌入式开发奠定了坚实的基础。
展望未来, 我们可以进一步完善外设驱动, 探索多核协同工作、RVV 向量指令的应用, 以及结合 Rust 生态构建高效、
安全的嵌入式系统, 为 RISC-V 开源社区贡献更多力量。(由 GPT 总结)</p>

<h3 id="tips">Tips</h3>

<ul>
  <li>Boot ROM 对于非法执行情况有异常报错, 可以用这种报错行为反向验证代码是否被执行, 例如插入非法指令查看报错位置的 pc</li>
  <li>裸机代码最好避免使用完整 target feature, 避免编译器生成还未使能的指令特性, 例如 V 扩展</li>
  <li>D-Cache 和 I-Cache 的状态需要处理, 一般在跳转到新代码前关闭, 以避免缓存不一致</li>
  <li><code class="language-plaintext highlighter-rouge">println!</code> 宏可以方便地输出调试信息, 但是需要注意, 打印是阻塞的, 影响时间敏感的操作</li>
  <li>学会使用 LLM 协助自己的探索过程, 例如从 PDF 手册 OCR 导出 YAML 定义, DDR init 代码的翻译, 以及对于特定寄存器的解释</li>
  <li>Boot ROM 会初始化一些外设, 例如 UART0, 但具体状态还需要再次验证, 例如 FIFO 模式, 波特率等</li>
  <li>对于可能的硬件实现 BUG 或特异性, 可以尝试使用等价的多种方法</li>
</ul>]]></content><author><name>猫·仁波切</name></author><category term="embedded" /><category term="rust" /><category term="risc-v" /><summary type="html"><![CDATA[难度: 中等, 读者应具备嵌入式系统基础知识和 Rust 嵌入式开发基础]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://andelf.github.io/assets/k230-boards.jpg" /><media:content medium="image" url="https://andelf.github.io/assets/k230-boards.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rust 嵌入式开发中的外设寄存器访问：从 svd2rust 到 chiptool 和 metapac - 以 hpm-data 为例</title><link href="https://andelf.github.io/2024/08/23/embedded-rust-peripheral-register-access-svdtools-chiptool-and-metapac-approach/" rel="alternate" type="text/html" title="Rust 嵌入式开发中的外设寄存器访问：从 svd2rust 到 chiptool 和 metapac - 以 hpm-data 为例" /><published>2024-08-23T01:51:00+00:00</published><updated>2024-11-14T00:27:37+00:00</updated><id>https://andelf.github.io/2024/08/23/embedded-rust-peripheral-register-access-svdtools-chiptool-and-metapac-approach</id><content type="html" xml:base="https://andelf.github.io/2024/08/23/embedded-rust-peripheral-register-access-svdtools-chiptool-and-metapac-approach/"><![CDATA[<p>Embedded Rust Peripheral Register Access: svd2rust, chiptool and metapac Approach.</p>

<p>本文是基础向文章, 介绍了 Rust 嵌入式开发中的外设寄存器访问问题，以及社区提供的解决方案。包括以下内容:</p>

<ul>
  <li>简短历史回顾</li>
  <li><a href="https://github.com/rust-embedded/svd2rust">svd2rust</a> + <a href="https://github.com/rust-embedded/svdtools">svdtools</a> 工作流</li>
  <li>介绍 <a href="https://embassy.dev/">Embassy</a> 框架中 stm32-metapac 所使用的 <a href="https://github.com/embassy-rs/chiptool">chiptool</a></li>
  <li>metapac 的设计与实现 - 以 <a href="https://github.com/andelf/hpm-data">hpm-data</a> 和 <a href="https://github.com/hpmicro-rs/hpm-metapac">hpm-metadata</a> 为例</li>
  <li>额外内容: pac 库的其他内容</li>
</ul>

<h2 id="背景">背景</h2>

<p>在嵌入式开发中，我们经常需要访问系统外设寄存器，以配置外设的工作模式、读取传感器数据等。在 C 中, 我们通常使用宏定义和来访问外设寄存器，例如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">ADC16_CONFIG0</span><span class="p">;</span>
<span class="n">temp</span> <span class="o">|=</span> <span class="n">ADC16_ADC16_CONFIG0_REG_EN_MASK</span>
         <span class="o">|</span>  <span class="n">ADC16_ADC16_CONFIG0_BANDGAP_EN_MASK</span>
         <span class="o">|</span>  <span class="n">ADC16_ADC16_CONFIG0_CAL_AVG_CFG_MASK</span>
         <span class="o">|</span>  <span class="n">ADC16_ADC16_CONFIG0_CONV_PARAM_SET</span><span class="p">(</span><span class="n">param32</span><span class="p">)</span>
<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">ADC16_CONFIG0</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">ptr</code> 类型为 <code class="language-plaintext highlighter-rouge">ADC_Type *</code>，<code class="language-plaintext highlighter-rouge">ADC_Type</code> 是一个结构体，包含了 ADC 模块的所有寄存器字段, 按照相应内存布局一一映射。字段往往定义为 <code class="language-plaintext highlighter-rouge">volatile</code> 类型，以确保编译器不会对其进行优化。</p>

<p>更原始的, 比如在 8051 等单片机上, 往往直接通过内存地址来访问外设寄存器或 SFR, 例如:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ADC16_CONFIG0 (*(volatile uint32_t *)0x4000_0000)
</span><span class="kt">uint32_t</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">ADC16_CONFIG0</span><span class="p">;</span>
<span class="n">temp</span> <span class="o">|=</span> <span class="n">ADC16_ADC16_CONFIG0_REG_EN_MASK</span>
         <span class="o">|</span>  <span class="n">ADC16_ADC16_CONFIG0_BANDGAP_EN_MASK</span>
         <span class="o">|</span>  <span class="n">ADC16_ADC16_CONFIG0_CAL_AVG_CFG_MASK</span>
         <span class="o">|</span>  <span class="n">ADC16_ADC16_CONFIG0_CONV_PARAM_SET</span><span class="p">(</span><span class="n">param32</span><span class="p">)</span>
<span class="n">ADC16_CONFIG0</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</code></pre></div></div>

<p>虽然这种方式简单直接，但是不够安全，容易出现错误。例如，当字段名误用时，编译器往往不会报错，而是直接生成错误的代码。另外，当字段的位宽和偏移写错时，也会导致错误的配置.
对于嵌入式环境来说, 更难以调试. 究其原因, 一是因为 C 语言中的宏是朴素的文本替换, 缺乏类型检查, 二是因为 C 语言中的类型系统较弱, 隐式类型转换较多. 另外还有历史原因, C 语言中的指针操作较为灵活, 这种 <code class="language-plaintext highlighter-rouge">struct</code> + 宏定义的方式在各大芯片厂商的 SDK/HAL/LL 中被广泛使用.</p>

<p>在 Rust 中，我们同样可以通过类似的直接操作内存地址映射的方式访问外设寄存器。这种方式的优点是速度快，但缺点是不够安全，容易出现错误。为了解决这个问题，社区提供了 <a href="https://github.com/rust-embedded/svd2rust">svd2rust</a> 或 <a href="https://github.com/embassy-rs/chiptool">chiptool</a> 等工具工具来生成类型安全的外设寄存器访问代码.</p>

<h2 id="由来">由来</h2>

<p>这里会绍一个虚拟的发展历程, 可能并不代表真实的历史发展过程, 也不代表新方案完全替换了旧方案.</p>

<h3 id="源起---unsafe--volatile-memory-access">源起 - unsafe &amp; volatile memory access</h3>

<p>在 Rust 中，我们可以通过 <code class="language-plaintext highlighter-rouge">unsafe</code> 代码块和 <code class="language-plaintext highlighter-rouge">ptr::read_volatile</code>、<code class="language-plaintext highlighter-rouge">ptr::write_volatile</code> 等函数来访问外设寄存器。例如：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0x4000_0000</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u32</span><span class="p">;</span>
<span class="k">unsafe</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="nn">ptr</span><span class="p">::</span><span class="nf">read_volatile</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="nn">ptr</span><span class="p">::</span><span class="nf">write_volatile</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">temp</span> <span class="p">|</span> <span class="mi">0x1234</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种方式的优点是简单直接，但缺点是不够安全，且需要依靠开发者本身的经验和代码命名规范来确保字段, SET, MASK 等的正确性. 直觉上, 就是在 Rust 中写 C 的 feel.</p>

<h3 id="memory-mapped-register-io---mmio">Memory Mapped Register IO - MMIO</h3>

<p>和上文提到的 C 结构体类似, Rust 中也可以定义类似的结构体来映射外设寄存器。例如：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">ADC</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">config0</span><span class="p">:</span> <span class="n">Config0</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">config1</span><span class="p">:</span> <span class="n">Config1</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">adc</span> <span class="o">=</span> <span class="mi">0x4000_0000</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">ADC</span><span class="p">;</span>
<span class="k">unsafe</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rb</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">adc</span> <span class="p">};</span>
    <span class="c1">// calling method or write to `rb.config0`</span>
<span class="p">}</span>
</code></pre></div></div>

<p>和 C 不同的是, Rust 缺乏 bitfield 的语法糖, 也就是说, Rust 中的结构体字段访问无法直接精确到 bit, 至少也是 <code class="language-plaintext highlighter-rouge">u8</code>. 但这并不妨碍 Rust 社区创建各种好用的第三方 crate, 例如
<a href="https://docs.rs/bitfield">bitfield</a>, <a href="https://crates.io/crates/bit_field">bit_field</a> 等. 通过直接使用 bitfield 作为字段类型, 可以更加直观的访问寄存器字段. 同时还有 <a href="https://crates.io/crates/bitflags">bitflags</a> 等 crate 提供类似 C 中标志位操作的功能.</p>

<p>这种方式的安全性有所保证，也一定程度上支持 C 样式的代码直接翻译. 但缺点是需要手动定义结构体和字段类型, 工程量大, 且容易出错.</p>

<p>另外在实际使用中, 还需要处理 <code class="language-plaintext highlighter-rouge">volatile</code> 的问题. 避免编译器优化掉对寄存器的访问.</p>

<h2 id="svd2rust">svd2rust</h2>

<p><a href="https://github.com/rust-embedded/svd2rust">svd2rust</a> 是一个由 Rust 社区提供的工具，用于将 SVD 文件转换为 Rust 代码。SVD 文件是一种 XML 格式的文件，用于描述芯片的外设寄存器。svd2rust 会根据 SVD 文件生成一个 Rust 模块(<code class="language-plaintext highlighter-rouge">xxx-pac</code>)，包含了芯片的所有外设寄存器的访问代码. 具体来说就是</p>

<ul>
  <li>每个外设映射为一个 <code class="language-plaintext highlighter-rouge">periph::RegisterBlock</code> 结构体提供寄存器访问</li>
  <li>每个寄存器字定义为一个 RegisterBlock 的字段(或成员函数), 通过 <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">write</code>, <code class="language-plaintext highlighter-rouge">modify</code> 方法来访问: “read proxy” and “write proxy”</li>
  <li>单个寄存器被定义为类似 bitfield 的结构体</li>
  <li>寄存器位的访问被分为 <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">write</code>, <code class="language-plaintext highlighter-rouge">modify</code> 方法, 其中 <code class="language-plaintext highlighter-rouge">write</code>, <code class="language-plaintext highlighter-rouge">modify</code> 通过闭包来传递具体的操作</li>
</ul>

<h3 id="svd2rust-寄存器访问示例">svd2rust 寄存器访问示例</h3>

<p>早期 svd2rust 实现直接使用了 MMIO struct 的方式, 生成的代码例如:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[doc</span> <span class="nd">=</span> <span class="s">r"ADC Register block"</span><span class="nd">]</span>
<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RegisterBlock</span> <span class="p">{</span>
    <span class="nd">#[doc</span> <span class="nd">=</span> <span class="s">"0x00 - status register"</span><span class="nd">]</span>
    <span class="k">pub</span> <span class="n">stat</span><span class="p">:</span> <span class="n">STAT</span><span class="p">,</span>
    <span class="nd">#[doc</span> <span class="nd">=</span> <span class="s">"0x04 - control register 0"</span><span class="nd">]</span>
    <span class="k">pub</span> <span class="n">ctl0</span><span class="p">:</span> <span class="n">CTL0</span><span class="p">,</span>
    <span class="nd">#[doc</span> <span class="nd">=</span> <span class="s">"0x08 - control register 1"</span><span class="nd">]</span>
    <span class="k">pub</span> <span class="n">ctl1</span><span class="p">:</span> <span class="n">CTL1</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>访问时使用:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rb</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nn">pac</span><span class="p">::</span><span class="nn">ADC0</span><span class="p">::</span><span class="n">PTR</span> <span class="p">};</span> <span class="c1">// `pac` 是生成的模块</span>

<span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="n">rb</span><span class="py">.stat</span><span class="nf">.read</span><span class="p">()</span><span class="nf">.adc_stat</span><span class="p">()</span><span class="nf">.bits</span><span class="p">();</span>
<span class="n">rb</span><span class="py">.ctl0</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.adc_en</span><span class="p">()</span><span class="nf">.set_bit</span><span class="p">()</span><span class="nf">.adc_start</span><span class="p">()</span><span class="nf">.set_bit</span><span class="p">());</span>
<span class="n">rb</span><span class="py">.ctl0</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">_r</span><span class="p">,</span> <span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.adc_en</span><span class="p">()</span><span class="nf">.clear_bit</span><span class="p">());</span>
</code></pre></div></div>

<p>后来 svd2rust 在一次更新后, 将所有字段的 <code class="language-plaintext highlighter-rouge">pub</code> 属性去掉, 转而使用 const fn 来访问寄存器字段. 例如:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">///Register block</span>
<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RegisterBlock</span> <span class="p">{</span>
    <span class="n">statr</span><span class="p">:</span> <span class="n">STATR</span><span class="p">,</span>
    <span class="n">ctlr1</span><span class="p">:</span> <span class="n">CTLR1</span><span class="p">,</span>
    <span class="n">ctlr2</span><span class="p">:</span> <span class="n">CTLR2</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">RegisterBlock</span> <span class="p">{</span>
    <span class="cd">///0x00 - status register</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">statr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">STATR</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.statr</span>
    <span class="p">}</span>
    <span class="cd">///0x04 - control register 1/TKEY_V_CTLR</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">ctlr1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">CTLR1</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="py">.ctlr1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>访问时使用:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rb</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nn">pac</span><span class="p">::</span><span class="nn">ADC0</span><span class="p">::</span><span class="nf">ptr</span><span class="p">()</span> <span class="p">};</span> <span class="c1">// `pac` 是生成的模块</span>

<span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="n">rb</span><span class="py">.statr</span><span class="nf">.read</span><span class="p">()</span><span class="nf">.adc_stat</span><span class="p">()</span><span class="nf">.bits</span><span class="p">();</span>
<span class="k">let</span> <span class="n">flag_val</span> <span class="o">=</span> <span class="n">rb</span><span class="nf">.adc_stat</span><span class="p">()</span><span class="nf">.read</span><span class="p">()</span><span class="nf">.status</span><span class="p">()</span><span class="nf">.bit_is_set</span><span class="p">();</span>
<span class="n">rb</span><span class="nf">.ctlr1</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.adc_en</span><span class="p">()</span><span class="nf">.set_bit</span><span class="p">()</span><span class="nf">.adc_start</span><span class="p">()</span><span class="nf">.set_bit</span><span class="p">());</span>
<span class="n">rb</span><span class="nf">.ctlr1</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">_r</span><span class="p">,</span> <span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.adc_en</span><span class="p">()</span><span class="nf">.clear_bit</span><span class="p">());</span>
</code></pre></div></div>

<p>这样做的好处是更好地隐藏了寄存器字段的具体实现，在嵌入式 Rust 中往往会大量使用 <code class="language-plaintext highlighter-rouge">unsafe</code>, 其中缺乏必要的检查, 通过隐藏字段的具体实现, 可以减少错误的发生.
同时, 通过 const fn 提供的字段访问, 可以很好地支持 “内存重叠字段”, 例如在 USB 外设中, 不同模式下, 同一个寄存器地址的字段可能有不同的含义, 通过 const fn 可以很好地支持这种情况.</p>

<h3 id="使用-svd2rust-生成-pac-库">使用 svd2rust 生成 pac 库</h3>

<p>svd2rust 工具可以通过简单的命令行调用来生成 pac 库. 直接 <code class="language-plaintext highlighter-rouge">cargo install</code> 即可安装.</p>

<p>但实际使用过程中, 往往有很多的额外工作, 例如:</p>

<p><strong>去哪里寻找 SVD 文件?</strong></p>

<p>大部分情况下 SVD 文件可以从芯片的 CMSIS pack, 芯片厂商的 SDK 中找到. 去芯片厂商的网站翻一翻也许能找到.
SVD 文件为 IDE 的调试功能提供了外设寄存器视图, 所以在对应的 IDE 或 IDE 扩展中也能找到.
同时, 直接联系厂商, 也许能得到帮助.</p>

<p>比如:</p>

<ul>
  <li>常见的 Cortex-M MCU 一般会提供 <a href="https://www.keil.arm.com/packs/">CMSIS packs</a>, 可以搜索芯片型号下载</li>
  <li>CH32/GD32 等国产芯片的 SVD 文件可以在 <a href="http://www.mounriver.com/download">MounRiver Studio</a> IDE 的安装目录找到</li>
  <li>HPMicro MCU 的 SVD 文件, 在官方 <a href="https://github.com/hpmicro/hpm_sdk/">hpm_sdk</a></li>
</ul>

<p><strong>SVD 文件的质量如何?</strong></p>

<p>SVD 文件往往由芯片厂商提供, 有些是由社区维护的, 质量参差不齐, 经常能见到格式报错, 字段错误等问题.
直接使用 svd2rust 工具执行转换也会提示报错信息, 当错误不够直观时候, 可以通过 <code class="language-plaintext highlighter-rouge">xmllint</code> 工具检查:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xmllint <span class="nt">--schema</span> svd/CMSIS-SVD.xsd <span class="nt">--noout</span> XX32XXX.svd
</code></pre></div></div>

<p>同时 <a href="https://github.com/rust-embedded/svdtools">svdtools</a> 提供一套基于 YAML 格式的 SVD patch 工具, 可以用来修复 SVD 文件中的错误, 修改字段, 新增外设等等.</p>

<p>对于 <a href="https://github.com/rust-embedded/svdtools">svdtools</a> 补丁工作流的使用, 可以参考 <a href="https://github.com/stm32-rs/stm32-rs">stm32-rs</a>, 或者规模较小的 <a href="https://github.com/ch32-rs/ch32-rs">ch32-rs</a>. 基本思路是拿到官方 SVD -&gt;
修正格式错误(这个没得洗, 毕竟 xml 库都读不进去的话没有办法处理) -&gt; 创建 patch 文件 -&gt; svdtools apply -&gt; patch 后的 SVD 文件 -&gt; svd2rust -&gt; pac.</p>

<p><strong>SVD 文件的版权问题?</strong></p>

<p>SVD 文件往往是芯片厂商提供的, 有些芯片厂商会在 SVD 文件或对应下载包中加入版权信息, 有些则没有. 一般来说, 用于开发者开发软件, 一般不会有问题,
但考虑到 pac 库发布需要, 最好联系芯片厂商, 以确认是否可以使用, 以及是否可以把 SVD 源文件包含在 pac 库中.</p>

<p><strong>找不到 SVD 文件怎么办?</strong></p>

<p>如果厂商没有提供 SVD 文件, 也可以通过手动编写 SVD 文件, 但这需要对芯片的外设寄存器有一定的了解, 以及对 SVD 文件格式有一定的了解.
一般来说, 从芯片手册中可以找到寄存器的描述, 以及寄存器地址, 位宽等信息.</p>

<p>直接以 YAML 格式编写 SVD 文件, 也是一种选择, 请参考 <a href="https://github.com/rust-embedded/svdtools">svdtools</a> 的文档.</p>

<h2 id="chiptool">chiptool</h2>

<p><a href="https://github.com/embassy-rs/chiptool">chiptool</a> 是一个由 <a href="https://embassy.dev/">Embassy</a> 社区提供的工具，用于生成 Rust 外设寄存器访问代码, 主要用于 <a href="https://github.com/embassy-rs/stm32-data">stm32-data</a>, 为 Embassy 框架提供 STM32 所有 MCU 的外设寄存器访问支持.
相关背景可以参考项目首页, 其中有详细的介绍. 要点如下:</p>

<ul>
  <li><a href="https://github.com/embassy-rs/chiptool">chiptool</a> 实际上是 <a href="https://github.com/rust-embedded/svd2rust">svd2rust</a> 的一个 fork, 使之更适用于创建 <code class="language-plaintext highlighter-rouge">metapac</code> 式的 pac 库, 即厂商的一系列不同芯片的所有外设寄存器都放在一个库中. 这样做的好处是可以更好地复用代码和元数据信息</li>
  <li>chiptool 没有使用 owned struct 的方式, 避免滥用 ownership, 提供更宽松的使用方式</li>
  <li>chiptool 没有使用字段的 read/write proy, 这样字段本身作为类型(<code class="language-plaintext highlighter-rouge">repr(u32)</code>)可以直接拿来保存寄存器值 - 一个常见场景是拿到中断 flags 值, 依次判断, 修改, 最后写回寄存器, 用来清除中断标志</li>
  <li>chiptool 没有使用 MMIO 结构体, 而是直接保存外设地址</li>
  <li>提供了单个 YAML 文件表示一个外设的处理方式</li>
  <li>提供更方便的 transform 支持, 用于合并寄存器块, 字段, enum 类型, 创建 cluster, array 等</li>
</ul>

<h3 id="chiptool-寄存器访问示例">chiptool 寄存器访问示例</h3>

<p>具体使用方法和 svd2rust 基本类似, bit field 访问方法略有不同, 通过 <code class="language-plaintext highlighter-rouge">set_xxx</code> 使用, 总体上更简洁:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="nn">pac</span><span class="p">::</span><span class="n">ADC0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="n">r</span><span class="nf">.statr</span><span class="p">()</span><span class="nf">.read</span><span class="p">()</span><span class="na">.0</span><span class="p">;</span> <span class="c1">// 读取寄存器值</span>
<span class="k">let</span> <span class="n">flag_val</span> <span class="o">=</span> <span class="n">r</span><span class="nf">.adc_stat</span><span class="p">()</span><span class="nf">.read</span><span class="p">()</span><span class="nf">.status</span><span class="p">();</span> <span class="c1">// 读取寄存器字段</span>

<span class="n">r</span><span class="nf">.ctlr1</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_adc_en</span><span class="p">(</span><span class="k">true</span><span class="p">));</span> <span class="c1">// 设置寄存器字段</span>

<span class="n">r</span><span class="nf">.ctlr1</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_adc_en</span><span class="p">(</span><span class="k">false</span><span class="p">));</span> <span class="c1">// 修改寄存器字段, 闭包不再需要传递 `r` 参数, 读出的值直接通过 `w` 访问</span>
</code></pre></div></div>

<h3 id="使用-chiptool-生成-pac-库">使用 chiptool 生成 pac 库</h3>

<p>chiptool 提供了简单的命令行接口来生成外设寄存器块定义(<code class="language-plaintext highlighter-rouge">RegisterBlock</code>):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 从 SVD 文件提取所有外设信息</span>
chiptool extract-all <span class="nt">--svd</span> soc.svd <span class="nt">--output</span> tmp

<span class="c"># 为单个外设生成 Rust 代码</span>
chiptool gen-block <span class="nt">--input</span> tmp/UART.yaml <span class="nt">-o</span> src/uart.rs
</code></pre></div></div>

<p>生成的代码仅包含外设类型定义(如 UART 结构体)，不包含具体实例(如 UART1、UART2)。要完整使用这些外设，还需要添加外设实例的地址信息, 使用 <code class="language-plaintext highlighter-rouge">::from_ptr</code> 方法从地址构造实例.</p>

<p>相比之下, chiptool 更适合于生成 metapac 风格的 pac 库, 这也就意味着它的门槛更高, 需要更多的元数据信息, 以及更多的工作量.</p>

<p>曾经唯一的参考资料是 Embassy 项目维护的 <a href="https://github.com/embassy-rs/stm32-data">stm32-data</a>. 在它的基础上, 我裁剪并维护了 <a href="https://github.com/ch32-rs/ch32-data">ch32-data</a> 和 <a href="https://github.com/andelf/hpm-data">hpm-data</a>, 都可以作为 chiptool + metapac 工作流的参考.</p>

<p>管理多个, 乃至某一厂商所有 MCU 的外设寄存器访问代码, 需要对整个芯片系列有一定的了解, 以及对外设寄存器的共性和差异有一定的认识. 需要来回阅读参考手册和原始 SVD 文件, 以及对生成的代码进行测试.</p>

<p>而 svd2rust 目前需要额外的脚本或工具才能更好支持单个 pac 库对应多个芯片的情况, 例如 <a href="https://github.com/djmcgill/form">form</a> 工具可以拆分 inline mode 到子 mod 文件.</p>

<h2 id="metapac-的设计与实现">metapac 的设计与实现</h2>

<p>这里将介绍 metapac 的创建步骤, 设计思路与具体实现细节, 方便读者理解 metapac 的流程, 并搞定自己的 metapac 库.
目前的规范一般是 <code class="language-plaintext highlighter-rouge">-data</code> repo 用于存放元数据和生成代码, <code class="language-plaintext highlighter-rouge">-metapac</code> crate 用于最终发布.</p>

<p><a href="https://github.com/embassy-rs/stm32-data">stm32-data</a> 整个流程较复杂, 包含从多个数据源获取的元数据, 包括 SVD 文件, STM32CubeMX 数据文件, 官方 SDK 头文件, ST-MCU-FINDER 数据等,
然后从 SVD 提取外设寄存器描述 YAML 文件, 通过若干 crate 配合, 完成数据的整合, 生成 pac 库.</p>

<p>而一些其他厂家的 MCU 可能缺乏如此丰富的格式化元数据(json/xml/etc.), 可能需要手动维护.</p>

<p>所以针对这种情况 <a href="https://github.com/ch32-rs/ch32-data">ch32-data</a> 和 <a href="https://github.com/andelf/hpm-data">hpm-data</a> 基于 <a href="https://github.com/embassy-rs/stm32-data">stm32-data</a> 的逻辑, 做了简化流程处理, 尽可能适合手工维护.
<strong>例如针对不同 MCU family 的外设情况, 增加了 <code class="language-plaintext highlighter-rouge">include</code> 支持, 方便层级化管理外设</strong>.</p>

<p><a href="https://github.com/andelf/hpm-data">hpm-data</a> 的难度相对更小一些, HPMicro 的 MCU 系列较少, 且外设跨度较小. 同时官方还提供了一些标准的元数据(官方 pinmux tool), 可以通过爬虫的方式拿到.</p>

<p>以下内容以 hpm-data 为例, 介绍 metapac 设计思路与具体实现细节.</p>

<h3 id="项目目录结构介绍">项目目录结构介绍</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">d</code> 脚本, 封装各命令</li>
  <li><code class="language-plaintext highlighter-rouge">data/</code> MCU Family, 外设寄存器元数据目录</li>
  <li><code class="language-plaintext highlighter-rouge">hpm-data-serde/</code> MCU 元数据的 serde 结构定义, lib</li>
  <li><code class="language-plaintext highlighter-rouge">hpm-data-macros/</code> proc-macro lib, 从结构体转 Rust 代码的依赖, 不需要定制, 从 stm32-data 复制即可</li>
  <li><code class="language-plaintext highlighter-rouge">hpm-data-gen/</code> 所有元数据的解析和生成工具, 从 <code class="language-plaintext highlighter-rouge">data</code> 目录读取, 生成到 <code class="language-plaintext highlighter-rouge">build/data</code> 目录</li>
  <li><code class="language-plaintext highlighter-rouge">hpm-metapac-gen/</code> 最终的 metapac 生成工具, 从 <code class="language-plaintext highlighter-rouge">build/data</code> 目录读取, 生成到 <code class="language-plaintext highlighter-rouge">build/hpm-metapac</code> 目录
    <ul>
      <li><code class="language-plaintext highlighter-rouge">res/</code> 最后 metapac 的模板文件, 包括 <code class="language-plaintext highlighter-rouge">Cargo.toml</code>, <code class="language-plaintext highlighter-rouge">build.rs</code>, <code class="language-plaintext highlighter-rouge">METADATA</code> 常量结构体类型定义等等</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">hpm-data-serde/</code> 并不是唯一的数据类型结构体定义, 它只用于保存到 <code class="language-plaintext highlighter-rouge">build/data</code> 目录的格式.
在 <code class="language-plaintext highlighter-rouge">hpm-metapac-gen/src</code> 下还有第二份, 用于从 <code class="language-plaintext highlighter-rouge">build/data</code> 下的 json 解析.
在 <code class="language-plaintext highlighter-rouge">hpm-metapac-gen/res/src</code> 下还有第三份, 用于在最终的 pac 代码中提供 METAPDATA 类型定义.</p>

<p>这是整个项目结构最绕的部分, 新手容易迷失在结构体定义报错中, 往往新增字段需要改三个地方.
但通过这种方式, 可以很好地分离数据定义, 数据解析, 数据生成, 以及最终的代码类型.
例如在最终的 METADATA 中, 很可能为了考虑嵌入式环境和常量类型的特点, 所有的字符串都会被转换为 <code class="language-plaintext highlighter-rouge">&amp;'static str</code>, 所有的数组都会被转换为 <code class="language-plaintext highlighter-rouge">[u32; N]</code> 等等.</p>

<h3 id="元数据准备">元数据准备</h3>

<p>首先确定好需要做哪些目标芯片的 PAC, 如果范围较广, 需要提前预留扩展性(比如多核的情况, 不同子架构的情况).</p>

<h4 id="chip-family">Chip Family</h4>

<p>不同的芯片系列列表数据可以从厂商网站获取, 也可以从多个芯片手册中获取. 创建 <code class="language-plaintext highlighter-rouge">data/chips/CHIP_NAME.yaml</code>. 芯片名称的具体的粒度可以根据芯片的外设共性来划分.
主要型号之后的额外后缀往往包含芯片的具体封装(package: QFN, BGA 等), 以及不同的温度等级, 电压等级, 批次等.
元数据的字段参考 <code class="language-plaintext highlighter-rouge">-data-serde</code> 内的定义即可. 我们把这个文件定义为单个芯片 pac 的所需全部数据入口:</p>

<p>这里以 <code class="language-plaintext highlighter-rouge">HPM5361.yaml</code> 为例:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">HPM5361</span>
<span class="na">family</span><span class="pi">:</span> <span class="s">HPM5300 Series</span>
<span class="na">sub_family</span><span class="pi">:</span> <span class="s">HPM5300, Single-core, Full Featured</span>
<span class="na">packages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">HPM5361xCBx</span>
    <span class="na">package</span><span class="pi">:</span> <span class="s">LQFP100</span>
    <span class="na">pins</span><span class="pi">:</span> <span class="m">100</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">HPM5361xEGx</span>
    <span class="na">package</span><span class="pi">:</span> <span class="s">QFN48</span>
    <span class="na">pins</span><span class="pi">:</span> <span class="m">48</span>
<span class="na">memory</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">address</span><span class="pi">:</span> <span class="s">0x00000000</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">ram</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">ILM</span>
    <span class="na">size</span><span class="pi">:</span> <span class="s">128K</span>
  <span class="pi">-</span> <span class="na">address</span><span class="pi">:</span> <span class="s">0x00080000</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">ram</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">DLM</span>
    <span class="na">size</span><span class="pi">:</span> <span class="s">128K</span>
  <span class="pi">-</span> <span class="na">address</span><span class="pi">:</span> <span class="s">0xf0400000</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">ram</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">AHB_SRAM</span>
    <span class="na">size</span><span class="pi">:</span> <span class="s">32K</span>
  <span class="pi">-</span> <span class="na">address</span><span class="pi">:</span> <span class="s">0x80000000</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">flash</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">XPI0</span>
    <span class="na">size</span><span class="pi">:</span> <span class="s">1M</span>
<span class="na">cores</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">RV32-IMAFDCPB</span> <span class="c1"># D25</span>
    <span class="na">ip-core</span><span class="pi">:</span> <span class="s">Andes D25F</span>
    <span class="na">peripherals</span><span class="pi">:</span> <span class="pi">[]</span>
    <span class="na">interrupts</span><span class="pi">:</span> <span class="pi">[]</span>
    <span class="na">include_peripherals</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/COMMON.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_GPTMR23.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_UART4567.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_ADC1.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_DAC.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_OPAMP.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_MCAN.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_Motion.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_PLB.yaml"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">../family/HPM5300_Secure.yaml"</span>
    <span class="na">include_interrupts</span><span class="pi">:</span> <span class="s2">"</span><span class="s">../interrupts/HPM5361.yaml"</span>
    <span class="na">include_dmamux</span><span class="pi">:</span> <span class="s2">"</span><span class="s">../dmamux/HPM5361.yaml"</span>
    <span class="na">gen_dma_channels</span><span class="pi">:</span>
      <span class="na">HDMA</span><span class="pi">:</span> <span class="m">32</span>
</code></pre></div></div>

<p>除了芯片的基本信息, 还包括了芯片的内存布局, 而在 <code class="language-plaintext highlighter-rouge">cores:</code> key 下, 是外设列表, 中断列表, DMA 通道列表等等. 这里 cores 实现为一个列表, 以支持多核异构芯片, 虽然在 HPMicro 的 MCU 中并没有这种情况.</p>

<p>其中 <code class="language-plaintext highlighter-rouge">include_peripherals:</code>, <code class="language-plaintext highlighter-rouge">include_interrupts:</code>, <code class="language-plaintext highlighter-rouge">include_dmamux:</code> 是外设, 中断, DMAMUX 描述的直接引用, 这是对 stm32-data 的改进, 以支持更好的外设复用和手工维护.
<code class="language-plaintext highlighter-rouge">gen_dma_channels:</code> 表示 DMA 通道的数量, 用于生成 DMA 控制器和 channel 的元数据, 这些元数据可能会在 hal 实现中用到. 尤其是 <a href="https://embassy.dev/">Embassy</a> 这种异步框架, DMA 通道的管理是一个重要的部分.</p>

<h4 id="外设元数据">外设元数据</h4>

<p>外设的元数据是 pac 库的核心, 也是最复杂的部分. 一般来说, 一个外设的元数据包括:</p>

<ul>
  <li>外设的基本信息, 包括名称, 描述, 寄存器等
    <ul>
      <li>寄存器块的定义, 包括寄存器地址, 寄存器名, 寄存器描述等</li>
      <li>寄存器字段的定义, 包括字段名, 字段位宽, 字段描述等</li>
      <li>寄存器字段的值定义, 包括字段值名, 字段值描述等, 通过 enum 提供</li>
    </ul>
  </li>
  <li>外设的中断信号</li>
  <li>外设的引脚信号, 包括引脚复用情况</li>
  <li>外设的时钟信号, 使能复位信号等</li>
  <li>外设的 DMA 请求信息</li>
</ul>

<p>其中寄存器的信息我们可以从 SVD 里获取, 通过 chiptool 提供的 <code class="language-plaintext highlighter-rouge">chiptool extract-peripheral</code> 子命令, 可以方便地从一系列 SVD 中生成对应外设的 YAML 文件.
之后的工作就是手工维护这些 YAML 文件. 对于不同芯片使用相同的外设, 可以通过文件 diff 的方法来判断是否同一外设.</p>

<p>其中 YAML 文件格式例子如下, 相比 SVD 的 XML 更简单明了, 便于维护:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">block/UART</span><span class="pi">:</span>
  <span class="na">description</span><span class="pi">:</span> <span class="s">UART0.</span>
  <span class="na">items</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">IIR2</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s">Interrupt Identification Register2.</span>
      <span class="na">byte_offset</span><span class="pi">:</span> <span class="m">12</span>
      <span class="na">fieldset</span><span class="pi">:</span> <span class="s">IIR2</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Cfg</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s">Configuration Register.</span>
      <span class="na">byte_offset</span><span class="pi">:</span> <span class="m">16</span>
      <span class="na">fieldset</span><span class="pi">:</span> <span class="s">Cfg</span>
    <span class="c1"># .... other register items</span>
<span class="na">fieldset/IIR2</span><span class="pi">:</span>
  <span class="na">description</span><span class="pi">:</span> <span class="s">Interrupt Identification Register2.</span>
  <span class="na">fields</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">INTRID</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s">Interrupt ID, see IIR2 for detail decoding.</span>
      <span class="na">bit_offset</span><span class="pi">:</span> <span class="m">0</span>
      <span class="na">bit_size</span><span class="pi">:</span> <span class="m">4</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">FIFOED</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s">FIFOs enabled These two bits are 1 when bit 0 of the FIFO Control Register (FIFOE) is set to 1.</span>
      <span class="na">bit_offset</span><span class="pi">:</span> <span class="m">6</span>
      <span class="na">bit_size</span><span class="pi">:</span> <span class="m">2</span>
    <span class="c1"># .... other fields</span>
<span class="c1"># ... other fieldsets</span>
<span class="na">enum/RX_IDLE_COND</span><span class="pi">:</span>
  <span class="na">description</span><span class="pi">:</span> <span class="s">IDLE Detection Condition.</span>
  <span class="na">bit_size</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">variants</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">RXLINE_LOGIC_ONE</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s">Treat as idle if RX pin is logic one</span>
      <span class="na">value</span><span class="pi">:</span> <span class="m">0</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">STATE_MACHINE_IDLE</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s">Treat as idle if UART state machine state is idle</span>
      <span class="na">value</span><span class="pi">:</span> <span class="m">1</span>
</code></pre></div></div>

<p>其中对外设寄存器描述的优化是整个工作最麻烦耗时的地方,
例如对字段值 enum 的优化, 对寄存器 array 的优化等.
优化修改的好处是显而易见的, 例如如下两种代码风格对比:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// set PWM1_CMP7 mode</span>
<span class="k">use</span> <span class="n">hpm_metapac</span> <span class="k">as</span> <span class="n">pac</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">pac</span><span class="p">::</span><span class="nn">pwm</span><span class="p">::</span><span class="n">vals</span><span class="p">;</span>
<span class="nn">pac</span><span class="p">::</span><span class="n">PWM1</span><span class="nf">.cmpcfg7</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">w</span><span class="nf">.set_cmpmode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// output compare</span>
    <span class="n">w</span><span class="nf">.set_cmpshdwupt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// on modify</span>
<span class="p">});</span>

<span class="c1">// vs</span>
<span class="nn">pac</span><span class="p">::</span><span class="n">PWM1</span><span class="nf">.cmpcfg</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">w</span><span class="nf">.set_cmpmode</span><span class="p">(</span><span class="nn">vals</span><span class="p">::</span><span class="nn">CmpMode</span><span class="p">::</span><span class="n">OUTPUT_COMPARE</span><span class="p">);</span>
    <span class="n">w</span><span class="nf">.set_cmpshdwupt</span><span class="p">(</span><span class="nn">vals</span><span class="p">::</span><span class="nn">ShadowUpdateTrigger</span><span class="p">::</span><span class="n">ON_MODIFY</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>可见, 通过 enum 的方式, 可以更好地表达寄存器字段的含义, 免去额外注释, 也更容易理解, 更类型安全.</p>

<p>寄存器之外的其他信息一般需要从芯片手册中获取. hpm-data 在实现中, 大量使用了 <a href="https://github.com/hpmicro/hpm_sdk">hpm_sdk</a> 头文件中的常量定义, 通过正则解析的方式动态填写在外设结构定义中.
另外前面提到的 pinmux tool 也提供了重要的引脚复用信息. 都通过 <code class="language-plaintext highlighter-rouge">-data-gen</code> 工具解析, 合并 Chip Family 信息后生成到 <code class="language-plaintext highlighter-rouge">build/data</code> 目录.</p>

<p>然后在 <code class="language-plaintext highlighter-rouge">family/</code> 中创建对应的外设版本引用就可以继而被 <code class="language-plaintext highlighter-rouge">CHIP_NAME.yaml</code> 的 include 引用.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># part of family/HPM5300_UARTs.yaml</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">UART0</span>
  <span class="na">address</span><span class="pi">:</span> <span class="s">0xF0040000</span>
  <span class="na">registers</span><span class="pi">:</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">uart</span>
    <span class="na">version</span><span class="pi">:</span> <span class="s">v53</span>
    <span class="na">block</span><span class="pi">:</span> <span class="s">UART</span>
  <span class="c1"># the following are filled by `-data-gen` tool</span>
  <span class="c1"># pins:</span>
  <span class="c1"># sysctl:</span>
  <span class="c1"># interrupts:</span>
  <span class="c1"># dma_channels:</span>
</code></pre></div></div>

<h4 id="data-gen-工具"><code class="language-plaintext highlighter-rouge">data-gen</code> 工具</h4>

<p><code class="language-plaintext highlighter-rouge">-data-gen</code> 工具会扫描 <code class="language-plaintext highlighter-rouge">data/chips/</code> 下所有 <code class="language-plaintext highlighter-rouge">CHIP_NAME.yaml</code> 文件, 处理 <code class="language-plaintext highlighter-rouge">include_x:</code> 引用, 根据对应的外设信息, 从 sdk 头文件中提取常量定义, 填充上述的 pins, sysctl, interrupts, dma_channels 等字段,
最终生成到 <code class="language-plaintext highlighter-rouge">build/data</code> 目录. 这个工具是整个 metapac 生成流程的核心, 也是最复杂的部分. 在 stm32-data 中, 也是这个工具从各种数据来源中提取生成结构化数据.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hpm-data-gen
├── Cargo.toml
└── src
    ├── main.rs <span class="c"># 主程序入口</span>
    ├── dma.rs <span class="c"># DMA 通道信息提取</span>
    ├── interrupts.rs <span class="c"># 中断信息提取</span>
    ├── pinmux.rs <span class="c"># 引脚复用信息提取</span>
    ├── iomux.rs <span class="c"># 引脚复用信息提取, 提出 sdk 常量</span>
    ├── pins.rs <span class="c"># 引脚数量, GPIO port 等信息提取</span>
    ├── registers.rs
    ├── sysctl.rs <span class="c"># 时钟, GROUP 使能信息提取</span>
    └── trgmmux.rs <span class="c"># 处理全局 TRGMUX 信号</span>
</code></pre></div></div>

<p>相关逻辑请参考 <a href="https://github.com/andelf/hpm-data">hpm-data</a> 项目, 通过依次执行以上流程, 完成了外设元数据的准备. 最终元数据如下:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">build/data/chips/CHIP_NAME.json</code> - 对应每个芯片的元数据</li>
  <li><code class="language-plaintext highlighter-rouge">build/data/registers/periph_ver.json</code> - 对应每种外设的寄存器信息</li>
</ul>

<h3 id="metapac-生成">metapac 生成</h3>

<p><code class="language-plaintext highlighter-rouge">-metapac-gen</code> 工具会扫描 <code class="language-plaintext highlighter-rouge">build/data/</code> 下所有的芯片和外设寄存器数据, 生成最终的 metapac 代码. 结合 <code class="language-plaintext highlighter-rouge">res/</code> 下项目模板,
最终输出到 <code class="language-plaintext highlighter-rouge">build/hpm-metapac</code> 目录.
这个工具是整个 metapac 生成流程的最后一步, 直接输出一个 crate 目录作为结果.</p>

<ul>
  <li>处理外设寄存器信息, 生成 <code class="language-plaintext highlighter-rouge">periph_ver.rs</code> 文件</li>
  <li>处理芯片信息, <code class="language-plaintext highlighter-rouge">METADATA</code> 结构, <code class="language-plaintext highlighter-rouge">metadata_xxxx.rs</code> 文件, 通过编译时 feature flag 选择引用具体文件</li>
  <li>输出 <code class="language-plaintext highlighter-rouge">-metapac</code> crate</li>
</ul>

<p>芯片信息的处理主要包括 <code class="language-plaintext highlighter-rouge">METADATA</code> 的处理, 最终所有芯片名 feature gate 和外设版本的映射关系, 中断结构体, <code class="language-plaintext highlighter-rouge">memory.x</code>, <code class="language-plaintext highlighter-rouge">device.x</code> 等信息的生成.</p>

<p><code class="language-plaintext highlighter-rouge">METADATA</code> 是区别于 metapac 和传统 svd2rust PAC 的一个重要特点, 用于提供芯片的元数据信息, 例如芯片的内存布局, 中断表, 外设及版本信息等.
通过 <code class="language-plaintext highlighter-rouge">"metadata"</code> feature gate 启用. 这个信息在 HAL 驱动中可能会用到, 例如 Embassy driver 需要动态创建 DMA 类型等.</p>

<p>外设寄存器信息的代码生成相关逻辑主要是调用 <a href="https://github.com/embassy-rs/chiptool">chiptool</a> 完成, 通过一个简单的 IR (intermediate representation) 结构, 生成对应的 Rust 代码.</p>

<p>题外: chiptool 的这个从 YAML 定义生成 <code class="language-plaintext highlighter-rouge">.rs</code> 代码的逻辑其实非常有用, 使用场景不仅限于 pac 库, 例如一些公共 IP 外设的定义, 二进制协议的定义,
I2C 传感器寄存器格式的定义等等. 甚至诸如 RISC-V CSR 字段的定义都有可能使用到这种机制. 希望这种格式成为 Rust 嵌入式的某种标准. <a href="https://github.com/embedded-drivers/yaml2pac">yaml2pac</a> 就是这样一个尝试,
实现单个文件的代码输出. 社区也有类似的工作 <a href="https://github.com/embassy-rs/chiptool/pull/17">embassy-rs/chiptool#17</a>.</p>

<h4 id="hpm-metapac-的扩展内容">hpm-metapac 的扩展内容</h4>

<p>HPMicro 提供了多个系列的高性能 RISV-V MCU, 包括丰富的外设资源和高速时钟, 其中较为复杂的是 SYSCTL 的资源管理, 引脚的 IOMUX, 以及 TRGMUX 外设互联等.
这些外设涉及到大量的 CLUSTER 寄存器(即外设的寄存器块通过二级, 三级索引的方式使用, 更好地组织资源), 而 <a href="https://github.com/embassy-rs/chiptool">chiptool</a> 目前对这种  CLUSTER 索引支持并不完善,
无法解析具体索引名字, 例如 CPU0 时钟设置 <code class="language-plaintext highlighter-rouge">SYSCTL.CLOCK[CLK_TOP_CPU0].MUX</code>, 在 chiptool 只能识别为 <code class="language-plaintext highlighter-rouge">pac::SYSCTL.clock(0).read().mux()</code>,
丢失了其中最终要的 <code class="language-plaintext highlighter-rouge">&lt;dimIndex&gt;</code> 信息. 其在 SVD 的原始定义如下:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dimIncrement&gt;</span>0x4<span class="nt">&lt;/dimIncrement&gt;</span>
<span class="nt">&lt;dimIndex&gt;</span>cpu0,cpx0,rsv2,rsv3,.... <span class="nt">&lt;/dimIndex&gt;</span>
</code></pre></div></div>

<p>相同情况的还有 IOC, GPIOM 等外设, 为了处理这种情况, hpm-data 对 pac 库做了扩展, 单独将必备的索引信息, 以 <code class="language-plaintext highlighter-rouge">pub const NAME: usize</code> 的方式提供.</p>

<p>这些 consts 通过 hpm-data-gen 解析, 最终由 hpm-metapac-gen 生成为对应 pac 的子 mod:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">hpm_metapac::clocks::</code> 下的所有时钟，用于 SYSCTL.CLOCK</li>
  <li><code class="language-plaintext highlighter-rouge">hpm_metapac::resources::</code> 下的所有 SYSCTL 资源</li>
  <li><code class="language-plaintext highlighter-rouge">hpm_metapac::pins::</code> 下的所有 GPIO 及其 PAD，用于 IOC</li>
  <li><code class="language-plaintext highlighter-rouge">hpm_metapac::iomux::</code> 下的所有 IOMUX 设置（FUNC_CTL）</li>
  <li><code class="language-plaintext highlighter-rouge">hpm_metapac::trgmmux::</code> 下的所有 TRGM 常量定义</li>
</ul>

<p>对于 PAC 库来说, 不仅仅是提供给 HAL 驱动使用, 而是同时能给最终用户一个方便安全的寄存器访问接口. 对于某些设计良好的外设, 寄存器访问更直接有效.
所以上面的常量定义其实很有必要, 也为 HAL 的实现提供了额外信息:
(这里为了方便作为 index 使用, 统一用了 <code class="language-plaintext highlighter-rouge">usize</code> 类型. 丢失了部分类型安全, 不过加一个 enum 也很容易, 这里主要是等待上游 chiptool 实现 cluster 支持.)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="n">hpm_metapac</span> <span class="k">as</span> <span class="n">pac</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">pac</span><span class="p">::{</span><span class="n">iomux</span><span class="p">,</span> <span class="n">pins</span><span class="p">};</span>

<span class="nn">pac</span><span class="p">::</span><span class="n">IOC</span>
    <span class="nf">.pad</span><span class="p">(</span><span class="nn">pins</span><span class="p">::</span><span class="n">PA25</span><span class="p">)</span>
    <span class="nf">.func_ctl</span><span class="p">()</span>
    <span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_alt_select</span><span class="p">(</span><span class="nn">iomux</span><span class="p">::</span><span class="n">IOC_PA25_FUNC_CTL_PWM1_P_1</span><span class="p">));</span>
</code></pre></div></div>

<h3 id="pac-库的其他内容">pac 库的其他内容</h3>

<p>上述一节其实已经介绍了 PAC 库在标准的外设寄存器访问定义之外还有哪些内容, 这里再总结一遍:</p>

<ul>
  <li>中断静态结构体定义, enum 定义 - 用于在 <code class="language-plaintext highlighter-rouge">-rt</code> 库中使用, 链接到中断处理函数</li>
  <li><code class="language-plaintext highlighter-rouge">device.x</code> 定义中断处理函数的链接符号, 和中断表结构体结合使用</li>
  <li><code class="language-plaintext highlighter-rouge">Peripherals</code> owned struct, 用于通过 ownership 机制管理外设资源 - 仅 svd2rust</li>
  <li><code class="language-plaintext highlighter-rouge">CorePeripherals</code> owned struct, 用于管理核心外设资源, 一般是内核定时器中断处理器等 - 仅 svd2rust + Cortex-M</li>
  <li><code class="language-plaintext highlighter-rouge">memory.x</code> 定义内存布局 - 实际上由于平台的多样性, 不一定非要由 pac 来提供内存布局定义, 比如某些可自由配置 FLASH/RAM 的芯片, 更适合最终应用提供</li>
  <li>各种 METADATA 信息 - 仅适用于本文提到的 metapac</li>
</ul>

<h2 id="附录-svd2pac">附录: svd2pac</h2>

<p>Infineon 是对 Rust 嵌入式方案支持比较友好的公司之一(非爱好者友好).
他们也提供了一个基于 svd2rust 的工具 <a href="https://github.com/Infineon/svd2pac">svd2pac</a>, 用于生成 Infineon MCU 的 PAC 库.
详细设计综合了 svd2rust 和 chiptool 的优点, 适合于单个芯片的 PAC 生成.
使用方法极其类似 chiptool 的闭包方式. 不过由于项目在 Infineon 之外使用较少, 对完整的 SVD 特性支持还不完善.</p>

<p>具体改进:</p>

<ul>
  <li>整体使用方式类似 <a href="https://github.com/embassy-rs/chiptool">chiptool</a></li>
  <li>寄存器访问应该是不安全的，因为它们相当于 C FFI</li>
  <li>不使用 owned Peripherals 结构体，因为带有 ownership 的寄存器会妨碍编写低级驱动程序(Low Level Drivers, LLD)</li>
  <li>不使用宏，以便于调试(相比 <a href="https://docs.rs/ral/latest/ral/">ral</a> 而言)</li>
  <li>较少的外部依赖</li>
</ul>

<h2 id="总结及对比">总结及对比</h2>

<ul>
  <li>C 中的外设寄存器访问, 方式简单直接, 但容易出错, 不够类型安全, Rust 基于自己的类型系统, 可以提供更好的类型安全, 但需要额外的工具支持</li>
  <li>svd2rust 适合于单个芯片的 PAC 生成, 通过 <code class="language-plaintext highlighter-rouge">svd2rust</code> 命令行工具, 可以快速生成单个芯片的 PAC 库, 目前也是社区最常用的方式</li>
  <li>chiptool 适合于多个芯片的 PAC 生成, 通过 <code class="language-plaintext highlighter-rouge">chiptool</code> 和 <code class="language-plaintext highlighter-rouge">-data</code> 仓库, 可以为多个芯片生成 PAC 库, 适合于厂商的多个芯片系列的 PAC 生成. 同时具有 <code class="language-plaintext highlighter-rouge">METADATA</code> 的特性, 用于提供芯片的元数据信息</li>
</ul>

<p>除此之外 <a href="https://docs.rs/ral/latest/ral/">ral</a> / <a href="https://docs.rs/ral-registers/latest/ral_registers/">ral-registers</a> 也提供了另一种基于宏的外设寄存器访问方案.</p>

<!-- Refs -->]]></content><author><name>andelf</name></author><category term="embedded" /><category term="rust" /><category term="embassy" /><summary type="html"><![CDATA[Embedded Rust Peripheral Register Access: svd2rust, chiptool and metapac Approach.]]></summary></entry><entry><title type="html">机场 24x24 像素显示单元 Airport 24x24 Dot Matrix RGB Character Display Unit</title><link href="https://andelf.github.io/2024/08/19/airport-24x24-dot-rgb-character-display/" rel="alternate" type="text/html" title="机场 24x24 像素显示单元 Airport 24x24 Dot Matrix RGB Character Display Unit" /><published>2024-08-19T13:42:00+00:00</published><updated>2024-08-20T07:41:40+00:00</updated><id>https://andelf.github.io/2024/08/19/airport-24x24-dot-rgb-character-display</id><content type="html" xml:base="https://andelf.github.io/2024/08/19/airport-24x24-dot-rgb-character-display/"><![CDATA[<p>之前在咸鱼 App 上收了 3 个 24x24 像素的机场 RGB 点阵显示单元, 大概是这么个东西:</p>

<p><img src="/assets/display-24x24-front.jpeg" alt="Front" /></p>

<p>这种显示单元在机场的航站楼里面经常见到，用来显示航班信息, 一个单元显示一个汉字. 常见是红色或黄色单色字符, 特点是显示效果非常醒目.</p>

<p><img src="/assets/display-24x24-airport-screen.jpeg" alt="Airport Screen" /></p>

<p>听商家说, 这一批屏幕来自于浦东机场. 大概是机场航班信息显示屏幕的一部分. 如上图, 一个汉字正好使用一个显示单元.
字体边缘清晰, 亮度高.</p>

<p>简单搜索发现相关似乎 IC 资料能搜到, 猜测驱动应该不难, 所以当时就收了下来. 垃圾佬的特色就是赌.</p>

<h2 id="介绍">介绍</h2>

<p>整个显示单元成色还可以, 但设备常年在较恶劣使用环境下工作, 有不少陈年灰, 需要清理.</p>

<p>正面稍有岁月痕迹, 外壳有些许运输划痕, 但屏幕成色很好. 屏幕隐约能看到大块的像素点.</p>

<p><img src="/assets/display-24x24-back.jpeg" alt="Back" /></p>

<p>背后是巨大的散热金属片, 用于给 RGB 背光驱动板散热. 说明 RGB 背光板功耗不小, 提醒我们不要直接用单片机驱动.
从背面的文字可以确定屏幕型号是 KD54008-L025. 同时插座文字可以确定屏幕的上下方向.
左右两侧有三个 PH2.0 接口, 用于背光级联驱动和背光电源. PCB 上有标注, 但被散热片遮挡不容易看到.
背光板上有三个电位器可以调整 R, G, B 的亮度.</p>

<p><img src="/assets/display-24x24-back-light-board.jpeg" alt="Back Light Driver PCB" /></p>

<p>拆掉后可以看到背光 RGB 灯珠, 分十六组, 使用移位寄存器驱动, 即完全改变一片背光板的颜色, 需要通过移位16次.</p>

<p><img src="/assets/display-24x24-screen.jpeg" alt="LCD Screen Teardown" /></p>

<p>屏幕是两层静态 TN, 每一层都是 24x24 像素, 相同. 这种屏幕的特点是响应速度快, 高对比度, 叠两层对比度更高.
LCD 驱动板分上下两块 PCB 板, 每块板四个 LCD 驱动芯片 LC7931 级联. TSSOP20 封装的是 74HC245, 用于级联信号驱动能力.
上下两块驱动板的布局近似, 但移位方向和屏幕像素连接稍有不同, 基本上是镜像对称的. 这里放上板的图:</p>

<p><img src="/assets/display-24x24-lcd-driver-board.jpeg" alt="LCD Driver PCB" /></p>

<p>每块驱动板背后有两个 10pin 接口, 用于级联和电源. 10pin 接口是超薄接插连接器, 不是常见的型号, 但可以用 MX1.25-10P 超薄接头兼容.</p>

<p>折腾这种东西像是在复习自己当年的数字电路知识, 高低电平, 时钟, 包括移位寄存器, 锁存器等等.</p>

<h2 id="电路部分">电路部分</h2>

<p>掏出家家必备的万用表开始, 一顿测.
背光驱动板因为接口有标注, 可以直接给驱动信号. LCD 驱动板稍微复杂一点, 但你只需要一个周末的下午. 有一些常用的经验:</p>

<ul>
  <li>如果外壳或安装孔接地, 可以很容易确定地线和电源</li>
  <li>从已知芯片和资料比较完善的芯片开始, 检测信号引脚, 例如 74HC245</li>
  <li>级联式组合的芯片走线一般都比较有规律, 可以大致猜测</li>
</ul>

<p>背光和LCD驱动是两部分独立的电路,分别处理。</p>

<h3 id="lcd-驱动板">LCD 驱动板</h3>

<p>单个单元有上下两块驱动板, 分别用于上下两半屏幕. 两块驱动板的布局近似, 但移位方向和屏幕连接稍有不同, 基本上是镜像对称的.</p>

<p>以上板为例(01A):</p>

<ul>
  <li>4 片级联 LC7931, 用于驱动屏幕, 三洋的 80-channel Liquid-crystal Display Driver</li>
  <li>1 片 HC245A , 即熟悉的 74HC245, Octal 3-State Noninverting Bus Transceiver, 三态 8 位总线收发, 用于驱动信号和级联信号的 buffer, 增加级联信号驱动能力</li>
  <li>两个超薄 10pin 板对线接插连接器, 不是常见的型号, 能近似兼容的信号是 MX1.25-10P 超薄接头(必须是超薄)</li>
</ul>

<p>通过分析74HC245三态8路总线收发芯片的使用情况,可以快速判断该PCB的供电和信号线路。74HC245的使能信号和方向信号均接地,说明它被当作一个普通的缓冲芯片使用,用于增加级联信号驱动能力.</p>

<p>74HC245的8路信号输入输出分别引向其他部分。由于LTC7931支持级联, 需要4条信号线控制, 因此可合理猜测这8路信号是用于TC7931的级联输入输出信号.</p>

<p>LTC7931是 80 通道液晶显示驱动芯片,用于驱动LCD的的像素点。引脚较多, 需要慢慢对应到接插件端口上.
LC7931 手册很详细, 是影印版的 PDF. 我们常把这种显示单元称为 “段码屏”, 屏幕被分成了很多 “segment”, 具体组织方式可以是规则矩阵排列, 也可以是类似数码管, 比如常见的七段数码管就是一种 segment display.</p>

<p>忽略74HC245, 简化电路示意图如下:</p>

<p><img src="/assets/display-24x24-lcd-driver-sch.jpeg" alt="SCH" /></p>

<p>主要是级联和接插件的信号输入输出。上下两块驱动板的四个接口的GND均位于显示单元外侧,电源输入位于靠模块中间一侧。</p>

<p>具体的像素布局需要在代码中一位一位修改尝试, 这里我结合了代码和万用表, 屏幕布局大概是:</p>

<ul>
  <li>屏幕上半部分像素 width=24, height=12, 由 4 片 LC7931 驱动, 级联方式</li>
  <li>每片 LC7931 驱动 72 个像素点(segment), 80-bit 输出的高八位为 NC</li>
  <li>72 个像素点正好是 6 列, z 字形排列, 12 行</li>
  <li>屏幕下半部分与此镜像对称, 所以成了 80-bit 输出的低八位 NC</li>
  <li>上下两块驱动板的布局通过跳线电阻选择移位方向, 所以大概是:</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Back View)
+--CN0------------CN1--+
| A1 -&gt; A2 -&gt; A3 -&gt; A4 |
|                      |
........................
|                      |
| B1 -&gt; B2 -&gt; B3 -&gt; B4 |
+--CN0------------CN1--+
</code></pre></div></div>

<p>其中每个 Ax, Bx 表示单片 LTC7931 驱动的 72 个像素点, 也就是 6 列 12 行的像素点.</p>

<p>CLKSR 是移位寄存器时钟, 最高 1MHz, 计算可以得到, 80 segment 驱动, 一个屏幕 8 片 LC7931,
(1 MHz / (80 * 8) = 1562 Hz) 理论最高一个单元屏幕刷新率, 3 个级联的话就是 320 Hz. 速度还可以.
对于机场静态文字来说, 这个速度是足够的.</p>

<h3 id="背光电路">背光电路</h3>

<p>背光板上的 16 组 RGB LED, 每组若干高亮三色 LED, 通过移位的方式逐渐驱动, 一个单元有三个连接器. 很常见的 PH2.0.</p>

<ul>
  <li>CN1: 电源输入, 5V, GND, 实测单个单元最高电流可达 1A 以上, 常见单片机板子 5V 直接驱动可能过流烧坏电路!!</li>
  <li>CN2: 驱动信号输出, 用于级联</li>
  <li>CN3: 驱动信号输入</li>
  <li>3 个电位器旋钮, 分别用来控制 R, G, B 的亮度, 方便调整颜色一致性</li>
</ul>

<p>CN2, CN3 都是 8pin PH2.0 接插连接器. CN3 输入驱动信号如下:</p>

<table>
  <thead>
    <tr>
      <th>自上到下</th>
      <th>信号</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>CLK</td>
      <td>背光移位寄存器时钟</td>
    </tr>
    <tr>
      <td>2</td>
      <td>LATCH/LOAD</td>
      <td>背光移位寄存器锁存</td>
    </tr>
    <tr>
      <td>3</td>
      <td>EN</td>
      <td>背光输出使能, 低电平有效</td>
    </tr>
    <tr>
      <td>4</td>
      <td>R</td>
      <td>红色</td>
    </tr>
    <tr>
      <td>5</td>
      <td>G</td>
      <td>绿色</td>
    </tr>
    <tr>
      <td>6</td>
      <td>B</td>
      <td>蓝色</td>
    </tr>
    <tr>
      <td>7</td>
      <td>GND</td>
      <td>地</td>
    </tr>
    <tr>
      <td>8</td>
      <td>NC</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="电路引出">电路引出</h3>

<p>得知了接口的信息, 就可以准备转接板了. 我这里选用了常见的单面洞洞焊接板, 引出电源及 10 pin 接口到 2.54mm 排针.</p>

<h2 id="coding-time">Coding Time</h2>

<p>MCU 这里选择 RPi Pico(RP2040), 开发框架选择 Rust Embassy. 它为嵌入式环境提供了方便简洁的 async/await 支持.
官方对 STM32, RP2040, NRF 等常见芯片提供了支持. 我目前正在做的 <a href="https://github.com/ch32-rs/ch32-hal">ch32-hal</a> 项目提供了 WCH 32 位单片机的 Embassy 支持,
<a href="https://github.com/hpmicro-rs/hpm-hal">hpm-hal</a> 项目提供了 HPMicro 的 32 位单片机的 Embassy 支持.</p>

<p>我们以 Embassy async task 的方式编写屏幕相关驱动.</p>

<p>从官方项目仓库直接找到 examples 目录, 复制出来搞定项目模板, 开始写代码.</p>

<h3 id="背光驱动">背光驱动</h3>

<p>先从简单的开始, 背光的移位和锁存可以快速验证, 甚至本例中, 我是用跳线来回短接模拟时钟测试的.</p>

<h3 id="lcd-像素驱动">LCD 像素驱动</h3>

<p>相对来说 LCD 的驱动需要处理像素位置等信息, 额外还有 M 信号用于刷新 LCD, 相对复杂一些.</p>

<p>LCD M 信号的 AC 刷新, 可以使用 PWM 输出, 也可以偷懒直接用 GPIO:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[embassy_executor::task]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">lcd_ac_driver</span><span class="p">(</span><span class="n">pin</span><span class="p">:</span> <span class="n">AnyPin</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pin</span> <span class="o">=</span> <span class="nn">Output</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="nn">Level</span><span class="p">::</span><span class="n">Low</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ticker</span> <span class="o">=</span> <span class="nn">Ticker</span><span class="p">::</span><span class="nf">every</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="n">ticker</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">pin</span><span class="nf">.toggle</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>移位式像素屏幕的显示内容驱动其实有完整的一个套路, 例如 WS2812 矩阵, 还有这种 LCD segment 驱动.
用 Framebuffer 是最简单的方式. Framebuffer 中字节的内容建议在空间允许的情况下, 尽可能接近最终传输输出的数据,
而不要为了方便像素写入逻辑使用复杂的发送时像素映射运算.(高速移位时候避免复杂指令对于多数低端单片机来说是必要的)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 3 display units</span>
<span class="c1">// 10 byte per chip, 24 chip, 12 upper chip, 12 lower chip</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Pixel24x24</span> <span class="p">{</span>
    <span class="n">buf</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Pixel24x24</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">buf</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_pixel</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span> <span class="n">on</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x_index</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">6</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">y_index</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="mi">12</span><span class="p">;</span>

        <span class="c1">// zig-zag shape</span>
        <span class="k">let</span> <span class="n">chip_index</span> <span class="o">=</span> <span class="k">if</span> <span class="n">y_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="n">x_index</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="p">(</span><span class="n">x_index</span><span class="p">)</span> <span class="p">};</span>

        <span class="k">let</span> <span class="n">start_index</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">chip_index</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">chip_buf</span> <span class="o">=</span> <span class="k">if</span> <span class="n">y_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.buf</span><span class="p">[</span><span class="n">start_index</span><span class="o">..</span><span class="n">start_index</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.buf</span><span class="p">[</span><span class="n">start_index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="n">start_index</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">chip_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">6</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">chip_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">12</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">chip_n</span> <span class="o">=</span> <span class="n">chip_y</span> <span class="o">+</span> <span class="n">chip_x</span> <span class="o">*</span> <span class="mi">12</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">byte_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">chip_n</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">bit_index</span> <span class="o">=</span> <span class="n">chip_n</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">on</span> <span class="p">{</span>
            <span class="n">chip_buf</span><span class="p">[</span><span class="n">byte_index</span><span class="p">]</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit_index</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">chip_buf</span><span class="p">[</span><span class="n">byte_index</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">!</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit_index</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>随后实现 <a href="https://docs.rs/[embedded-graphics]/latest/embedded_graphics/">embedded-graphics</a> 的 <code class="language-plaintext highlighter-rouge">DrawTarget</code> trait:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">OriginDimensions</span> <span class="k">for</span> <span class="n">Pixel24x24</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Size</span> <span class="p">{</span>
        <span class="nn">Size</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">24</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">DrawTarget</span> <span class="k">for</span> <span class="n">Pixel24x24</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">BinaryColor</span><span class="p">;</span>

    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="nn">core</span><span class="p">::</span><span class="nn">convert</span><span class="p">::</span><span class="n">Infallible</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">draw_iter</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">pixels</span><span class="p">:</span> <span class="n">I</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">I</span><span class="p">:</span> <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">Pixel</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Color</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="nf">Pixel</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span> <span class="k">in</span> <span class="n">pixels</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.bounding_box</span><span class="p">()</span><span class="nf">.contains</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.set_pixel</span><span class="p">(</span><span class="n">coord</span><span class="py">.x</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">,</span> <span class="n">coord</span><span class="py">.y</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">,</span> <span class="n">color</span><span class="nf">.is_on</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">clear</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="k">Self</span><span class="p">::</span><span class="n">Color</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">color</span><span class="nf">.is_on</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.buf</span><span class="nf">.fill</span><span class="p">(</span><span class="mi">0xff</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.buf</span><span class="nf">.fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>完成 Framebuffer 之后, 驱动只需要把 FB 的内容移位输出即可:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[inline]</span>
<span class="k">fn</span> <span class="nf">shift_out_lsbf</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Output</span><span class="p">,</span> <span class="n">clk</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Output</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">8</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">p</span><span class="nf">.set_high</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">p</span><span class="nf">.set_low</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">Delay</span><span class="nf">.delay_us</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">clk</span><span class="nf">.set_low</span><span class="p">();</span> <span class="c1">// falling edge shift data out</span>
        <span class="n">Delay</span><span class="nf">.delay_us</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">clk</span><span class="nf">.set_high</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由此, 就可以用 <a href="https://docs.rs/[embedded-graphics]/latest/embedded_graphics/">embedded-graphics</a> 的 <code class="language-plaintext highlighter-rouge">DrawTarget</code> trait 来驱动 LCD 了.</p>

<p><img src="/assets/display-24x24-char-display.jpeg" alt="Char Display" /></p>

<h2 id="进阶---field-sequential-rgb-driving">进阶 - Field Sequential RGB Driving</h2>

<p>在群里经 <a href="https://www.youtube.com/watch?v=t_YXjM7Keqw">wenting</a> 大佬的点拨,
发现它完全可以用 Field Sequential RGB Driving, 也就是分时复用的 RGB 驱动方式, 通过快速切换 R, G, B 三种颜色的亮度来合成出各种颜色.
它与传统的像素并行驱动显示技术不同，采用时间分割方法来处理颜色。</p>

<p>首先显示所有像素的红色成分，然后是绿色，最后是蓝色。这些颜色的显示通常以非常高的频率交替进行，以便人眼无法察觉到颜色的切换，而是感知到这些颜色的混合效果。由于人眼具有持续性的视觉特性（视觉暂留），不同颜色的快速切换可以在观众的视觉中自然地混合起来，从而形成完整的图像。</p>

<p>本文配图即为这种分时复用 RGB 驱动方式的效果.</p>

<h2 id="后">后</h2>

<p>其实这个拆机折腾早在 2023 年末即完成, 只不过迟迟一直没有总结.</p>

<p>后来考虑到 5V 输出更稳定, 单独做了一块 CH32X033(X035) 的板子, 方便焊接排线驱动, 灵感来自 DALL-E 的一次输出, 即结合可焊接 pad 和 2.54mm 排针, 方便使用.</p>

<p><img src="/assets/display-24x24-pcb-board.jpeg" alt="PCB Board Design" /></p>]]></content><author><name>andelf</name></author><category term="embedded" /><category term="rust" /><summary type="html"><![CDATA[之前在咸鱼 App 上收了 3 个 24x24 像素的机场 RGB 点阵显示单元, 大概是这么个东西:]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://andelf.github.io/assets/display-24x24-final.jpeg" /><media:content medium="image" url="https://andelf.github.io/assets/display-24x24-final.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">HPM RISC-V MCU 中断处理简介: 直接地址模式和向量模式 - Interrupt Handling for HPMicro RISC-V MCU / Andes RISC-V</title><link href="https://andelf.github.io/2024/06/17/hpmicro-riscv-interrupt-handling/" rel="alternate" type="text/html" title="HPM RISC-V MCU 中断处理简介: 直接地址模式和向量模式 - Interrupt Handling for HPMicro RISC-V MCU / Andes RISC-V" /><published>2024-06-17T07:30:00+00:00</published><updated>2024-06-17T12:43:43+00:00</updated><id>https://andelf.github.io/2024/06/17/hpmicro-riscv-interrupt-handling</id><content type="html" xml:base="https://andelf.github.io/2024/06/17/hpmicro-riscv-interrupt-handling/"><![CDATA[<p>Interrupt Handling for HPMicro RISC-V MCU(Andes RISC-V IP Core) - Direct Address Mode and Vector Mode.</p>

<p>最近在折腾 HPMicro 的 RISC-V 系列 MCU 的 Rust 支持 <a href="https://github.com/hpmicro-rs/hpm-hal">hpm-hal</a>, 由于需要处理中断, 所以对其中断控制器的工作原理有了一些了解.
虽然 HPMicro 的文档相对于国内其他厂商已经很出色了, 但对于一些细节还是有些模糊, 比如中断的向量模式和具体中断软件处理步骤.
虽然阅读 <a href="https://github.com/hpmicro/hpm_sdk">hpm_sdk</a> 代码可以了解到一些细节, 但很容易迷失在条件编译的海洋中.</p>

<p>这里以 HPM5300EVK 为例, MCU 为 HPM5361, IP Core 为 Andes D25(F). HPM6xxx 系列的 IP Core 为 Andes D45, 但是中断控制器的实现是一样的.</p>

<ul>
  <li>本文不涉及多核情况. 每个核心各自有一个 PLIC,其工作机制无本质区别.</li>
  <li>本文不涉及 Supervisor / User 模式, 仅讨论 Machine 模式下的中断处理.</li>
  <li>本文混合使用 HPM RISC-V MCU 和 Andes IP Core 两个名词, 对于中断处理来说, 他们是通用的.</li>
  <li>本文使用 <a href="https://github.com/hpmicro-rs/hpm-metapac">hpm-metapac</a> 和 <a href="https://github.com/hpmicro-rs/hpm-hal">hpm-hal</a> 作为代码示例.</li>
</ul>

<h2 id="基础介绍">基础介绍</h2>

<p>RISC-V 的中断分为核心本地中断(Core Local Interrupts, 即各种缩写中 “CLxxx” 的由来)和外部中断(External Interrupts).
异常也是一种中断, 但是异常是由指令执行引起的. 异常和中断通过 <code class="language-plaintext highlighter-rouge">mcause</code> 寄存器的最高位来区分. 通过 <code class="language-plaintext highlighter-rouge">mstatus</code> 和 <code class="language-plaintext highlighter-rouge">mie</code> 寄存器开启和关闭中断.</p>

<h3 id="异常">异常</h3>

<p>我们掏出 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 源码看看具体定义:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">InstructionMisaligned</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">InstructionFault</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">IllegalInstruction</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">Breakpoint</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">LoadMisaligned</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">LoadFault</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">StoreMisaligned</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">StoreFault</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">UserEnvCall</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">SupervisorEnvCall</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">MachineEnvCall</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">InstructionPageFault</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">LoadPageFault</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">StorePageFault</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[doc(hidden)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">__EXCEPTIONS</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">InstructionMisaligned</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">InstructionFault</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">IllegalInstruction</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">Breakpoint</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">LoadMisaligned</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">LoadFault</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">StoreMisaligned</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">StoreFault</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">UserEnvCall</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">SupervisorEnvCall</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">MachineEnvCall</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">InstructionPageFault</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">LoadPageFault</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">StorePageFault</span><span class="p">),</span>
<span class="p">];</span>
</code></pre></div></div>

<p><a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 通过静态数组 <code class="language-plaintext highlighter-rouge">__EXCEPTIONS</code> 定义了异常处理函数列表, 通过 <code class="language-plaintext highlighter-rouge">mcause</code> 寄存器的值来索引.
<code class="language-plaintext highlighter-rouge">TrapFrame</code> 是一个结构体, 用于保存异常发生时的寄存器状态. 由汇编代码保存后压栈传递.
所有函数由链接脚本提供了一个 <code class="language-plaintext highlighter-rouge">loop {}</code> 死循环的默认实现, 用户可以在代码中覆盖.</p>

<h3 id="中断">中断</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">SupervisorSoft</span><span class="p">();</span>
    <span class="k">fn</span> <span class="nf">MachineSoft</span><span class="p">();</span>
    <span class="k">fn</span> <span class="nf">SupervisorTimer</span><span class="p">();</span>
    <span class="k">fn</span> <span class="nf">MachineTimer</span><span class="p">();</span>
    <span class="k">fn</span> <span class="nf">SupervisorExternal</span><span class="p">();</span>
    <span class="k">fn</span> <span class="nf">MachineExternal</span><span class="p">();</span>
<span class="p">}</span>

<span class="nd">#[doc(hidden)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">__INTERRUPTS</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">SupervisorSoft</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">MachineSoft</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">SupervisorTimer</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">MachineTimer</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">SupervisorExternal</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">MachineExternal</span><span class="p">),</span>
<span class="p">];</span>
</code></pre></div></div>

<p>如上代码是中断处理函数的定义, 处理方式一致, 也是通过静态数组 <code class="language-plaintext highlighter-rouge">__INTERRUPTS</code> 索引. 但是中断处理函数不需要传递 <code class="language-plaintext highlighter-rouge">TrapFrame</code>, 因为中断发生时,
由中断处理函数来保存寄存器和恢复状态.</p>

<p>其中我们需要关注的是 <code class="language-plaintext highlighter-rouge">MachineExternal</code> 函数, 它负责在机器模式下处理外部中断(即 MCU 的外设中断).
当发生外部中断时, 在 <code class="language-plaintext highlighter-rouge">MachineExternal</code> 函数中, 需要先读取 <code class="language-plaintext highlighter-rouge">PLIC</code> 的中断挂起状态, 确定具体的中断源, 然后调用相应的中断处理函数进行处理.</p>

<h3 id="中断入口">中断入口</h3>

<p><a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 默认使用直接模式(Direct Mode)处理中断, 即将 <code class="language-plaintext highlighter-rouge">mtvec</code> 寄存器设置为统一的中断入口函数地址。
在这种模式下, 发生中断时会直接跳转到该函数执行. 中断入口函数需要读取 <code class="language-plaintext highlighter-rouge">mcause</code> 寄存器的值, 判断是异常还是中断, 然后调用相应的异常或中断处理逻辑.
具体实现中, 入口地址为汇编代码, 负责调用 Rust 函数, 并执行 mret 指令返回.</p>

<p>(这部分实现 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 经常修改, 今天汇编改 Rust, 明天 Rust 改宏, 大后天可能又换个位置…, 实际上区别不大, 依然很难用)</p>

<p>而 Rust 部分比较直观:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">start_trap_rust</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">TrapFrame</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">ExceptionHandler</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrapFrame</span><span class="p">);</span>
        <span class="k">fn</span> <span class="nf">DefaultHandler</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">cause</span> <span class="o">=</span> <span class="nn">xcause</span><span class="p">::</span><span class="nf">read</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">code</span> <span class="o">=</span> <span class="n">cause</span><span class="nf">.code</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">cause</span><span class="nf">.is_exception</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">trap_frame</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">trap_frame</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="n">__EXCEPTIONS</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__EXCEPTIONS</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="o">=</span> <span class="n">h</span> <span class="p">{</span>
                <span class="nf">handler</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">ExceptionHandler</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">ExceptionHandler</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">ExceptionHandler</span><span class="p">(</span><span class="n">trap_frame</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="n">__INTERRUPTS</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__INTERRUPTS</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="o">=</span> <span class="n">h</span> <span class="p">{</span>
            <span class="nf">handler</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">DefaultHandler</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">DefaultHandler</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样当我们需要处理外部中断时候, 只需要覆盖 <code class="language-plaintext highlighter-rouge">MachineExternal</code> 函数即可, <code class="language-plaintext highlighter-rouge">__INTERRUPTS</code> 通过链接符号获得函数入口地址.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">MachineExternal</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">irq_no</span> <span class="o">=</span> <span class="nn">pac</span><span class="p">::</span><span class="n">PLIC</span><span class="nf">.claim</span><span class="p">();</span>

    <span class="c1">// handle irq_no here!</span>

    <span class="nn">pac</span><span class="p">::</span><span class="n">PLIC</span><span class="nf">.complete</span><span class="p">(</span><span class="n">irq_no</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>一般情况下, <a href="https://github.com/rust-embedded/svd2rust">svd2rust</a> 生成的 pac crate 会自带一个 <code class="language-plaintext highlighter-rouge">__EXTERNAL_INTERRUPTS</code> 表, 我们在 <code class="language-plaintext highlighter-rouge">MachineExternal</code> 中读取当前外部中断号, 然后跳转处理即可.</p>

<p>部分 RISC-V 核心实现可能会有一些特殊的处理, 以具体型号参考文档为准.</p>

<h2 id="hpm-risc-v-mcu-中断处理---直接地址模式">HPM RISC-V MCU 中断处理 - 直接地址模式</h2>

<p>这里介绍 HPM RISC-V MCU 中断处理的两种模式, 包括传统的直接地址模式和 Andes IP Core 特有的向量模式.</p>

<p><a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 支持通过编译选项选择中断处理模式, 但向量模式实现极不通用, 直接地址模式是最常见的, 也是几乎被所有 RISC-V 实现支持的.</p>

<p>直接地址模式大致流程如下:</p>

<ul>
  <li>中断模式启用:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">mstatus</code> 中 <code class="language-plaintext highlighter-rouge">MIE</code> 位用于开启全局中断</li>
      <li><code class="language-plaintext highlighter-rouge">mie</code> 中 <code class="language-plaintext highlighter-rouge">MEXT</code> 位用于开启外部中断, <code class="language-plaintext highlighter-rouge">MTIMER</code> 位用于开启 MTIME 中断…</li>
      <li><code class="language-plaintext highlighter-rouge">mtvec</code> 写入中断处理函数地址, 低位置 0(无影响)</li>
    </ul>
  </li>
  <li>中断处理入口 - <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 提供
    <ul>
      <li>从 <code class="language-plaintext highlighter-rouge">mcuase</code> 可以获得当前是异常还是中断, 中断号等信息</li>
      <li>从静态数组中读取对应的处理函数地址, 调用中断处理函数中处理具体的中断</li>
      <li><code class="language-plaintext highlighter-rouge">mret</code> 返回</li>
    </ul>
  </li>
  <li>外部中断处理函数 - 链接符号覆盖
    <ul>
      <li>读取 PLIC, 获取当前中断号</li>
      <li>处理中断</li>
      <li>完成中断, 通知 PLIC (PLIC.claim)</li>
    </ul>
  </li>
</ul>

<h3 id="gpio-外设---外部中断">GPIO 外设 - 外部中断</h3>

<p>对于外部中断来说, 处理 <code class="language-plaintext highlighter-rouge">MachineExternal</code> 即可.</p>

<p>需要注意的是 <code class="language-plaintext highlighter-rouge">mtvec</code> 的设置在 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 中完成, 通过 <code class="language-plaintext highlighter-rouge">xtvec::write(_start_trap as usize, xTrapMode::Direct);</code> 写入函数地址和中断模式即可.
但 Andes RISC-V IP Core 的 mtvec 低位地址无效, 它使用额外的自定义 CSR 来选择中断模式. 这里 <code class="language-plaintext highlighter-rouge">mtvec</code> 只用于写入函数入口地址.</p>

<p>在 <code class="language-plaintext highlighter-rouge">mtvec</code> 设置后, 还需要额外设置 <code class="language-plaintext highlighter-rouge">mstatus</code>, <code class="language-plaintext highlighter-rouge">mie</code> CSR 寄存器, 开启全局中断, 和外部中使能.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mstatus</span><span class="p">::</span><span class="nf">set_mie</span><span class="p">();</span> <span class="c1">// enable global interrupt</span>
    <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mie</span><span class="p">::</span><span class="nf">set_mext</span><span class="p">();</span> <span class="c1">// enbale external interrupt</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里以 PA09 GPIO0 中断为例(开发板板载按钮), 设置外设中断:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 省略 GPIO 配置</span>
<span class="nn">pac</span><span class="p">::</span><span class="n">GPIO0</span><span class="nf">.pl</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.set</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_irq_pol</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">));</span> <span class="c1">// falling edge</span>
<span class="nn">pac</span><span class="p">::</span><span class="n">GPIO0</span><span class="nf">.tp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.set</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_irq_type</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">));</span> <span class="c1">// edge trigger</span>
<span class="nn">pac</span><span class="p">::</span><span class="n">GPIO0</span><span class="nf">.ie</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.set</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_irq_en</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">));</span> <span class="c1">// enable interrupt</span>
</code></pre></div></div>

<p>然后针对具体的外设中断号通过 PLIC 启用中断:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">hal</span><span class="p">::</span><span class="nn">interrupt</span><span class="p">::</span><span class="n">GPIO0_A</span><span class="nf">.set_priority</span><span class="p">(</span><span class="nn">Priority</span><span class="p">::</span><span class="n">P1</span><span class="p">);</span> <span class="c1">// PLIC.priority</span>
    <span class="nn">hal</span><span class="p">::</span><span class="nn">interrupt</span><span class="p">::</span><span class="n">GPIO0_A</span><span class="nf">.enable</span><span class="p">();</span> <span class="c1">// PLIC.targetint[0].inten</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我们直接覆盖 <code class="language-plaintext highlighter-rouge">MachineExternal</code> 函数即可.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">MachineExternal</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">claim</span> <span class="o">=</span> <span class="nn">pac</span><span class="p">::</span><span class="n">PLIC</span><span class="nf">.claim</span><span class="p">();</span> <span class="c1">// 获取当前 interrupt id</span>

    <span class="nn">defmt</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"claim = {}"</span><span class="p">,</span> <span class="n">claim</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">claim</span> <span class="o">==</span> <span class="nn">hal</span><span class="p">::</span><span class="nn">interrupt</span><span class="p">::</span><span class="n">GPIO0_A</span><span class="nf">.number</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// GPIO0_A();</span>
        <span class="c1">// write 1 to clear</span>
        <span class="nn">pac</span><span class="p">::</span><span class="n">GPIO0</span><span class="nf">.if_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.value</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_irq_flag</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">));</span> <span class="c1">// 清除对应外设的中断标志</span>
    <span class="p">}</span>

    <span class="nn">pac</span><span class="p">::</span><span class="n">PLIC</span><span class="nf">.complete</span><span class="p">(</span><span class="n">claim</span><span class="p">);</span> <span class="c1">// 通知 PLIC 处理完毕</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样就完成了对 PA09 GPIO0 的中断处理.</p>

<h3 id="mchtmr---mtime-中断">MCHTMR - MTIME 中断</h3>

<p>以上举例的是 MCU 的外设中断, 这里再介绍下 MTIME, 即 MCHTMR 中断的处理. 假定 <code class="language-plaintext highlighter-rouge">mstatus::set_mie()</code> 已经设置, 即全局中断已经开启.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nn">pac</span><span class="p">::</span><span class="n">MCHTMR</span><span class="nf">.mtime</span><span class="p">()</span><span class="nf">.read</span><span class="p">();</span>
<span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">24_000_000</span><span class="p">;</span> <span class="c1">// 24Mhz default</span>

<span class="nn">pac</span><span class="p">::</span><span class="n">MCHTMR</span><span class="nf">.mtimecmp</span><span class="p">()</span><span class="nf">.write_value</span><span class="p">(</span><span class="n">next</span><span class="p">);</span> <span class="c1">// + 1s</span>

<span class="k">unsafe</span> <span class="p">{</span>
    <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mie</span><span class="p">::</span><span class="nf">set_mtimer</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我们直接设置了一个 1 秒之后的中断. 然后在 <code class="language-plaintext highlighter-rouge">MachineTimer</code> 中处理即可.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">MachineTimer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// // disable mtime interrupt</span>
    <span class="c1">//  unsafe {</span>
    <span class="c1">//        riscv::register::mie::clear_mtimer();</span>
    <span class="c1">//}</span>

    <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nn">pac</span><span class="p">::</span><span class="n">MCHTMR</span><span class="nf">.mtime</span><span class="p">()</span><span class="nf">.read</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">24_000_000</span><span class="p">;</span> <span class="c1">// 24Mhz</span>

    <span class="nn">pac</span><span class="p">::</span><span class="n">MCHTMR</span><span class="nf">.mtimecmp</span><span class="p">()</span><span class="nf">.write_value</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>中断处理函数 <code class="language-plaintext highlighter-rouge">MachineTimer</code> 中可以直接 <code class="language-plaintext highlighter-rouge">mie::clear_mtimer()</code> 关闭 MTIME 中断, 也可以设置比较寄存器, 设置下次中断时间.</p>

<h2 id="hpm-risc-v-mcu-中断处理---向量模式">HPM RISC-V MCU 中断处理 - 向量模式</h2>

<p>中断向量模式在 HPM 官方 Datasheet 中介绍较为简略, 同时还需要参考 Andes RISC-V IP Core 的<a href="http://www.andestech.com/en/products-solutions/product-documentation/">文档</a>.</p>

<ul>
  <li>AndeStar V5 Platform-Level Interrupt Controller Specification (PLIC IP Core 文档)</li>
  <li>AndeStar V5 System Privileged Architecture and CSR (CSR 文档)</li>
</ul>

<p>经过相关试验, 得到如下结论:</p>

<ul>
  <li>中断模式启用:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">mstatus</code> 中 <code class="language-plaintext highlighter-rouge">MIE</code> 位用于开启全局中断</li>
      <li><code class="language-plaintext highlighter-rouge">mie</code> 中 <code class="language-plaintext highlighter-rouge">MEXT</code> 位用于开启外部中断, <code class="language-plaintext highlighter-rouge">MTIMER</code> 位用于开启 MTIME 中断…</li>
      <li><code class="language-plaintext highlighter-rouge">mtvec</code> 写入中断表地址, <code class="language-plaintext highlighter-rouge">mtvec</code> 低 2 位无效 - <strong>与标准 RISC-V 行为不一致</strong></li>
      <li>自定义 CSR <code class="language-plaintext highlighter-rouge">mmisc_ctl</code>(0x7D0) 和 PLIC 设置位 <code class="language-plaintext highlighter-rouge">PLIC.FEATURE.VECTORED</code> 用于选择向量模式</li>
      <li>中断表地址必须位于 FLASH(XPI) 或 ILM, <strong>无法放在 DLM</strong>, 编写自定义链接脚本时候需要注意</li>
    </ul>
  </li>
  <li>中断表
    <ul>
      <li>中断表索引为中断号, 4 字节内存地址表, 必须 4 字节对齐</li>
      <li>外设中断(外部中断)编号从 1 开始</li>
      <li>中断表索引 0 为异常处理和 Core Local 中断, 即上面提到的 <code class="language-plaintext highlighter-rouge">__EXCEPTIONS</code> 和 <code class="language-plaintext highlighter-rouge">__INTERRUPTS</code></li>
      <li>中断表 <code class="language-plaintext highlighter-rouge">mtvec[N]</code> 长 1024, 对于 Supervisor 模式和 User 模式, 中断表为 <code class="language-plaintext highlighter-rouge">mtvec[1024+N]</code>, <code class="language-plaintext highlighter-rouge">mtvec[2048+N]</code></li>
    </ul>
  </li>
  <li>中断处理函数 - 外部中断
    <ul>
      <li><strong>此模式下 <code class="language-plaintext highlighter-rouge">PLIC.CLAIM</code> 寄存器值无效</strong>, 需要当前函数名获得, 或者通过 <code class="language-plaintext highlighter-rouge">mcause</code> 读取</li>
      <li>处理中断</li>
      <li>写入中断号到 <code class="language-plaintext highlighter-rouge">PLIC.CLAIM</code> 通知 PLIC 处理完毕</li>
      <li><code class="language-plaintext highlighter-rouge">mret</code> 返回</li>
    </ul>
  </li>
  <li>中断处理函数 - Core Local 中断
    <ul>
      <li>在向量模式下, 内部中断和异常处理函数位于向量表 0 位置</li>
      <li>通过读取 <code class="language-plaintext highlighter-rouge">mcause</code> 寄存器值, 获取异常或中断原因, 然后调用对应的异常或中断处理函数</li>
      <li><code class="language-plaintext highlighter-rouge">mret</code> 返回</li>
    </ul>
  </li>
</ul>

<h3 id="patch-riscv-rt-_setup_interrupts">Patch <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> <code class="language-plaintext highlighter-rouge">_setup_interrupts</code></h3>

<p><a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 中的中断处理默认是直接地址模式, 通过编译选项 <code class="language-plaintext highlighter-rouge">v-trap</code> 可以切换到向量中断处理模式,
但是实现无法兼容 HPM RISC-V MCU 的向量中断模式. 传统 RISC-V 标准实现的向量中断模式,
指的是跳转指令的向量表, 即中断向量每个中断号对应一条 jump 指令, 跳转到对应的中断处理函数.</p>

<p>而 Andes IP Core 的中断向量是一个内存地址表, 每个中断号对应一个函数的内存地址.
这样的好处是直接跳转, 没有跳转指令的内存偏移限制.</p>

<p>万幸是 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a>  提供了扩展点, 可以通过覆盖 <code class="language-plaintext highlighter-rouge">_setup_interrupts</code> 函数来实现自定义中断处理相关设置.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"Rust"</span> <span class="k">fn</span> <span class="nf">_setup_interrupts</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">__VECTORED_INTERRUPTS</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">vector_addr</span> <span class="o">=</span> <span class="n">__VECTORED_INTERRUPTS</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
    <span class="c1">// FIXME: TrapMode is ignored in mtvec, it's set in CSR_MMISC_CTL</span>
    <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mtvec</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="n">vector_addr</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mtvec</span><span class="p">::</span><span class="nn">TrapMode</span><span class="p">::</span><span class="n">Direct</span><span class="p">);</span>

    <span class="c1">// Enable vectored external PLIC interrupt</span>
    <span class="c1">// CSR_MMISC_CTL = 0x7D0</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">asm!</span><span class="p">(</span><span class="s">"csrsi 0x7D0, 2"</span><span class="p">);</span>
        <span class="nn">pac</span><span class="p">::</span><span class="n">PLIC</span><span class="nf">.feature</span><span class="p">()</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_vectored</span><span class="p">(</span><span class="k">true</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">__VECTORED_INTERRUPTS</code> 是在 <a href="https://github.com/hpmicro-rs/hpm-metapac">hpm-metapac</a> 中定义的向量模式中断表, 通过 <code class="language-plaintext highlighter-rouge">extern</code> 方式从链接器过程获取地址.</p>

<p>此时我们可能需要自定义链接脚本, 将 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 中的额外无效符号丢弃. 不过目前暂时不需要.</p>

<h3 id="中断处理函数---内部中断和异常">中断处理函数 - 内部中断和异常</h3>

<p>考虑到向量表 0 位置用于处理处理器内部中断和异常, 我们希望能复用 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 中的异常处理函数定义表. 在 <code class="language-plaintext highlighter-rouge">hpm-metapac</code> 的实现中,
我定义向量表第一个位置为 <code class="language-plaintext highlighter-rouge">CORE_LOCAL</code> 中断处理函数(通过代码生成工具自动处理):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[link_section</span> <span class="nd">=</span> <span class="s">".vector_table.interrupts"</span><span class="nd">]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">__VECTORED_INTERRUPTS</span><span class="p">:</span> <span class="p">[</span><span class="n">Vector</span><span class="p">;</span> <span class="mi">73</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Vector</span> <span class="p">{</span> <span class="n">_handler</span><span class="p">:</span> <span class="n">CORE_LOCAL</span> <span class="p">},</span>
    <span class="n">Vector</span> <span class="p">{</span> <span class="n">_handler</span><span class="p">:</span> <span class="n">GPIO0_A</span> <span class="p">},</span>
    <span class="n">Vector</span> <span class="p">{</span> <span class="n">_handler</span><span class="p">:</span> <span class="n">GPIO0_B</span> <span class="p">},</span>
    <span class="n">Vector</span> <span class="p">{</span> <span class="n">_handler</span><span class="p">:</span> <span class="n">GPIO0_X</span> <span class="p">},</span>
    <span class="n">Vector</span> <span class="p">{</span> <span class="n">_handler</span><span class="p">:</span> <span class="n">GPIO0_Y</span> <span class="p">},</span>
    <span class="n">Vector</span> <span class="p">{</span> <span class="n">_handler</span><span class="p">:</span> <span class="n">GPTMR0</span> <span class="p">},</span>
    <span class="n">Vector</span> <span class="p">{</span> <span class="n">_handler</span><span class="p">:</span> <span class="n">GPTMR1</span> <span class="p">},</span>
    <span class="c1">// ......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样就可以通过链接符号直接添加内部中断处理函数:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"riscv-interrupt-m"</span> <span class="k">fn</span> <span class="nf">CORE_LOCAL</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用这样的方式, 可以链接非 `pub` 向量表</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">__INTERRUPTS</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">12</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">cause</span> <span class="o">=</span> <span class="nn">riscv</span><span class="p">::</span><span class="nn">register</span><span class="p">::</span><span class="nn">mcause</span><span class="p">::</span><span class="nf">read</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">code</span> <span class="o">=</span> <span class="n">cause</span><span class="nf">.code</span><span class="p">();</span>

    <span class="nn">defmt</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"mcause = 0x{:08x}"</span><span class="p">,</span> <span class="n">cause</span><span class="nf">.bits</span><span class="p">());</span>
    <span class="k">if</span> <span class="n">cause</span><span class="nf">.is_exception</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{}</span> <span class="c1">// let it crash for now</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="n">__INTERRUPTS</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__INTERRUPTS</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="o">=</span> <span class="n">h</span> <span class="p">{</span>
            <span class="nf">handler</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">DefaultHandler</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">DefaultHandler</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nd">#[allow(non_snake_case)]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">fn</span> <span class="nf">DefaultHandler</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于没有了 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 的中断入口函数, 我们需要自己处理寄存器压栈和恢复, 以及中断结束的 <code class="language-plaintext highlighter-rouge">mret</code> 指令.
<code class="language-plaintext highlighter-rouge">extern "riscv-interrupt-m" fn</code> 是一个特殊的 ABI, 它会自动处理所有寄存器的保存和恢复,并在中断处理函数返回时执行 <code class="language-plaintext highlighter-rouge">mret</code> 指令.
需要 Nightly Rust 和 <code class="language-plaintext highlighter-rouge">#![feature(abi_riscv_interrupt)]</code> feature 启用.</p>

<p>使用这种方式, 可以在不 fork <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 的情况下, 实现与传统 <a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 中断处理方式类似的功能.</p>

<p>这里我踩了一个不小的坑, 当开启向量模式后, <code class="language-plaintext highlighter-rouge">PLIC.CLAIM</code> 不再提供中断号, 但中断处理函数依然需要写入它来通知 <code class="language-plaintext highlighter-rouge">PLIC</code> 处理完毕.
因此, 需要通过读取 <code class="language-plaintext highlighter-rouge">mcause</code> 寄存器获取中断号, 然后写入 <code class="language-plaintext highlighter-rouge">PLIC.CLAIM</code> 寄存器来通知 <code class="language-plaintext highlighter-rouge">PLIC</code> 中断已经处理完毕.</p>

<h3 id="中断处理函数---外部中断">中断处理函数 - 外部中断</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"riscv-interrupt-m"</span> <span class="k">fn</span> <span class="nf">GPIO0_A</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// let claim = pac::PLIC.claim(); // WRONG!!!</span>
    <span class="k">let</span> <span class="n">mcause</span> <span class="o">=</span> <span class="nn">mcause</span><span class="p">::</span><span class="nf">read</span><span class="p">()</span><span class="nf">.bits</span><span class="p">();</span>

    <span class="nn">defmt</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"button pressed!"</span><span class="p">);</span>

    <span class="c1">// write 1 to clear</span>
    <span class="nn">pac</span><span class="p">::</span><span class="n">GPIO0</span><span class="nf">.if_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.value</span><span class="p">()</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="nf">.set_irq_flag</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">));</span>

    <span class="nf">compiler_fence</span><span class="p">(</span><span class="nn">core</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">atomic</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
    <span class="nn">pac</span><span class="p">::</span><span class="n">PLIC</span><span class="nf">.complete</span><span class="p">(</span><span class="n">mcause</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>本文中对 <code class="language-plaintext highlighter-rouge">PLIC</code> 操作的实现位于 <a href="https://github.com/hpmicro-rs/hpm-hal">hpm-hal</a> 的 <a href="https://github.com/hpmicro-rs/hpm-hal/blob/master/src/internal/interrupt.rs">src/internal/interrupt.rs</a>.</p>

<p><a href="https://docs.rs/crate/riscv-rt/latest/source/src/lib.rs">riscv-rt</a> 的实现不够通用, 但疯狂打 patch 还是能将就的. 如果我已经自定义了向量表, 中断处理, 链接脚本, 那么原本属于它的只剩下几句 <code class="language-plaintext highlighter-rouge">.data</code> <code class="language-plaintext highlighter-rouge">.bss</code> 和 FPU 初始化汇编了. 并不是很好的方式.</p>

<p>向量模式中断总体实现更简洁明了, 少一层跳转, 其中 <code class="language-plaintext highlighter-rouge">extern "riscv-interrupt-m" fn</code> 可以通过过程宏的方式处理, 例如 <code class="language-plaintext highlighter-rouge">#[interrupt]</code>.</p>

<p>本文适用于其他 Andes IP Core 的 RISC-V MCU, 但是具体实现细节请参考具体型号的文档.</p>

<p>本文适用于其他语言. 但是需要注意 ABI 和寄存器的处理.</p>

<p>欢迎关注 <a href="https://github.com/hpmicro-rs/hpm-hal">hpm-hal</a> 的进展, 以及 <a href="https://github.com/hpmicro-rs/hpm-metapac">hpm-metapac</a> 的实现 <a href="https://github.com/andelf/hpm-data">hpm-data</a>.</p>]]></content><author><name>andelf</name></author><category term="embedded" /><category term="rust" /><category term="riscv" /><summary type="html"><![CDATA[Interrupt Handling for HPMicro RISC-V MCU(Andes RISC-V IP Core) - Direct Address Mode and Vector Mode.]]></summary></entry><entry><title type="html">10.2 寸黑白红三色墨水屏价签拆解及驱动过程简记 - 10.2 inch 3-Color BWR ESL</title><link href="https://andelf.github.io/blog/2023/12/17/10-2-inch-3-color-esl/" rel="alternate" type="text/html" title="10.2 寸黑白红三色墨水屏价签拆解及驱动过程简记 - 10.2 inch 3-Color BWR ESL" /><published>2023-12-17T11:54:00+00:00</published><updated>2023-12-18T16:30:06+00:00</updated><id>https://andelf.github.io/blog/2023/12/17/10-2-inch-3-color-esl</id><content type="html" xml:base="https://andelf.github.io/blog/2023/12/17/10-2-inch-3-color-esl/"><![CDATA[<p>书接很久以前的 <a href="/blog/2021/01/14/play-with-2-13-inch-e-ink-display/">这里</a>.
最近机缘巧合又收了一个 10.2 寸的黑白红墨水屏价签. 很新, 屏幕保护膜都没撕, 又可见倒闭的公司库存.</p>

<p><img src="/assets/esl-10in2.jpeg" alt="ESL 10in2" /></p>

<p>可惜后盖上的贴纸不见了, 不知道是哪家公司的. 先拆拆看.</p>

<h2 id="拆解">拆解</h2>

<p>目前市面上大大小小价签很多种, 拆解价签的方法大同小异. 拆价签翻车的案例太多, 尤其大屏幕, 一旦翻车就是一顿外卖的损失.
所以拆解前一定要做好功课, 了解屏幕的结构, 以及拆解的方法.
卡扣一般会特别紧, 需要较薄的刀片, 但又不能太薄, 否则可能会受伤. 比如这个:</p>

<p><img src="/assets/esl-10in2-toolkit.jpeg" alt="ESL Teardown Toolkit" /></p>

<p>另外加上软质塑料片, 这玩意文具店很多, 用来拆解屏幕背面和 PCB 的双面胶.</p>

<p><img src="/assets/esl-10in2-back.jpeg" alt="ESL Back Remoted" /></p>

<p>撬开后电池盖, 注意卡扣位置. 然后取掉电池. 方便之后取出 PCB.</p>

<p>然后就是拆卡扣, 从屏幕背面的一个开口处开始, 用刀片, 慢慢撬一圈卡扣,
注意不要伤到自己和屏幕边缘.</p>

<p><img src="/assets/esl-10in2-teardown-1.jpeg" alt="ESL Back Teardown Start" /></p>

<p><img src="/assets/esl-10in2-teardown-2.jpeg" alt="ESL Back Teardown Knot Removed" /></p>

<p><img src="/assets/esl-10in2-teardown-3.jpeg" alt="ESL Back Teardown Removing Tape" /></p>

<p>卡扣分离后, 这时候可以用软质塑料片, 伸进去, 慢慢拆开 PCB 和后盖的双面胶.</p>

<p>PCB 也是用双面胶贴在屏幕背后的, 这一步是最容易翻车的, 一定要慢慢来. 塑料片伸进去横向推, 一点一点的推开 PCB 和背板的双面胶.</p>

<p><img src="/assets/esl-10in2-teardown-4.jpeg" alt="ESL Back Teardown PCB Removed 1" /></p>

<p><img src="/assets/esl-10in2-teardown-5.jpeg" alt="ESL Back Teardown PCB Removed 2" /></p>

<p>PCB 丝印: Endor Telink1020 2021-07-22 change U5, 可见这是 BLOZI(保资) 的价签. 但是在今天, 他家官网都是挂的.
难道价签厂家也倒闭了…</p>

<p>24pin 屏幕排线丝印: HINK-E102A01-A1, 搜索可以找到全网唯一参考资料<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, 虽然是个 CSDN, 但提供了不少线索,
里面说明了驱动 IC 是 SSD1677, 微雪 3in7 也使用了相同驱动 IC, 但那是一个黑白屏幕.</p>

<p>如果没有找到对应的驱动 IC, 那可能就需要参考 <a href="https://www.youtube.com/watch?v=t_YXjM7Keqw">wenting</a> 的方法逆向了.
请自行学习.</p>

<h2 id="驱动">驱动</h2>

<p>拆解完成后就可以尝试驱动了. 一般来说, 24pin 就是 AIO(All-In-One) 串口屏了, 驱动版都是通用的.
这里随便找了一个驱动板(咸鱼), 使用 RPi Pico(RP2040 MCU) 来驱动. 开发框架使用 Rust <a href="https://embassy.dev/">embassy</a>.</p>

<p>Rust embedded-graphics 提供了非常方便的 Framebuffer API(注意, 没有屏幕旋转支持).</p>

<p>传统情况下, 我们只需要实现一个 <code class="language-plaintext highlighter-rouge">Display</code> trait, 就可以使用 embedded-graphics 的各种绘图 API 了.
但这里, 我们再抽象一级, 直接预留一个 <code class="language-plaintext highlighter-rouge">update_frame(raw: &amp;[u8])</code> 接口, 直接接收 <code class="language-plaintext highlighter-rouge">Framebuffer::data()</code> 作为参数.
这是在经历了 <a href="https://github.com/embedded-drivers/epd">epd</a> 项目之后, 尝试七八种屏幕之后发现最合适最通用的方法.</p>

<p>先写个骨架, 一切 SPI 串口 EPD 都可以这样搞, 唯一需要注意的是部分驱动 IC 的 BUSY 使用反逻辑:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">EPD10in2</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">spi</span><span class="p">:</span> <span class="n">Spi</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">SPI0</span><span class="p">,</span> <span class="n">Blocking</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">dc</span><span class="p">:</span> <span class="n">Output</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">busy</span><span class="p">:</span> <span class="n">Input</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">EPD10in2</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">send_command</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.dc</span><span class="nf">.set_low</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.spi</span><span class="nf">.blocking_write</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">cmd</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">send_data</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.dc</span><span class="nf">.set_high</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.spi</span><span class="nf">.blocking_write</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">send_command_data</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.send_data</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">busy_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.busy</span><span class="nf">.is_low</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">info!</span><span class="p">(</span><span class="s">"busy out"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">refresh</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="bwr-驱动---三色">BWR 驱动 - 三色</h3>

<p>微雪驱动使用了自定义黑白 LUT 和 4 阶灰度的 LUT 来驱动, 但个人经验是, 自定义 LUT 方法不适合三色 BWR 屏幕.
除非确定 LUT 来自厂家调教.
三色屏幕建议使用出厂的 OTP LUT(One-time-programming LUT). 这样可以保证屏幕的寿命, 也直接使用厂商调教过的颜色效果.
否则电子墨水屏在 LUT 表错误的情况下, 极容易永久性损坏, 例如我手头有若干永久性残影的屏幕.</p>

<p>当然, 的确是可以自己调教三色 LUT 逻辑, 相关论文有不少, 例如 Zeng, W.; Yi, Z.; Zhou, X.; Zhao, Y.; Feng, H.; Yang, J.; Liu, L.; Chi, F.; Zhang, C.; Zhou, G. Design of Driving Waveform for Shortening Red Particles Response Time in Three-Color Electrophoretic Displays. Micromachines 2021, 12, 578. <a href="https://doi.org/10.3390/mi12050578">https://doi.org/10.3390/mi12050578</a>. 请沿着引文链自行探索.</p>

<p>一般来说, 三色墨水屏在墨囊黑白粒子之外额外加入了第三种颜色的粒子, 例如红色, 黄色.
彩色粒子的带电量和粘度(粒子物理运动特性)和黑色粒子可以通过较弱电压区分.
驱动过程大概是: 清屏, 激活(让黑色和彩色粒子尽可能分层而不是黏在一起), 然后利用较弱电压, 使得彩色粒子在屏幕上浮动, 形成彩色图像.</p>

<p>通读 SSD1677 的数据手册, 对照微雪的驱动代码, 找到核心修改点. 几乎所有 EPD 驱动 IC 的手册都是极其含糊,
这个也不例外. 其中一些关键词, 可能是需要你通读过其他同类型驱动 IC 才能理解.</p>

<p><img src="/assets/ssd1677-lut-mapping.jpeg" alt="SSD1677 LUT Mapping" /></p>

<p>SSD1677 有如上两种模式, 一种是 BWR 三色, 一种是黑白两色. 按照不同方式使用 LUT.</p>

<p><img src="/assets/ssd1677-cmd-display-ctrl-2.jpeg" alt="SSD1677 Display Update Control 2" /></p>

<!-- ![SSD1677 Load WS OTP](/assets/ssd1677-cmd-load-ws-otp.jpeg) -->

<p><img src="/assets/ssd1677-cmd-write-display-option.jpeg" alt="SSD1677 Write Display Option" /></p>

<p>这两个含糊的 Command 描述文档, 隐藏了 BWR 驱动的细节.</p>

<ul>
  <li>Display Mode 1 即 BWR 三色模式, Display Mode 2 为黑白模式</li>
  <li>Display Update Control 2 命令的 0x99 和 0x91 分别可以加载不同模式的 OTP LUT
    <ul>
      <li>0xC7, 0xCF 决定了最终刷新使用的 Display Mode</li>
    </ul>
  </li>
  <li>Write Display Option 命令中设置了 WS(LUT) 不同时间片对应的 Display Mode</li>
</ul>

<p>那么这里, 我们直接加载 Display Mode 1 的 OTP LUT, 然后使用 Display Update Control 2(with Display Mode 1) 命令刷新.</p>

<p>由此修改 <code class="language-plaintext highlighter-rouge">init()</code> 函数:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x12</span><span class="p">);</span> <span class="c1">// Soft reset</span>
        <span class="n">Delay</span><span class="nf">.delay_ms</span><span class="p">(</span><span class="mi">20_u32</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x46</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0xF7</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.busy_wait</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x47</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0xF7</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.busy_wait</span><span class="p">();</span>

        <span class="c1">// Driver output control</span>
        <span class="c1">// 0x27F = 639</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x01</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x7F</span><span class="p">,</span> <span class="mi">0x02</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">]);</span>

        <span class="c1">// set gate voltage</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x03</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">]);</span>
        <span class="c1">// set source voltage</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x04</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x41</span><span class="p">,</span> <span class="mi">0xA8</span><span class="p">,</span> <span class="mi">0x32</span><span class="p">]);</span> <span class="c1">// POR</span>

        <span class="c1">// set data entry sequence</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x11</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x03</span><span class="p">]);</span>

        <span class="c1">// set border</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x3C</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x03</span><span class="p">]);</span>

        <span class="c1">// set booster strength</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x0C</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0xAE</span><span class="p">,</span> <span class="mi">0xC7</span><span class="p">,</span> <span class="mi">0xC3</span><span class="p">,</span> <span class="mi">0xC0</span><span class="p">,</span> <span class="mi">0xC0</span><span class="p">]);</span>

        <span class="c1">// set internal sensor on</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x18</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x80</span><span class="p">]);</span>

        <span class="c1">// set vcom value</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x2C</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x44</span><span class="p">]);</span>

        <span class="c1">// setting X direction start/end position of RAM</span>
        <span class="c1">// 640 -&gt; 639 =&gt; 0x27F</span>
        <span class="c1">// 960 -&gt; 959 =&gt; 0x3BF</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x44</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0xBF</span><span class="p">,</span> <span class="mi">0x03</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x45</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x7F</span><span class="p">,</span> <span class="mi">0x02</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4E</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4F</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">]);</span>

        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x37</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">;</span> <span class="mi">10</span><span class="p">]);</span> <span class="c1">// Use Mode 1 !!!</span>

        <span class="c1">// Load Waveform !!!</span>
        <span class="c1">// 0x91, Load LUT with Mode 1</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x22</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x91</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x20</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.busy_wait</span><span class="p">();</span>

        <span class="c1">// Display Update Control 2</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x22</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0xCF</span><span class="p">]);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>除了屏幕大小设定的修改, 最核心的用 <code class="language-plaintext highlighter-rouge">!!!</code> 标注.</p>

<p>补齐写 RAM 函数和屏幕刷新函数:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_bw_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// self.send_command_data(0x4E, &amp;[0x00, 0x00]);</span>
        <span class="c1">// self.send_command_data(0x4F, &amp;[0x00, 0x00]);</span>

        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x24</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.send_data</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_red_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// self.send_command_data(0x4E, &amp;[0x00, 0x00]);</span>
        <span class="c1">// self.send_command_data(0x4F, &amp;[0x00, 0x00]);</span>

        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x26</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.send_data</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">refresh</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">Delay</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x20</span><span class="p">);</span> <span class="c1">// Master activation</span>
        <span class="n">delay</span><span class="nf">.delay_ms</span><span class="p">(</span><span class="mi">100_u32</span><span class="p">);</span> <span class="c1">//must</span>
        <span class="k">self</span><span class="nf">.busy_wait</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>在屏幕大小正确设定的前提下, 0x4E/0x4F(RAM 当前 X/Y) 可以只写一次, 之后就不需要了, 自动增长.</p>

<p>为了测试效果, 我们找一张 LLM 生成的图. 由于屏幕是 960x640, 而一般 LLM 生成的图是正方形, 需要进行缩放.
这里可以使用 Context Aware Image Resizing(CAIR) 算法, 或者传统直接缩放.</p>

<p>考虑到我们的屏幕只有三种颜色, 无法体现图片的丰富彩色和灰度细节, 需要使用抖动 (Diffusion Dithering) 来模拟灰度.
然后提取 BW frame 和 Red frame, 分别写 RAM. 相关任务可以通过 ImageMagick 完成:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>convert ~/Downloads/_34f9c9ae-d1c2-47a9-ab55-089ffc7cb626.jpeg <span class="nt">-size</span> 960x640 <span class="nt">-dither</span> FloydSteinberg <span class="nt">-remap</span> 3color.gif out.gif
</code></pre></div></div>

<p>这里 <code class="language-plaintext highlighter-rouge">3color.gif</code> 是只包含红黑白三色的索引色图, 用来提供调色板. <code class="language-plaintext highlighter-rouge">out.gif</code> 是经过抖动处理的图片.</p>

<p>之前突然想到, Rust 的过程宏不就是在编译期执行的吗? 于是就写了个过程宏, 用来自动加载图片, 提取 BW/Red frame.
项目在 <a href="https://github.com/andelf/text-image">text-image</a>.</p>

<p>全部刷新大概需要 20 秒左右, 最终效果如下:</p>

<p><img src="/assets/esl-10in2-bwr.jpeg" alt="BWR Image with Dithering" /></p>

<h3 id="bw-驱动---黑白双色">BW 驱动 - 黑白双色</h3>

<p>通过前面的描述, 其实大家都会发现, 首先 SSD1677 本身就支持三色和双色驱动两种模式,
且三色屏幕的彩色粒子和黑色粒子如果一同处理, 那完全是可以把三色屏幕当做双色屏幕来驱动的.</p>

<p>方法1: 依然使用三色模式, 只不过 RED RAM 永远置空. 这是最简单的, 不需要修改任何代码, 但需要忍受长大 20 秒的刷新时间.</p>

<p>方法2: 启用驱动 IC 的双色模式?</p>

<p>这里主要介绍双色模式, 它的好处是, 刷新速度可以调教到更快, 并且有可能支持灰度显示, 以及快速局部刷新.
黑白双色模式最主要的是驱动像素到新的状态, 需要拿到前一状态和目标状态, 然后执行对应的波形. 这需要驱动 IC 有对应的支持.</p>

<p>这里是驱动 IC 手册中含糊没有介绍清楚的部分:</p>

<p><img src="/assets/ssd1677-lut.jpeg" alt="SSD1677 LUT" /></p>

<p>可见 LUT 表和 <a href="/blog/2021/01/14/play-with-2-13-inch-e-ink-display/">上一篇文章</a> 中的类似, 但似乎缺乏核心的 “AB” 概念? 其实不然.
我们大致按照 Display Mode 1 整理得到格式是:</p>

<ul>
  <li>VS - L0(LUT0) - for BLACK</li>
  <li>VS - L1(LUT1) - for WHITE</li>
  <li>VS - L2(LUT2) - for RED (R=1, B/W=0)</li>
  <li>VS - L3(LUT3) - for RED (R=1, B/W=1), LUT3=LUT2</li>
  <li>VS - L4(LUT4) - reserved</li>
  <li>TP / RP - time period / repeat</li>
  <li>FR - Frame Rate</li>
</ul>

<p>而按照 Display Mode 2, 经过测试, 发现 LUT 是:</p>

<ul>
  <li>VS - L0(LUT0) - Black to Black</li>
  <li>VS - L1(LUT1) - Black to White</li>
  <li>VS - L2(LUT2) - White to Black</li>
  <li>VS - L3(LUT3) - White to White</li>
  <li>(其他部分一致)</li>
</ul>

<p>可见, 这里其实是有新旧 AB 转换的概念的, 实测发现在 Display Mode 2 下,
0x24 B/W RAM 表示当前(目标/NEW)显示状态, 0x26 Red RAM 则是上一(OLD)状态.
那么看起来就可以实现快速刷新了. 只需要我们在写入新内容到 NEW RAM 同时, 把旧内容写入 OLD RAM.
驱动 IC 将自动使用 OLD/NEW 信息执行对应的波形, 完成像素位的状态转换.</p>

<p>那么是不是有种方法可以让驱动 IC 自动完成这个过程呢? 答案是肯定的. 这个功能在不同驱动 IC 的叫法不同,
比如在 UCxxxx 系列手册中, 叫做 N2OCP (New to Old Copy), 在 SSD1677 中, 叫做 “RAM ping-pong”.</p>

<p>翻看上面 0x37 Write Display Option 命令的 <code class="language-plaintext highlighter-rouge">F[6]</code> 位, 可以看到 “RAM Ping-Pong for Display Mode 2” 的描述.
且同时告知, 只有 Display Mode 2(黑白双色) 支持这个功能.</p>

<p>简单对 <code class="language-plaintext highlighter-rouge">init()</code> 函数做修改, 这里只贴出修改的部分:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ....</span>

        <span class="c1">// Display Option</span>
        <span class="nd">#[rustfmt::skip]</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x37</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span>
            <span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//B</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//C</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//D</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//E</span>
            <span class="c1">// 0x0F, RAM ping-pong disable</span>
            <span class="c1">// 0x4F, RAM ping-pong enable</span>
            <span class="mi">0x4F</span><span class="p">,</span> <span class="c1">//F, RAM ping-pong enable. only in Display Mode 2</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//G</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//H</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//I</span>
            <span class="mi">0xFF</span><span class="p">,</span> <span class="c1">//J</span>
        <span class="p">]);</span> <span class="c1">// MODE 2</span>

        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x22</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x99</span><span class="p">]);</span> <span class="c1">// Load LUT with Mode 2</span>
        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x20</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.busy_wait</span><span class="p">();</span>

        <span class="c1">// Display Update Control 2</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x22</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0xCF</span><span class="p">]);</span>
    <span class="p">}</span>

</code></pre></div></div>

<p>废话不多说, 我们编写一张快速刷新的波形, 前置条件是需要屏幕是纯白的, 也就是刚刚清屏后的状态. 这可以通过 OTP LUT 实现.
这里只关注我们需要的黑色和白色状态.</p>

<ul>
  <li>对于 Black to Black 和  White to White, 什么都不做</li>
  <li>Black to White, 加 VSL 电压, 若干周期</li>
  <li>White to Black, 加 VSH 电压, 若干周期</li>
</ul>

<p>经过测试, 我们得到了如下 LUT, 简洁到惊人. <code class="language-plaintext highlighter-rouge">0x0F</code> 是个人测试的值, 即 15 个周期. RP=0 表示只重复一次.
相关内容和上一篇文章介绍的大同小异.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">configure_partial_update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">#[rustfmt::skip]</span>
        <span class="k">const</span> <span class="n">LUT</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span>
            <span class="mi">0b00_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT0, B2B</span>
            <span class="mi">0b10_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT1, B2W</span>
            <span class="mi">0b01_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT2, W2B</span>
            <span class="mi">0b00_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT3, W2W</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT5, reserved</span>
            <span class="c1">// TP[xA, xB, xC, xD], RP</span>
            <span class="mi">0x0F</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//7</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//9</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="c1">// FR</span>
            <span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span>
        <span class="p">];</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x32</span><span class="p">,</span> <span class="n">LUT</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>而此时只需要写入 0x24 B/W RAM, 就可实现快速刷新, 实测大概 1s 左右即可完成刷屏. 且无闪动.</p>

<h3 id="bw-驱动---灰度大法">BW 驱动 - 灰度大法</h3>

<p>看着 0x0F 这个时间周期值, 是不是手痒. 没错, 我们可以尝试调整这个值, 从而实现灰度显示.
灰度显示对于阅读器类应用意义重大, 矢量字体的抗锯齿渲染, 以及图片的灰度显示, 都可以大大提升用户体验.</p>

<p>这里假设我们需要实现 16 级别灰度, 正好对应 0x00 ~ 0x0F.</p>

<ul>
  <li>可以刷屏 16 次, 每次刷入 1/16 的灰度层次, 朴素但是可行</li>
  <li>!! 刷屏 4 次, 分别是 8, 4, 2, 1 个周期, 从而实现 16 级灰度, 相当于只用了 4 倍刷新时间</li>
</ul>

<p>废话不多说, 直接上代码:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cd">/// Level 0 to 15</span>
    <span class="k">fn</span> <span class="nf">configure_gray_update_level</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">#[rustfmt::skip]</span>
        <span class="k">let</span> <span class="n">lut</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span>
            <span class="mi">0b01_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT0, B2B</span>
            <span class="mi">0b00_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT1, B2W</span>
            <span class="mi">0b01_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT2, W2B</span>
            <span class="mi">0b00_00_00_00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//LUT3, W2W</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//5</span>
            <span class="c1">// TP[xA, xB, xC, xD], RP</span>
            <span class="n">level</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//7</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="c1">//9</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span><span class="mi">0x00</span><span class="p">,</span>
            <span class="c1">// FR</span>
            <span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span><span class="p">,</span><span class="mi">0x22</span>
        <span class="p">];</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x32</span><span class="p">,</span> <span class="n">lut</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">refresh_gray4_image</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">level</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// level: (8, 4, 2, 1)</span>
            <span class="k">self</span><span class="nf">.configure_gray_update_level</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">level</span><span class="p">);</span>
            <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x24</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">buf</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">b</span> <span class="k">in</span> <span class="n">chunk</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">0x10</span> <span class="o">&lt;&lt;</span> <span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="c1">// 0xFF is white, 0x00 is black</span>
                <span class="k">self</span><span class="nf">.send_data</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="nf">.refresh</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">refresh_gray2_image</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">level</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
            <span class="c1">// level: 9, 5</span>
            <span class="k">self</span><span class="nf">.configure_gray_update_level</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x24</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="n">buf</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">b</span> <span class="k">in</span> <span class="n">chunk</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">0b01_00_00_00</span> <span class="o">&lt;&lt;</span> <span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">0b00_01_00_00</span> <span class="o">&lt;&lt;</span> <span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">0b00_00_01_00</span> <span class="o">&lt;&lt;</span> <span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">0b00_00_00_01</span> <span class="o">&lt;&lt;</span> <span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="c1">// 0xFF is white, 0x00 is black</span>
                <span class="k">self</span><span class="nf">.send_data</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="nf">.refresh</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>以上代码中, <code class="language-plaintext highlighter-rouge">refresh_gray4_image</code> 和 <code class="language-plaintext highlighter-rouge">refresh_gray2_image</code> 分别是 4 级和 2 级灰度的刷新函数.
这里对灰度的每一位的权重映射做了微调.
格式兼容 embedded-graphics 中的 Framebuffer 和 Image 类型, 可以直接使用.
其中的 bit 操作, 其实基本上是 Github Copilot 写的, 我只是稍微修改了下边界情况和编译错误,
实现不是最优, 但好理解.</p>

<p>显示效果, 这里以互联网 UGC 时代的化石, 徐静蕾手写体为例:</p>

<p><img src="/assets/esl-10in2-grayscale.jpeg" alt="Gray4 for Font Renderring" /></p>

<p>你猜我抗锯齿字体怎么渲染的? 没错, 还是 <a href="https://github.com/andelf/text-image">text-image</a> 过程宏, 使用方法:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span> <span class="o">=</span> <span class="nn">text_image</span><span class="p">::</span><span class="nd">text_image!</span><span class="p">(</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s">"北京市发布持续低温黄色预警</span><span class="se">\n</span><span class="s">北京市发布道路结冰橙色预警</span><span class="se">\n\n</span><span class="s">-12.5℃ </span><span class="se">\n</span><span class="s">-16℃ -- -7℃</span><span class="se">\n</span><span class="s">相对湿度 36%</span><span class="se">\n</span><span class="s">东北风 1级"</span><span class="p">,</span>
    <span class="n">font</span> <span class="o">=</span> <span class="s">"./徐静蕾手写体.ttf"</span><span class="p">,</span>
    <span class="n">font_size</span> <span class="o">=</span> <span class="mf">48.0</span><span class="p">,</span>
    <span class="n">line_spacing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">inverse</span><span class="p">,</span>
    <span class="n">Gray4</span><span class="p">,</span>
<span class="p">);</span>

<span class="nd">info!</span><span class="p">(</span><span class="s">"w: {}, h: {}"</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

<span class="n">epd</span><span class="nf">.set_partial_refresh</span><span class="p">(</span><span class="nn">Rectangle</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Point</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">160</span><span class="p">),</span> <span class="nn">Size</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)));</span>
<span class="n">epd</span><span class="nf">.refresh_gray4_image</span><span class="p">(</span><span class="n">raw</span><span class="p">);</span>
</code></pre></div></div>

<p>当然这里用到了 “局部刷新” 函数, 我们这就介绍.</p>

<h3 id="局部刷新">局部刷新</h3>

<p>局部刷新是指, 只刷新屏幕的一个矩形部分, 而不是整屏刷新. 这在阅读器类应用中, 是非常重要的功能.
包括弹出式菜单, 局部 UI 元素等都可以用到.
在日历天气中, 局部刷新可以只刷新时间或天气的一小部分, 而不是整屏刷新, 从而大大提升观感.</p>

<p>实际上局部刷新只需要找驱动 IC 手册中的 RAM X/Y Start/End 关键词即可,
UCxxxx 系列的驱动 IC, 也会直接提供 Partial Update 的相关命令.
这里一笔带过直接上代码:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">fn</span> <span class="nf">clear_as_bw_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// set X/Y ram counter</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4E</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4F</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">]);</span>

        <span class="k">const</span> <span class="n">NBUF</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">960</span> <span class="o">*</span> <span class="mi">640</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x24</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">NBUF</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.send_data</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0xFF</span><span class="p">]);</span> <span class="c1">// W</span>
        <span class="p">}</span>

        <span class="c1">// reset X/Y ram counter</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4E</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4F</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command</span><span class="p">(</span><span class="mi">0x26</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">NBUF</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.send_data</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0xFF</span><span class="p">]);</span> <span class="c1">// Red off</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_partial_refresh</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">rect</span><span class="p">:</span> <span class="n">Rectangle</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// clear old buf</span>
        <span class="k">self</span><span class="nf">.clear_as_bw_mode</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect</span><span class="py">.top_left.x</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">rect</span><span class="nf">.bottom_right</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.x</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">rect</span><span class="py">.top_left.y</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">rect</span><span class="nf">.bottom_right</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.y</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">;</span>

        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x44</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[(</span><span class="n">x0</span> <span class="o">&amp;</span> <span class="mi">0xff</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">x0</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span> <span class="o">&amp;</span> <span class="mi">0xff</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x45</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[(</span><span class="n">y0</span> <span class="o">&amp;</span> <span class="mi">0xff</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">y0</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">y1</span> <span class="o">&amp;</span> <span class="mi">0xff</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">y1</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">]);</span>
        <span class="c1">// set X/Y ram counter</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4E</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[(</span><span class="n">x0</span> <span class="o">&amp;</span> <span class="mi">0xff</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">x0</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">]);</span>
        <span class="k">self</span><span class="nf">.send_command_data</span><span class="p">(</span><span class="mi">0x4F</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[(</span><span class="n">y0</span> <span class="o">&amp;</span> <span class="mi">0xff</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="n">y0</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">]);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>需要注意的是:</p>

<ul>
  <li>在开启局部刷新前需要处理好 OLD/NEW RAM 的状态, 这里选择直接清空</li>
  <li>X/Y RAM counter 需要设置正确</li>
  <li>部分驱动 IC 要求 gate 或 source 边界以 8 对齐, 需要参考手册, 并提前对图片进行裁剪补齐</li>
</ul>

<h2 id="结语">结语</h2>

<p>这里只是简单介绍了如何驱动这块价签, 以及如何实现局部刷新和灰度显示.
其中若干技术可以混用, 例如局部刷新 + 灰度显示, 局部刷新 + 三色显示等等.
屏幕也可以在不同状态下重新初始化, 最终实现的效果, 取决于你的想象力.</p>

<p>原理有了, 剩下的就是点子了. 之前做了一个 <a href="https://www.bing.com/images/create">Bing Image Creator</a>
加随机每日诗词的小工具. 效果还不错, 但一堆粗糙脚本未整理.</p>

<p>一些可能用到的技术再提一遍:</p>

<ul>
  <li>Context Aware Image Resizing(CAIR) - PhotoShop 或一些图形学算法库</li>
  <li>Diffusion Dithering - ImageMagick / PhotoShop</li>
  <li>各种 Text to Image 模型</li>
  <li>我的 <a href="https://github.com/andelf/text-image">text-image</a> 过程宏, 粗糙, 但支持各种图片加载, 字体抗锯齿渲染</li>
  <li>Rust Embedded 我推荐 embassy 框架, 至少它够统一, 而且是 async-first 的
    <ul>
      <li>Rust embedded-graphics 提供了 Framebuffer API, 以及各种图形绘制 API</li>
    </ul>
  </li>
  <li>本项目粗糙代码, 未整理 <a href="https://github.com/andelf/rp-embassy-playground/commit/568eac55c42b9c5682b4c92177090a1fa63842f0">commit</a></li>
</ul>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://blog.csdn.net/lymacadam/article/details/132178619">https://blog.csdn.net/lymacadam/article/details/132178619</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>andelf</name></author><category term="blog" /><category term="embedded" /><category term="epd" /><summary type="html"><![CDATA[书接很久以前的 这里. 最近机缘巧合又收了一个 10.2 寸的黑白红墨水屏价签. 很新, 屏幕保护膜都没撕, 又可见倒闭的公司库存.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://andelf.github.io/assets/esl-10in2-bwr.jpeg" /><media:content medium="image" url="https://andelf.github.io/assets/esl-10in2-bwr.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">使用 Rust 语言 Embassy 嵌入式框架实现 STM32WL LoRa 数据传输</title><link href="https://andelf.github.io/blog/2023/01/23/stm32wl-lora-with-rust-embassy/" rel="alternate" type="text/html" title="使用 Rust 语言 Embassy 嵌入式框架实现 STM32WL LoRa 数据传输" /><published>2023-01-23T04:00:00+00:00</published><updated>2024-06-17T12:43:43+00:00</updated><id>https://andelf.github.io/blog/2023/01/23/stm32wl-lora-with-rust-embassy</id><content type="html" xml:base="https://andelf.github.io/blog/2023/01/23/stm32wl-lora-with-rust-embassy/"><![CDATA[<blockquote>
  <p>2024-06 补充: 相关内容已经过期, 且 lora-rust 项目长达 1 年多是时间删去 CN470 支持后没有再加回来. 本文仅作为历史记录.</p>
</blockquote>

<p>之前参与了 eet-china.com 的开发板测评活动, 申请的板子是 <a href="https://mbb.eet-china.com/evaluating/product-106.html">STM32WLE5 易智联 Lora 评估板(LM401-Pro-Kit)</a>, 正好 Rust Embassy 框架对 STM32WL 系列及其 SubGhz 有不错的支持, 所以打算用这套技术栈进行开发尝试.</p>

<p>本文主要介绍如何使用 Rust 语言的 Embassy 嵌入式框架实现 STM32WL LoRa 数据传输. 过年回老家, 随身带的东西不多, 只有一个迷你 BMP280 (大气压温度)传感器模块, 所以本文使用 BMP280 传感器数据作为例子.</p>

<p>门槛率高, 还是从点灯开始搞起.</p>

<p>最终相关代码位于 <a href="https://github.com/andelf/lm401-pro-kit">Github: andelf/lm401-pro-kit</a>.</p>

<h2 id="介绍">介绍</h2>

<p>快递于 [[2023-01-08]] 收到, 里面的评估板, 天线, 数据线均是两份, 方便开发使用.</p>

<h3 id="开发板介绍">开发板介绍</h3>

<p>LM401-Pro-Kit 是基于 STM32WLE5CBU6 的 Lora 评估板. 支持 SubGHz 无线传输. LM401 模组内嵌高性能 MCU 芯片 STM32WLE5CBU6, 芯片内部集成了 SX1262. 开发板板载 ST-Link(上传下载程序, UART 转 USB). ST-Link 通过跳线帽和模块核心部分连接, 方便单独供电使用模块. 开发板提供了若干 LED 状态灯, 复位按钮和一个用户按钮.</p>

<p>日常屯的(吃灰)板子也有大几十上百了, 拿到新板子, 需要查资料, 看手册, 电路图, 读例程, 找到一些核心信息, 其中一些信息可能需要读例程的 C 代码库才能获得, 这里列出整理的部分:</p>

<ul>
  <li>MCU: STM32WLE5CBU6
    <ul>
      <li>架构: Cortex-M4</li>
      <li>主频: 48MHz, <strong>通过 MSI 提供</strong></li>
      <li>FLASH 128K，RAM 48K</li>
      <li>核心外设: SX1262 via SPI3</li>
    </ul>
  </li>
  <li>LM401: CN470-510MHZ</li>
  <li>板载
    <ul>
      <li>ST-Link 下载器</li>
      <li>用户按钮 PA0</li>
      <li>LED blue PB5, green PB4, yellow PB3</li>
      <li>射频开关:
        <ul>
          <li>FE_CTRL1 PB0</li>
          <li>FE_CTRL2 PA15, LM401 未使用</li>
          <li>FE_CTRL3 PA8</li>
        </ul>
      </li>
      <li>UART RX/TX
        <ul>
          <li>PA2 TXD, USART2_TX, LPUART1_TX</li>
          <li>PA3 RXD, USART2_RX, LPUART1_RX</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="预备知识">预备知识</h3>

<ul>
  <li>对 Rust 的基础了解</li>
  <li>对 STM32 的基础了解</li>
</ul>

<p>使用 Rust 嵌入式开发大概大概有如下几层(只是粗略分类, 实际项目使用中, 可能会混合使用):</p>

<ul>
  <li>直接使用 PAC 库操作寄存器, PAC 库通过 <code class="language-plaintext highlighter-rouge">svd2rust</code> 工具从 <code class="language-plaintext highlighter-rouge">.svd</code> 文件生成</li>
  <li>使用 HAL 库, 例如 stm32f4xx-hal, stm32l0xx-hal, stm32wlxx-hal 等, 融合 <code class="language-plaintext highlighter-rouge">embedded-hal</code> 生态</li>
  <li>使用 Rust 嵌入式框架, 例如 embassy</li>
</ul>

<p>Embassy 框架是基于 Rust 语言的嵌入式异步框架. 考虑到相关框架还在开发中, 本文的代码仓库使用的是最新的 embassy master 分支. Commit hash 为 <code class="language-plaintext highlighter-rouge">f98ba4ebac192e81c46933c0dc1dfb2d907cd532</code>, 通过 <code class="language-plaintext highlighter-rouge">Cargo.toml</code> 中设置依赖 <code class="language-plaintext highlighter-rouge">path</code> 的方式引入. 其他可选方案还可有 <code class="language-plaintext highlighter-rouge">git submodule</code> 或 直接 <code class="language-plaintext highlighter-rouge">git</code> 依赖远程版本等.</p>

<p>绕开 C HAL/BSP 库开发, 是需要踩不少坑的, 例如, RCC 时钟初始化, 需要查阅 BSP 代码才能确认, 48MHz 主时钟通过 MSI range11 获得, 而 embassy 对应 MCU 的示例代码使用的是 HSE, 这些都给 Rust 嵌入式开发带来一定的门槛.</p>

<h3 id="软件环境准备">软件环境准备</h3>

<p>安装 Rust 工具链, 本文使用 rustup nightly. 请参考 https://rustup.rs/ .</p>

<p>安装 Rust <code class="language-plaintext highlighter-rouge">thumbv7em-none-eabi</code> target, 对应 Cortex-M4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rustup target add thumbv7em-none-eabi
</code></pre></div></div>

<p>安装 Rust 嵌入式开发烧录/运行工具 <code class="language-plaintext highlighter-rouge">probe-run</code>, 也可以使用 OpenOCD 或其他烧录工具:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>cargo <span class="nb">install </span>probe-run
<span class="go">...(install log)
</span><span class="gp">&gt;</span><span class="w"> </span>probe-run <span class="nt">--list-chips</span> | <span class="nb">grep </span>STM32WL
<span class="go">STM32WL Series
        STM32WLE5J8Ix
        STM32WLE5JBIx
        STM32WLE5JCIx
        STM32WL55JCIx
</span></code></pre></div></div>

<p>检查发现支持列表没有 STM32WLE5CBU6, 不过可以拿 STM32WLE5JCIx 替代, 问题不大.</p>

<p>安装任意串口调试工具, 这里我使用 <code class="language-plaintext highlighter-rouge">picocom</code>. 其他可以使用的替代有 <a href="https://www.putty.org/">PuTTy</a>, <a href="https://ttssh2.osdn.jp/index.html.en">Teraterm</a> 等等.</p>

<p>通过 USB 数据线连接开发板, 通过 <code class="language-plaintext highlighter-rouge">picocom</code> 连接串口, 通过 <code class="language-plaintext highlighter-rouge">probe-run</code> 烧录程序.</p>

<p>测试连接</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>lsusb
<span class="go">Bus 001 Device 008: ID 0483:374b STMicroelectronics STM32 STLink  Serial: xxxx
</span></code></pre></div></div>

<h2 id="从-blinky-开始-embassy-应用开发">从 Blinky 开始 Embassy 应用开发</h2>

<p>考虑到从初识 Rust 嵌入式开发直接跨越到 LoRa 无线传输门槛较高, 我们从简单的点灯例子开始:</p>

<h3 id="创建项目---初始化-rust-嵌入式项目模板">创建项目 - 初始化 Rust 嵌入式项目模板</h3>

<p>我们直接依赖 embassy 的 master 分支进行开发, 为方便调试, 直接 clone 到本地用相对路径引入依赖:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@github.com:embassy-rs/embassy.git
<span class="c"># or</span>
git clone https://github.com/embassy-rs/embassy.git

<span class="c"># 在同层目录直接创建我们的项目, 起板子名就可以. 相当于一个 BSP 模板可以扩充</span>

cargo new <span class="nt">--lib</span> lm401-pro-kit

<span class="c"># 进入项目目录, 以下命令均在此执行</span>
<span class="nb">cd </span>lm401-pro-kit
</code></pre></div></div>

<p>Rust 嵌入式项目的初始设置需要请参考项目代码</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.cargo/config.toml</code>
    <ul>
      <li>设置编译器 target 到 <code class="language-plaintext highlighter-rouge">thumbv7em-none-eabi</code></li>
      <li>设置 <code class="language-plaintext highlighter-rouge">cargo run</code> 的执行方式为调用 <code class="language-plaintext highlighter-rouge">probe-run ...</code></li>
      <li>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[target.'cfg(all(target_arch = "arm", target_os = "none"))']
runner = "probe-run --chip STM32WLE5JCIx"

[build]
target = "thumbv7em-none-eabi"
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">build.rs</code>
    <ul>
      <li>设置 <code class="language-plaintext highlighter-rouge">link.x</code>/<code class="language-plaintext highlighter-rouge">memory.x</code> 链接过程中所用配置, 编译过程中由 embassy 自动按照芯片选择生成</li>
      <li>添加 <code class="language-plaintext highlighter-rouge">defmt</code> 链接参数支持</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Cargo.toml</code>
    <ul>
      <li>添加 <code class="language-plaintext highlighter-rouge">embassy</code> 相关依赖, 并通过 <code class="language-plaintext highlighter-rouge">features</code> 设置相关参数</li>
      <li>添加项目依赖, defmt, cortex-m 相关等</li>
      <li>设置编译参数 <code class="language-plaintext highlighter-rouge">opt-level = "z"</code>, 最小化编译二进制大小</li>
      <li>
        <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># part of Cargo.toml</span>
<span class="nn">[dependencies]</span>
<span class="c"># ...</span>
<span class="py">embassy-stm32</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span><span class="p">,</span> <span class="py">path</span> <span class="p">=</span> <span class="s">"../embassy/embassy-stm32"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span>
    <span class="s">"nightly"</span><span class="p">,</span>
    <span class="s">"defmt"</span><span class="p">,</span>
    <span class="s">"stm32wle5cb"</span><span class="p">,</span>
    <span class="s">"time-driver-any"</span><span class="p">,</span>
    <span class="s">"memory-x"</span><span class="p">,</span>
    <span class="s">"subghz"</span><span class="p">,</span>
    <span class="s">"unstable-pac"</span><span class="p">,</span>
    <span class="s">"exti"</span><span class="p">,</span>
<span class="p">]</span> <span class="p">}</span>
<span class="c"># ...</span>
<span class="nn">[profile.dev]</span>
<span class="py">opt-level</span> <span class="p">=</span> <span class="s">"z"</span> <span class="c"># Optimize for size.</span>

<span class="nn">[profile.release]</span>
<span class="py">lto</span> <span class="p">=</span> <span class="kc">true</span>
<span class="py">opt-level</span> <span class="p">=</span> <span class="s">"z"</span> <span class="c"># Optimize for size.</span>
</code></pre></div>        </div>
      </li>
      <li>defmt 是一个非常好用的 Rust 嵌入式调试打印, 对 STM32(ST-Link) 有很好的支持.</li>
      <li><code class="language-plaintext highlighter-rouge">stm32wle5cb</code> 用于选择 STM32WLE5CBU6 的芯片配置, <code class="language-plaintext highlighter-rouge">subghz</code> 用于选择 SubGHz 驱动.</li>
      <li><code class="language-plaintext highlighter-rouge">memory-x</code> 自动生成链接所需的 <code class="language-plaintext highlighter-rouge">memory.x</code> 文件(FLASH, SRAM 的大小和内存位置).</li>
    </ul>
  </li>
  <li>未避免编译报错, 还需要清空 <code class="language-plaintext highlighter-rouge">src/lib.rs</code> 项目初始文件, 用 <code class="language-plaintext highlighter-rouge">#![no_std]</code> 替代</li>
</ul>

<p>几乎所有的 Rust 嵌入式项目都是 <code class="language-plaintext highlighter-rouge">no_std</code> 的, 这意味着无法简单地使用所有带内存分配类型. 本例中, 我们使用 <code class="language-plaintext highlighter-rouge">heapless</code> crate 中提供的栈分配类型来替代 <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p>注意到, 创建项目时候使用了 <code class="language-plaintext highlighter-rouge">cargo new --lib</code>, 相当于我们创建的是一个 library 项目. 这不需要担心, <code class="language-plaintext highlighter-rouge">cargo run</code> 会自动识别 <code class="language-plaintext highlighter-rouge">src/bin/xxx.rs</code> 为 “可执行” 二进制目标. 通过 <code class="language-plaintext highlighter-rouge">cargo run --bin xxx</code> 即可运行对应程序. 也可以通过 <code class="language-plaintext highlighter-rouge">examples/xxx.rs</code> 的方法管理多个可执行二进制目标.</p>

<h3 id="blinky-点灯---初识-rust-embassy">Blinky 点灯 - 初识 Rust Embassy</h3>

<p>我们先通过一个最简单的闪灯例子来熟悉 Rust Embassy 的使用. 创建 <code class="language-plaintext highlighter-rouge">src/bin/blinky.rs</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// blinky.rs</span>
<span class="nd">#![no_std]</span>
<span class="nd">#![no_main]</span>
<span class="nd">#![feature(type_alias_impl_trait)]</span>

<span class="k">use</span> <span class="nn">defmt</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_executor</span><span class="p">::</span><span class="n">Spawner</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">gpio</span><span class="p">::{</span><span class="n">Level</span><span class="p">,</span> <span class="n">Output</span><span class="p">,</span> <span class="n">Speed</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">embassy_time</span><span class="p">::{</span><span class="n">Duration</span><span class="p">,</span> <span class="n">Timer</span><span class="p">};</span>
<span class="k">use</span> <span class="p">{</span><span class="n">defmt_rtt</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">panic_probe</span> <span class="k">as</span> <span class="n">_</span><span class="p">};</span>

<span class="nd">#[embassy_executor::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">_spawner</span><span class="p">:</span> <span class="n">Spawner</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nf">init</span><span class="p">(</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>
    <span class="nd">info!</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">led</span> <span class="o">=</span> <span class="nn">Output</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">p</span><span class="py">.PB4</span><span class="p">,</span> <span class="nn">Level</span><span class="p">::</span><span class="n">High</span><span class="p">,</span> <span class="nn">Speed</span><span class="p">::</span><span class="n">Low</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"high"</span><span class="p">);</span>
        <span class="n">led</span><span class="nf">.set_high</span><span class="p">();</span>
        <span class="nn">Timer</span><span class="p">::</span><span class="nf">after</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>

        <span class="nd">info!</span><span class="p">(</span><span class="s">"low"</span><span class="p">);</span>
        <span class="n">led</span><span class="nf">.set_low</span><span class="p">();</span>
        <span class="nn">Timer</span><span class="p">::</span><span class="nf">after</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">#![no_main]</code> 用于告诉 Rust 编译器, 我们不使用 Rust 提供的 <code class="language-plaintext highlighter-rouge">main</code> 函数做程序入口. <code class="language-plaintext highlighter-rouge">#[embassy_executor::main]</code> 是一个宏, 用于包装 <code class="language-plaintext highlighter-rouge">async fn main()</code> 函数, 由 embassy-executor 提供了一个 futures runtime, 所以可以使用 <code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">await</code> 语法. 底层实现中, <code class="language-plaintext highlighter-rouge">.await</code> 通过 STM32 的 WFE/SEV 等待指令和中断唤醒指令实现, 实现了程序逻辑在等待时候的低功耗.
<code class="language-plaintext highlighter-rouge">Spawner</code> 还可以用来启动其他 <code class="language-plaintext highlighter-rouge">async fn</code> 函数, 实现了多任务的功能.</p>

<p><code class="language-plaintext highlighter-rouge">#![feature(type_alias_impl_trait)]</code> 在 embassy 中被广泛使用, 需要开启. Embassy 中经常能看到形如 <code class="language-plaintext highlighter-rouge">irq: impl Peripheral&lt;P = T::Interrupt&gt; + 'd</code> 的类型签名.</p>

<p><code class="language-plaintext highlighter-rouge">let p = embassy_stm32::init(Default::default());</code> 直接初始化了所有的外设, 并返回一个 <code class="language-plaintext highlighter-rouge">Peripherals</code> 对象.
通过 Rust 的 move 语义保证不同外设使用之间不会出现竞争.</p>

<p><code class="language-plaintext highlighter-rouge">let mut led = Output::new(p.PB4, Level::High, Speed::Low);</code> 创建了一个 <code class="language-plaintext highlighter-rouge">Output</code> 对象, 用于控制 PB4 引脚.
<code class="language-plaintext highlighter-rouge">Output</code> 对象是一个 <code class="language-plaintext highlighter-rouge">Pin</code> 的 trait, 通过 <code class="language-plaintext highlighter-rouge">set_high</code> 和 <code class="language-plaintext highlighter-rouge">set_low</code> 方法可以控制引脚电平. 这里会自动完成对 GPIOB PB4 的所有初始化和设置, 包括外设时钟使能, 状态设置等.</p>

<p><code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">warn!</code> 等都是 <code class="language-plaintext highlighter-rouge">defmt</code> 的宏, 用于通过 ST-Link 提供的 Debug 通道打印调试信息. 强烈推荐使用, 否则嵌入式开发中, 只能用串口打印信息.</p>

<p><code class="language-plaintext highlighter-rouge">Timer::after(Duration::from_millis(1000)).await</code> 是一个异步等待 1 秒的方法, 通过 <code class="language-plaintext highlighter-rouge">embassy-time</code> crate 实现. 在 <code class="language-plaintext highlighter-rouge">Cargo.toml</code> 中的 <code class="language-plaintext highlighter-rouge">time-driver-any</code> feature 选择了任意可用 timer 实现, 默认是 TIM2, 由 embassy-stm32 提供给 <code class="language-plaintext highlighter-rouge">embassy-time</code>.</p>

<p>确保板子连接正常, 直接运行:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>cargo run <span class="nt">--bin</span> blinky
<span class="go">    Finished dev [optimized + debuginfo] target(s) in 0.32s
     Running `probe-run --chip STM32WLE5JCIx target/thumbv7em-none-eabi/debug/blinky`
(HOST) INFO  flashing program (14 pages / 14.00 KiB)
(HOST) INFO  success!
────────────────────────────────────────────────────────────────────────────────
0.000000 DEBUG rcc: Clocks { sys: Hertz(4000000), apb1: Hertz(4000000), apb1_tim: Hertz(4000000), apb2: Hertz(4000000), apb2_tim: Hertz(4000000), apb3: Hertz(4000000), ahb1: Hertz(4000000), ahb2: Hertz(4000000), ahb3: Hertz(4000000) }
└─ embassy_stm32::rcc::set_freqs @ ./embassy/embassy-stm32/src/fmt.rs:125
0.000113 INFO  Hello World!
</span><span class="gp">└─ blinky::____embassy_main_task::{async_fn#</span>0<span class="o">}</span> @ src/bin/blinky.rs:14
<span class="go">0.000552 INFO  high
</span><span class="gp">└─ blinky::____embassy_main_task::{async_fn#</span>0<span class="o">}</span> @ src/bin/blinky.rs:19
<span class="go">1.001157 INFO  low
</span><span class="gp">└─ blinky::____embassy_main_task::{async_fn#</span>0<span class="o">}</span> @ src/bin/blinky.rs:23
<span class="go">2.001811 INFO  high
</span></code></pre></div></div>

<ul>
  <li>二进制编译成功后, 由 <code class="language-plaintext highlighter-rouge">probe-run</code> 烧录到 MCU 并执行, 持续获取 defmt 打印信息</li>
  <li><code class="language-plaintext highlighter-rouge">rcc: Clocks</code> 调试时钟信息由 <code class="language-plaintext highlighter-rouge">embassy-stm32</code> 库 <code class="language-plaintext highlighter-rouge">embassy_stm32::rcc::set_freqs</code> 打印</li>
  <li>所有 defmt 打印内容在 <code class="language-plaintext highlighter-rouge">cargo run</code> dev 模式下均附加了代码行, 非常方便</li>
  <li>defmt 打印内容均带有时间戳, 该时间戳由 STM32 SYSTICK 提供(所以如果使用了 SYSTICK, 有可能导致时间戳异常)</li>
  <li>最终的 <code class="language-plaintext highlighter-rouge">main</code> 函数显示为 <code class="language-plaintext highlighter-rouge">blinky::____embassy_main_task::{async_fn#0}</code>, 由 <code class="language-plaintext highlighter-rouge">#[embassy_executor::main]</code> 宏生成</li>
</ul>

<h3 id="uart-打印---时钟和外设初始化">UART 打印 - 时钟和外设初始化</h3>

<p>defmt 固然方便, 但很多时候依然需要用到 UART, 通过串口获取调试信息或收集数据. LM401-Pro-Kit 正好通过 ST-Link 提供了到 USART2 的访问.</p>

<p>Blinky 例子中, 由 defmt 调试信息可知, 我们使用的系统时钟只有 4MHz, 但 STM32WL 的最大时钟频率是 48MHz. 所以需要通过初始化 <code class="language-plaintext highlighter-rouge">init()</code> 方法设置时钟参数:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sys clk init, with LSI support</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">Config</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
<span class="n">config</span><span class="py">.rcc.enable_lsi</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="n">config</span><span class="py">.rcc.mux</span> <span class="o">=</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">rcc</span><span class="p">::</span><span class="nn">ClockSrc</span><span class="p">::</span><span class="nf">MSI</span><span class="p">(</span><span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">rcc</span><span class="p">::</span><span class="nn">MSIRange</span><span class="p">::</span><span class="n">Range11</span><span class="p">);</span> <span class="c1">// 48MHz</span>
<span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nf">init</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
</code></pre></div></div>

<p>Embassy UART 使用非常简单, 可以单独用 UartTx/UartRx 只初始发送/接收部分. 这里是一个发送 Hello world 和 MCU 内部 “时间” 的简单示例:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// USART2 tx</span>
<span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">dma</span><span class="p">::</span><span class="n">NoDma</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">usart</span><span class="p">::</span><span class="n">UartTx</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_time</span><span class="p">::</span><span class="n">Instant</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">heapless</span><span class="p">::</span><span class="nb">String</span><span class="p">;</span>

<span class="c1">// Default: 115200 8N1</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">usart</span> <span class="o">=</span> <span class="nn">UartTx</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">p</span><span class="py">.USART2</span><span class="p">,</span> <span class="n">p</span><span class="py">.PA2</span><span class="p">,</span> <span class="n">NoDma</span><span class="p">,</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">String</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
<span class="nn">core</span><span class="p">::</span><span class="nd">write!</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">"Hello world, device time: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="nf">.as_millis</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="n">usart</span><span class="nf">.blocking_write</span><span class="p">(</span><span class="n">msg</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="n">msg</span><span class="nf">.clear</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">UartTx</code> 初始化时需要传入 <code class="language-plaintext highlighter-rouge">USART2</code>, <code class="language-plaintext highlighter-rouge">PA2</code>, 分别对应 USART2 外设和 TX 引脚, DMA 通道是可选的. 默认串口参数是 115200 8N1. 外设初始化会自动处理对应引脚的 AF 设置.</p>

<p>串口打印需要字符串拼接格式化, 由于 <code class="language-plaintext highlighter-rouge">no_std</code>, 标准库的 <code class="language-plaintext highlighter-rouge">String</code> 类型不可用, 这里使用 <code class="language-plaintext highlighter-rouge">heapless::String</code>, 初始化时候需要指定分配大小. <code class="language-plaintext highlighter-rouge">core::write!</code> 即标准库中的 <code class="language-plaintext highlighter-rouge">write!</code>, <code class="language-plaintext highlighter-rouge">core::</code> 前缀是为了避免和 <code class="language-plaintext highlighter-rouge">defmt::write!</code> 名字冲突.</p>

<p>完整代码请参考 <a href="https://github.com/andelf/lm401-pro-kit">代码仓库</a>.</p>

<p>执行代码确认, 可以看到系统时钟被正确设置为 48MHz.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>cargo run <span class="nt">--bin</span> uart
<span class="go">0.000000 DEBUG rcc: Clocks { sys: Hertz(48000000), apb1: Hertz(48000000), apb1_tim: Hertz(48000000), apb2: Hertz(48000000), apb2_tim: Hertz(48000000), apb3: Hertz(48000000), ahb1: Hertz(48000000), ahb2: Hertz(48000000), ahb3: Hertz(48000000) }
└─ embassy_stm32::rcc::set_freqs @ /Users/mono/Elec/embassy/embassy-stm32/src/fmt.rs:125
0.000011 INFO  Hello World!
</span><span class="gp">└─ uart::____embassy_main_task::{async_fn#</span>0<span class="o">}</span> @ src/bin/uart.rs:21
<span class="go">0.000064 INFO  tick
</span></code></pre></div></div>

<p>在另一命令行打开串口监视工具, 查看串口输出:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>picocom <span class="nt">-b</span> 115200 /dev/tty.usbmodem11103
<span class="go">Hello world, device time: 1000
Hello world, device time: 3002
Hello world, device time: 5005
Hello world, device time: 7008
Hello world, device time: 9011
Hello world, device time: 11013
</span><span class="c">....
</span></code></pre></div></div>

<h3 id="i2c-访问-bmp280">I2C 访问 BMP280</h3>

<h4 id="硬件准备">硬件准备</h4>

<ul>
  <li>BMP280 传感器模块 1 个</li>
  <li>杜邦线若干根, 用于连接传感器模块和开发板</li>
</ul>

<p>BMP280 是来自 Bosch 的气压传感器, 通过 I2C 接口读取气压和温度数据, 所以需要在板子上找到未被占用的 I2C SCL/SDA 引脚资源, 通过查阅芯片手册, 最后选择了空闲的 I2C2, SCL pin PA12, SDA pin PA11. 开发板上一排跳线帽正好提供了 VCC, GND.</p>

<p>接线:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+--------+          VCC GND
| BMP280 |           |   |
|      VCC&gt;----------+   |
|      GND&gt;--------------+
| [.]  SCL&gt;--------------------&gt;PA12
|      SDA&gt;--------------------&gt;PA11
|        |          (LM401-Pro-Kit)
+--------+
</code></pre></div></div>

<h4 id="bmp280-访问">BMP280 访问</h4>

<p>Rust Embassy 完美兼容 <code class="language-plaintext highlighter-rouge">embedded-hal</code> 相关生态, 相关外设类型均支持对应的 <code class="language-plaintext highlighter-rouge">embedded-hal</code> trait,</p>

<p>考虑到 BMP280 的使用略微复杂, 需要初始化, 读取校准数据, 测量后还需要通过校准数据计算最终测量结果. 所以 BMP280 直接寻找对应驱动即可. 但 Rust 嵌入式生态有个问题, 弃坑项目太多. 寻找第三方依赖时候需要注意阅读代码, 查看依赖版本, 必要时更新.</p>

<p>这么说, 其实是之前我有个弃坑项目里面有个 BME280 驱动库, BME280 和 BMP280 基本兼容, 只是多了湿度测量. 驱动代码使用 <code class="language-plaintext highlighter-rouge">embedded-hal</code> 提供的 trait 类型访问设备, 完成传感器初始化和测量. 稍微改了改, 直接 Copy <a href="https://github.com/andelf/embedded-drivers/blob/master/src/bme280.rs">embedded-drivers: bme280.rs</a> 到项目 <code class="language-plaintext highlighter-rouge">src/</code> 下使用即可.</p>

<p>修改 <code class="language-plaintext highlighter-rouge">src/lib.rs</code> 增加:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">bme280</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="代码实现">代码实现</h4>

<p>创建 BMP280 传感器项目 <code class="language-plaintext highlighter-rouge">src/bin/i2c-bmp280.rs</code>. 完整代码请参考 <a href="https://github.com/andelf/lm401-pro-kit">代码仓库</a>, 以下只选择关键部分介绍.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BMP280 init</span>
<span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">i2c</span><span class="p">::</span><span class="n">I2c</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="n">interrupt</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Hertz</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_time</span><span class="p">::</span><span class="n">Delay</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">lm401_pro_kit</span><span class="p">::</span><span class="nn">bme280</span><span class="p">::</span><span class="n">BME280</span><span class="p">;</span>

<span class="k">let</span> <span class="n">irq</span> <span class="o">=</span> <span class="nn">interrupt</span><span class="p">::</span><span class="nd">take!</span><span class="p">(</span><span class="n">I2C2_EV</span><span class="p">);</span>
<span class="k">let</span> <span class="n">i2c</span> <span class="o">=</span> <span class="nn">I2c</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
    <span class="n">p</span><span class="py">.I2C2</span><span class="p">,</span>
    <span class="n">p</span><span class="py">.PA12</span><span class="p">,</span>
    <span class="n">p</span><span class="py">.PA11</span><span class="p">,</span>
    <span class="n">irq</span><span class="p">,</span>
    <span class="n">NoDma</span><span class="p">,</span>
    <span class="n">NoDma</span><span class="p">,</span>
    <span class="nf">Hertz</span><span class="p">(</span><span class="mi">100_000</span><span class="p">),</span>
    <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
<span class="p">);</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">Delay</span><span class="p">;</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">bmp280</span> <span class="o">=</span> <span class="nn">BME280</span><span class="p">::</span><span class="nf">new_primary</span><span class="p">(</span><span class="n">i2c</span><span class="p">);</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">bmp280</span><span class="nf">.init</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">delay</span><span class="p">));</span>
</code></pre></div></div>

<p>Embassy 中访问设备时, 一般会需要中断, 虽然理论上阻塞访问外设时不需要中断.
但是为了保证接口的一致性, 一般都会要求提供中断参数. <code class="language-plaintext highlighter-rouge">interrupt::take!</code> 用于获取对应中断对象.</p>

<p><code class="language-plaintext highlighter-rouge">BME280::new_primary</code> 直接使用设备主地址 <code class="language-plaintext highlighter-rouge">0x76</code> 访问 I2C 总线上的 BMP280.</p>

<p>初始化设备时候由于需要软复位, 需要传递 <code class="language-plaintext highlighter-rouge">Delay</code> 对象, 用于延时(<code class="language-plaintext highlighter-rouge">delay_ms</code>).
默认的 <code class="language-plaintext highlighter-rouge">embassy_time::Delay</code> 使用循环比较 “设备当前时间” 的方法实现.</p>

<p><code class="language-plaintext highlighter-rouge">unwrap!</code> 宏由 <code class="language-plaintext highlighter-rouge">defmt</code> 提供, 等价于 <code class="language-plaintext highlighter-rouge">.unwrap()</code> 调用, 但是会在 panic 时候通过 defmt 打印信息.</p>

<p>完成设备初始化后, 可以访问传感器信息:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="nd">unwrap!</span><span class="p">(</span><span class="n">bmp280</span><span class="nf">.measure</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">delay</span><span class="p">));</span>
<span class="nd">info!</span><span class="p">(</span><span class="s">"BMP280: {:?}"</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
</code></pre></div></div>

<p>传感器执行测量时候, 按照手册, 依然需要延时, 所以也同样需要传递 <code class="language-plaintext highlighter-rouge">Delay</code> 对象.
<code class="language-plaintext highlighter-rouge">BME280::measure</code> 方法返回 <code class="language-plaintext highlighter-rouge">Measurements</code> 类型, 为了方便调试使用, 用 derive macro 增加了 defmt 支持, 可以直接做格式化参数:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">defmt::Format)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Measurements</span> <span class="p">{</span>
    <span class="cd">/// temperature in degrees celsius</span>
    <span class="k">pub</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="cd">/// pressure in pascals</span>
    <span class="k">pub</span> <span class="n">pressure</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="cd">/// percent relative humidity (`0` with BMP280)</span>
    <span class="k">pub</span> <span class="n">humidity</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>执行代码:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>cargo run <span class="nt">--bin</span> i2c-bmp280
<span class="go">0.000011 INFO  I2C BMP280 demo!
</span><span class="gp">└─ i2c_bmp280::____embassy_main_task::{async_fn#</span>0<span class="o">}</span> @ src/bin/i2c-bmp280.rs:23
<span class="go">0.009314 INFO  measure tick
</span><span class="gp">└─ i2c_bmp280::____embassy_main_task::{async_fn#</span>0<span class="o">}</span> @ src/bin/i2c-bmp280.rs:45
<span class="go">0.051652 INFO  BMP280: Measurements { temperature: 23.689554, pressure: 88391.13, humidity: 0.0 }
</span><span class="gp">└─ i2c_bmp280::____embassy_main_task::{async_fn#</span>0<span class="o">}</span> @ src/bin/i2c-bmp280.rs:48
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">temperature: 23.689554, pressure: 88391.13</code> 传感器数据正常.</p>

<h2 id="lora-传感器数据传输">LoRa 传感器数据传输</h2>

<p>LoRa 是一种无线传输协议, 适合长距离(km), 少量数据传输. 尤其适合传感器数据. 因为手头没有 LoRaWAN 基站, 所以暂时没法测试 LoRaWAN. 这里使用 LoRa 调制模式点对点传输 BMP280 传感器数据.</p>

<p>详细实现请参考 <a href="https://github.com/andelf/lm401-pro-kit">代码仓库</a> 里的 <code class="language-plaintext highlighter-rouge">src/bin/subghz-bmp280-tx.rs</code> 和 <code class="language-plaintext highlighter-rouge">src/bin/subghz-bmp280-rx.rs</code>.</p>

<h3 id="硬件准备-1">硬件准备</h3>

<p>LM401-Pro-Kit x2, 天线, 数据线.</p>

<p>其中一个开发板作为传感器采集端, 按照上一示例链接到 BMP280 传感器模块, 另一个作为接收端, 两个开发板之间通过 LoRa 无线传输数据. 接收端通过 UART 与电脑连接, 通过串口调试工具查看传感器数据.(实际上也可以直接通过 ST-Link + defmt 获取数据)</p>

<h3 id="射频开关-radioswitch">射频开关 RadioSwitch</h3>

<p>使用开发板射频功能, 需要处理射频开关逻辑. 相关逻辑从 BSP C 代码获得. 可以直接作为 BSP 的工具类型, 写入到 <code class="language-plaintext highlighter-rouge">src/lib.rs</code> 中:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::{</span>
    <span class="nn">gpio</span><span class="p">::{</span><span class="n">AnyPin</span><span class="p">,</span> <span class="n">Level</span><span class="p">,</span> <span class="n">Output</span><span class="p">,</span> <span class="nb">Pin</span><span class="p">,</span> <span class="n">Speed</span><span class="p">},</span>
    <span class="nn">peripherals</span><span class="p">::{</span><span class="n">PA15</span><span class="p">,</span> <span class="n">PA8</span><span class="p">,</span> <span class="n">PB0</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">RadioSwitch</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">ctrl1</span><span class="p">:</span> <span class="n">Output</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">ctrl2</span><span class="p">:</span> <span class="n">Output</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">ctrl3</span><span class="p">:</span> <span class="n">Output</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">RadioSwitch</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new_from_pins</span><span class="p">(</span><span class="n">ctrl1</span><span class="p">:</span> <span class="n">PB0</span><span class="p">,</span> <span class="n">ctrl2</span><span class="p">:</span> <span class="n">PA15</span><span class="p">,</span> <span class="n">ctrl3</span><span class="p">:</span> <span class="n">PA8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">ctrl1</span><span class="p">:</span> <span class="nn">Output</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ctrl1</span><span class="nf">.degrade</span><span class="p">(),</span> <span class="nn">Level</span><span class="p">::</span><span class="n">Low</span><span class="p">,</span> <span class="nn">Speed</span><span class="p">::</span><span class="n">VeryHigh</span><span class="p">),</span>
            <span class="n">ctrl2</span><span class="p">:</span> <span class="nn">Output</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ctrl2</span><span class="nf">.degrade</span><span class="p">(),</span> <span class="nn">Level</span><span class="p">::</span><span class="n">Low</span><span class="p">,</span> <span class="nn">Speed</span><span class="p">::</span><span class="n">VeryHigh</span><span class="p">),</span>
            <span class="n">ctrl3</span><span class="p">:</span> <span class="nn">Output</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ctrl3</span><span class="nf">.degrade</span><span class="p">(),</span> <span class="nn">Level</span><span class="p">::</span><span class="n">Low</span><span class="p">,</span> <span class="nn">Speed</span><span class="p">::</span><span class="n">VeryHigh</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
        <span class="n">ctrl1</span><span class="p">:</span> <span class="n">Output</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ctrl2</span><span class="p">:</span> <span class="n">Output</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ctrl3</span><span class="p">:</span> <span class="n">Output</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">AnyPin</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">ctrl1</span><span class="p">,</span>
            <span class="n">ctrl2</span><span class="p">,</span>
            <span class="n">ctrl3</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_off</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.ctrl3</span><span class="nf">.set_low</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.ctrl1</span><span class="nf">.set_low</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.ctrl2</span><span class="nf">.set_low</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="nn">embassy_lora</span><span class="p">::</span><span class="nn">stm32wl</span><span class="p">::</span><span class="n">RadioSwitch</span> <span class="k">for</span> <span class="n">RadioSwitch</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">set_rx</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.ctrl3</span><span class="nf">.set_low</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.ctrl1</span><span class="nf">.set_high</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.ctrl2</span><span class="nf">.set_low</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">set_tx</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.ctrl3</span><span class="nf">.set_high</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.ctrl1</span><span class="nf">.set_low</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.ctrl2</span><span class="nf">.set_low</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>非常简单的 GPIO 操作, GPIO 的强类型 <code class="language-plaintext highlighter-rouge">PAn</code>/<code class="language-plaintext highlighter-rouge">PBn</code>/.. 可以通过 <code class="language-plaintext highlighter-rouge">.degrade()</code> 方法转换为 <code class="language-plaintext highlighter-rouge">AnyPin</code> 类型, 方便使用.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">rfs</span> <span class="o">=</span> <span class="nn">lm401_pro_kit</span><span class="p">::</span><span class="nn">RadioSwitch</span><span class="p">::</span><span class="nf">new_from_pins</span><span class="p">(</span><span class="n">p</span><span class="py">.PB0</span><span class="p">,</span> <span class="n">p</span><span class="py">.PA15</span><span class="p">,</span> <span class="n">p</span><span class="py">.PA8</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="lora-数据报文定义">LoRa 数据报文定义</h3>

<p>为简单展示, 传感器节点只负责发送, 接受节点只接受 LoRa 报文, 不回传 ACK 信号.</p>

<p>报文格式为 24 字节:</p>

<table>
  <tbody>
    <tr>
      <td>头</td>
      <td>设备地址</td>
      <td>设备时间戳</td>
      <td>温度</td>
      <td>大气压</td>
      <td>checksum</td>
    </tr>
    <tr>
      <td>b”MM”</td>
      <td>u32</td>
      <td>u64</td>
      <td>f32</td>
      <td>f32</td>
      <td>u16</td>
    </tr>
  </tbody>
</table>

<p>其中设备地址使用 STM32 系列的 chip id 实现, 保证一定的唯一性:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Device ID in STM32L4/STM32WL microcontrollers</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">chip_id</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="p">[</span>
            <span class="nn">core</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">read_volatile</span><span class="p">(</span><span class="mi">0x1FFF7590</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span><span class="p">),</span>
            <span class="nn">core</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">read_volatile</span><span class="p">(</span><span class="mi">0x1FFF7594</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span><span class="p">),</span>
            <span class="nn">core</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">read_volatile</span><span class="p">(</span><span class="mi">0x1FFF7598</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u32</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">chip_id</span> <span class="o">=</span> <span class="nf">chip_id</span><span class="p">();</span>
<span class="k">let</span> <span class="n">dev_addr</span> <span class="o">=</span> <span class="n">chip_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">chip_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">chip_id</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</code></pre></div></div>

<p>设备时间戳直接读取 <code class="language-plaintext highlighter-rouge">Instant::now()</code> 并转为 millis. 保证每个数据报文的差异性. <code class="language-plaintext highlighter-rouge">checksum</code> 校验和字段通过计算 <code class="language-plaintext highlighter-rouge">[2..22]</code> 所有字节之和得到. 所有数据字段均按照大端序列化(BigEndian).</p>

<h3 id="subghz-初始化">SubGhz 初始化</h3>

<p>LM401 的射频功能由 STM32WLE5 内置的 SX1262 提供, 设备内部通过 SPI3(SUBGHZSPI) 访问. SX1262 初始化需要较多参数, 且发送端接收端若干参数需要一致.</p>

<p>这里选用 490.500MHz, LoRa SF7,  4/5 编码率, 125kHz 带宽, 24 字节数据长度. 接收端和发送端设置一致.</p>

<p>参数定义:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">embassy_stm32</span><span class="p">::</span><span class="nn">subghz</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">const</span> <span class="n">DATA_LEN</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">24_u8</span><span class="p">;</span>
<span class="k">const</span> <span class="n">PREAMBLE_LEN</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">0x8</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

<span class="k">const</span> <span class="n">RF_FREQ</span><span class="p">:</span> <span class="n">RfFreq</span> <span class="o">=</span> <span class="nn">RfFreq</span><span class="p">::</span><span class="nf">from_frequency</span><span class="p">(</span><span class="mi">490_500_000</span><span class="p">);</span>

<span class="k">const</span> <span class="n">TX_BUF_OFFSET</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="k">const</span> <span class="n">RX_BUF_OFFSET</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">LORA_PACKET_PARAMS</span><span class="p">:</span> <span class="n">LoRaPacketParams</span> <span class="o">=</span> <span class="nn">LoRaPacketParams</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.set_crc_en</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="nf">.set_preamble_len</span><span class="p">(</span><span class="n">PREAMBLE_LEN</span><span class="p">)</span>
    <span class="nf">.set_payload_len</span><span class="p">(</span><span class="n">DATA_LEN</span><span class="p">)</span>
    <span class="nf">.set_invert_iq</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
    <span class="nf">.set_header_type</span><span class="p">(</span><span class="nn">HeaderType</span><span class="p">::</span><span class="n">Fixed</span><span class="p">);</span>

<span class="c1">// SF7, Bandwidth 125 kHz, 4/5 coding rate, low data rate optimization</span>
<span class="k">const</span> <span class="n">LORA_MOD_PARAMS</span><span class="p">:</span> <span class="n">LoRaModParams</span> <span class="o">=</span> <span class="nn">LoRaModParams</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.set_bw</span><span class="p">(</span><span class="nn">LoRaBandwidth</span><span class="p">::</span><span class="n">Bw125</span><span class="p">)</span>
    <span class="nf">.set_cr</span><span class="p">(</span><span class="nn">CodingRate</span><span class="p">::</span><span class="n">Cr45</span><span class="p">)</span>
    <span class="nf">.set_ldro_en</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="nf">.set_sf</span><span class="p">(</span><span class="nn">SpreadingFactor</span><span class="p">::</span><span class="n">Sf7</span><span class="p">);</span>

<span class="c1">// see table 35 "PA optimal setting and operating modes"</span>
<span class="k">const</span> <span class="n">PA_CONFIG</span><span class="p">:</span> <span class="n">PaConfig</span> <span class="o">=</span> <span class="nn">PaConfig</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.set_pa_duty_cycle</span><span class="p">(</span><span class="mi">0x4</span><span class="p">)</span>
    <span class="nf">.set_hp_max</span><span class="p">(</span><span class="mi">0x7</span><span class="p">)</span>
    <span class="nf">.set_pa</span><span class="p">(</span><span class="nn">PaSel</span><span class="p">::</span><span class="n">Hp</span><span class="p">);</span>

<span class="k">const</span> <span class="n">TX_PARAMS</span><span class="p">:</span> <span class="n">TxParams</span> <span class="o">=</span> <span class="nn">TxParams</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.set_power</span><span class="p">(</span><span class="mi">0x16</span><span class="p">)</span> <span class="c1">// +22dB</span>
    <span class="nf">.set_ramp_time</span><span class="p">(</span><span class="nn">RampTime</span><span class="p">::</span><span class="n">Micros200</span><span class="p">);</span>
</code></pre></div></div>

<p>设备初始化, 部分内容从 BSP C 代码转换得到:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">radio</span> <span class="o">=</span> <span class="nn">SubGhz</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">p</span><span class="py">.SUBGHZSPI</span><span class="p">,</span> <span class="n">NoDma</span><span class="p">,</span> <span class="n">NoDma</span><span class="p">);</span>

<span class="c1">// from demo code: Radio_SMPS_Set</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_smps_clock_det_en</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_smps_drv</span><span class="p">(</span><span class="nn">SmpsDrv</span><span class="p">::</span><span class="n">Milli40</span><span class="p">));</span>

<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_standby</span><span class="p">(</span><span class="nn">StandbyClk</span><span class="p">::</span><span class="nb">Rc</span><span class="p">));</span>

<span class="c1">// in XO mode, set internal capacitor (from 0x00 to 0x2F starting 11.2pF with 0.47pF steps)</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_hse_in_trim</span><span class="p">(</span><span class="nn">HseTrim</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="mi">0x20</span><span class="p">)));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_hse_out_trim</span><span class="p">(</span><span class="nn">HseTrim</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="mi">0x20</span><span class="p">)));</span>

<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_regulator_mode</span><span class="p">(</span><span class="nn">RegMode</span><span class="p">::</span><span class="n">Smps</span><span class="p">));</span> <span class="c1">// Use DCDC</span>

<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_buffer_base_address</span><span class="p">(</span><span class="n">TX_BUF_OFFSET</span><span class="p">,</span> <span class="n">RX_BUF_OFFSET</span><span class="p">));</span>

<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_pa_config</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PA_CONFIG</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_pa_ocp</span><span class="p">(</span><span class="nn">Ocp</span><span class="p">::</span><span class="n">Max60m</span><span class="p">));</span> <span class="c1">// current max</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_tx_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TX_PARAMS</span><span class="p">));</span>

<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_packet_type</span><span class="p">(</span><span class="nn">PacketType</span><span class="p">::</span><span class="n">LoRa</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_lora_sync_word</span><span class="p">(</span><span class="nn">LoRaSyncWord</span><span class="p">::</span><span class="n">Public</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_lora_mod_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LORA_MOD_PARAMS</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_lora_packet_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LORA_PACKET_PARAMS</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.calibrate_image</span><span class="p">(</span><span class="nn">CalibrateImage</span><span class="p">::</span><span class="n">ISM_470_510</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_rf_frequency</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RF_FREQ</span><span class="p">));</span>
</code></pre></div></div>

<p>中断信号量处理, 由于发送接收循环需要涉及到中断处理, 这里直接用 <code class="language-plaintext highlighter-rouge">Signal</code> 类型的信号量处理中断:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">embassy_sync</span><span class="p">::</span><span class="nn">blocking_mutex</span><span class="p">::</span><span class="nn">raw</span><span class="p">::</span><span class="n">CriticalSectionRawMutex</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">embassy_sync</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="n">Signal</span><span class="p">;</span>

<span class="k">static</span> <span class="n">IRQ_SIGNAL</span><span class="p">:</span> <span class="n">Signal</span><span class="o">&lt;</span><span class="n">CriticalSectionRawMutex</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Signal</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">let</span> <span class="n">radio_irq</span> <span class="o">=</span> <span class="nn">interrupt</span><span class="p">::</span><span class="nd">take!</span><span class="p">(</span><span class="n">SUBGHZ_RADIO</span><span class="p">);</span>
<span class="n">radio_irq</span><span class="nf">.set_handler</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="p">{</span>
    <span class="n">IRQ_SIGNAL</span><span class="nf">.signal</span><span class="p">(());</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">interrupt</span><span class="p">::</span><span class="nn">SUBGHZ_RADIO</span><span class="p">::</span><span class="nf">steal</span><span class="p">()</span> <span class="p">}</span><span class="nf">.disable</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div>

<p>这样, 在 <code class="language-plaintext highlighter-rouge">async fn main()</code> 中使用 <code class="language-plaintext highlighter-rouge">IRQ_SIGNAL.wait().await</code> 就可以随时等待中断信号量.</p>

<h3 id="subghz-发送端">SubGhz 发送端</h3>

<p>首先拼接报文, 这里直接手动拼接组合字节:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">payload</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">24</span><span class="p">];</span>
<span class="k">let</span> <span class="n">now</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
<span class="k">let</span> <span class="n">measurements</span> <span class="o">=</span> <span class="nd">unwrap!</span><span class="p">(</span><span class="n">bmp280</span><span class="nf">.measure</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">delay</span><span class="p">));</span>

<span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">b'M'</span><span class="p">;</span>
<span class="n">payload</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">b'M'</span><span class="p">;</span>

<span class="n">payload</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">6</span><span class="p">]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">dev_addr</span><span class="nf">.to_be_bytes</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">());</span>
<span class="n">payload</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">14</span><span class="p">]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">now</span><span class="nf">.as_millis</span><span class="p">()</span><span class="nf">.to_be_bytes</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">());</span>
<span class="n">payload</span><span class="p">[</span><span class="mi">14</span><span class="o">..</span><span class="mi">18</span><span class="p">]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">measurements</span><span class="py">.temperature</span><span class="nf">.to_be_bytes</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">());</span>
<span class="n">payload</span><span class="p">[</span><span class="mi">18</span><span class="o">..</span><span class="mi">22</span><span class="p">]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">measurements</span><span class="py">.pressure</span><span class="nf">.to_be_bytes</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">());</span>
<span class="k">let</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">22</span><span class="p">]</span>
    <span class="nf">.iter</span><span class="p">()</span>
    <span class="nf">.fold</span><span class="p">(</span><span class="mi">0u16</span><span class="p">,</span> <span class="p">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">x</span><span class="p">|</span> <span class="n">acc</span><span class="nf">.wrapping_add</span><span class="p">(</span><span class="o">*</span><span class="n">x</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">));</span>
<span class="nd">info!</span><span class="p">(</span><span class="s">"checksum: {:04x}"</span><span class="p">,</span> <span class="n">checksum</span><span class="p">);</span>
<span class="n">payload</span><span class="p">[</span><span class="mi">22</span><span class="o">..</span><span class="mi">24</span><span class="p">]</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">checksum</span><span class="nf">.to_be_bytes</span><span class="p">()</span><span class="nf">.as_slice</span><span class="p">());</span>
</code></pre></div></div>

<p>然后开始发送:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rfs</span><span class="nf">.set_tx</span><span class="p">();</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_irq_cfg</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">CfgIrq</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.irq_enable_all</span><span class="p">(</span><span class="nn">Irq</span><span class="p">::</span><span class="n">TxDone</span><span class="p">)));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.write_buffer</span><span class="p">(</span><span class="n">TX_BUF_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">[</span><span class="o">..</span><span class="p">]));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_tx</span><span class="p">(</span><span class="nn">Timeout</span><span class="p">::</span><span class="n">DISABLED</span><span class="p">));</span>

<span class="n">radio_irq</span><span class="nf">.enable</span><span class="p">();</span>
<span class="n">IRQ_SIGNAL</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
<span class="n">rfs</span><span class="nf">.set_off</span><span class="p">();</span>

<span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">irq_status</span><span class="p">)</span> <span class="o">=</span> <span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.irq_status</span><span class="p">());</span>
<span class="k">if</span> <span class="n">irq_status</span> <span class="o">&amp;</span> <span class="nn">Irq</span><span class="p">::</span><span class="n">TxDone</span><span class="nf">.mask</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nn">defmt</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"TX done"</span><span class="p">);</span>
<span class="p">}</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.clear_irq_status</span><span class="p">(</span><span class="n">irq_status</span><span class="p">));</span>
</code></pre></div></div>

<p>总结起来发送过程需要如下步骤:</p>

<ul>
  <li>打开射频发送开关</li>
  <li>设置中断, 开启 <code class="language-plaintext highlighter-rouge">TxDone</code></li>
  <li>写入数据 buffer</li>
  <li>开始发送, 不使用 <code class="language-plaintext highlighter-rouge">Timeout</code></li>
  <li>开启中断</li>
  <li>等待中断信号量</li>
  <li>关闭射频开关</li>
  <li>检查中断状态</li>
  <li>清理中断状态</li>
</ul>

<h3 id="subghz-接收端">SubGhz 接收端</h3>

<p>这里是接收端逻辑, <code class="language-plaintext highlighter-rouge">src/bin/subghz-bmp280-rx.rs</code>, 其中配置部分和发送端相同:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">256</span><span class="p">];</span>

<span class="n">rfs</span><span class="nf">.set_rx</span><span class="p">();</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_irq_cfg</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="nn">CfgIrq</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.irq_enable_all</span><span class="p">(</span><span class="nn">Irq</span><span class="p">::</span><span class="n">RxDone</span><span class="p">)</span>
        <span class="nf">.irq_enable_all</span><span class="p">(</span><span class="nn">Irq</span><span class="p">::</span><span class="n">Timeout</span><span class="p">)</span>
        <span class="nf">.irq_enable_all</span><span class="p">(</span><span class="nn">Irq</span><span class="p">::</span><span class="nb">Err</span><span class="p">)</span>
<span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.read_buffer</span><span class="p">(</span><span class="n">RX_BUF_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">));</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.set_rx</span><span class="p">(</span><span class="nn">Timeout</span><span class="p">::</span><span class="nf">from_duration_sat</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">5000</span><span class="p">))));</span>

<span class="n">radio_irq</span><span class="nf">.unpend</span><span class="p">();</span>
<span class="n">radio_irq</span><span class="nf">.enable</span><span class="p">();</span>

<span class="n">IRQ_SIGNAL</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
<span class="n">led_rx</span><span class="nf">.set_low</span><span class="p">();</span>
<span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">irq_status</span><span class="p">)</span> <span class="o">=</span> <span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.irq_status</span><span class="p">());</span>
<span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.clear_irq_status</span><span class="p">(</span><span class="n">irq_status</span><span class="p">));</span>

<span class="k">if</span> <span class="n">irq_status</span> <span class="o">&amp;</span> <span class="nn">Irq</span><span class="p">::</span><span class="n">RxDone</span><span class="nf">.mask</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_st</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.rx_buffer_status</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">packet_status</span> <span class="o">=</span> <span class="nd">unwrap!</span><span class="p">(</span><span class="n">radio</span><span class="nf">.lora_packet_status</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">rssi</span> <span class="o">=</span> <span class="n">packet_status</span><span class="nf">.rssi_pkt</span><span class="p">()</span><span class="nf">.to_integer</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">snr</span> <span class="o">=</span> <span class="n">packet_status</span><span class="nf">.snr_pkt</span><span class="p">()</span><span class="nf">.to_integer</span><span class="p">();</span>
    <span class="nd">info!</span><span class="p">(</span>
        <span class="s">"RX done: rssi={}dBm snr={}dB len={} offset={}"</span><span class="p">,</span>
        <span class="n">rssi</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">payload</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span> <span class="k">as</span> <span class="nb">usize</span><span class="o">..</span><span class="n">offset</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="n">len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>
    <span class="c1">// Parse payload here</span>
<span class="p">}</span>
</code></pre></div></div>

<p>发送步骤如下:</p>

<ul>
  <li>打开射频接收开关</li>
  <li>设置中断, 开启 <code class="language-plaintext highlighter-rouge">RxDone</code>, <code class="language-plaintext highlighter-rouge">Timeout</code>, <code class="language-plaintext highlighter-rouge">Err</code></li>
  <li>设置读入 buffer</li>
  <li>开始接收, 这里使用 <code class="language-plaintext highlighter-rouge">Timeout</code> 5 秒</li>
  <li>清理未处理中断状态, 否则会有观察到空中断</li>
  <li>开启中断</li>
  <li>等待中断信号量</li>
  <li>检查中断状态, 清理中断状态</li>
  <li>通过 <code class="language-plaintext highlighter-rouge">rx_buffer_status</code> 获取 buffer 状态</li>
  <li>通过 <code class="language-plaintext highlighter-rouge">lora_packet_status</code> 获取报文 rssi, snr 信息</li>
</ul>

<h3 id="运行结果">运行结果</h3>

<p>发送端上电之后, 每2秒采集一次传感器数据并发送.</p>

<p>接收端上电之后, 持续接收数据并同时打印在 defmt 调试和串口输出.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>cargo run <span class="nt">--bin</span> subghz-bmp280-rx <span class="nt">--release</span>
<span class="go">1.226162 INFO  begin rx...
3.292868 INFO  RX done: rssi=-42dBm snr=14dB len=24 offset=0
3.292969 DEBUG got BMP280 node raw=[0x4d, 0x4d, 0x72, 0x2e, 0x67, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x3a, 0x41, 0xad, 0x10, 0xa2, 0x47, 0xac, 0x8c, 0x2a, 0x5, 0xa]
3.293173 INFO  dev addr=722e6728 dev tick=22586 temp=21.633121'C pressure=883.4433hPa
3.299479 INFO  stats: Stats { status: Status { mode: Ok(StandbyRc), cmd: Ok(Avaliable) }, pkt_rx: 2, pkt_crc: 0, pkt_len_or_hdr_err: 0, ty: LoRaStats }
3.299622 INFO  begin rx...
</span></code></pre></div></div>

<p>串口输出, CSV 格式:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>picocom <span class="nt">-b</span> 115200 /dev/tty.usbmodem11203
<span class="go">addr=722e6728,rssi=-44,snr=14,temperature=16.304043,pressure=87621.96
addr=722e6728,rssi=-44,snr=14,temperature=16.306524,pressure=87621.96
addr=722e6728,rssi=-44,snr=13,temperature=16.309006,pressure=87621.83
addr=722e6728,rssi=-45,snr=13,temperature=16.311487,pressure=87621.81
addr=722e6728,rssi=-45,snr=13,temperature=16.313969,pressure=87621.66
</span></code></pre></div></div>

<h2 id="总结">总结</h2>

<p>Rust Embassy 是一个非常好的嵌入式 Rust 开发框架, 通过它可以快速开发嵌入式应用.
Rust Embassy 把 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> 关键字带到了 Rust 嵌入式开发中, 其还有丰富的多任务支持, 多种同步元语支持. 通过它们, 我们可以很方便的开发多任务应用.</p>

<p>但它依然是一个很早期的框架, 还不够完善, 例如目前在 STM32WL 上缺乏 ADC 支持.
文档不够丰富, 部分库函数会随着开发进度有所变更, 给维护项目带来不小的困难.</p>

<p>在开发过程中, 往往能看到 move 语义, ownership, 类型系统等 Rust 的特性, 虽然这些特性在嵌入式开发中并不是必须的, 但是它们确实能带来更好的开发体验. 例如 move/borrow 保证对设备资源的唯一访问所有权.
通过类型安全的寄存器类型访问避免 C 语言中错误的寄存器访问, 经过 Rust 编译器优化后, 和 C 中的 bit mask 写法是等价的.
通过 “associated types” 保证设备和对应引脚的状态匹配.</p>

<p>Rust Embassy 隐藏了大部分嵌入式设备细节, 开发者不需要过多的关注设备初始化细节, 应用代码短小.</p>

<p>实际使用过程中, 也遇到了一些坑, 例如在写一个 PWM 例子时候, <code class="language-plaintext highlighter-rouge">embassy_time::Delay</code> 怎么都不工作, 添加了若干 debug 打印之后才发现, <code class="language-plaintext highlighter-rouge">embassy_time::Delay</code> 内部使用 <code class="language-plaintext highlighter-rouge">embassy_time::Instant</code> 实现, 默认情况下会使用 <code class="language-plaintext highlighter-rouge">TIM2</code>.
而选择的 PWM 输出 pin 正好是 <code class="language-plaintext highlighter-rouge">TIM2_CH2</code>, 两者互相干扰, 导致 <code class="language-plaintext highlighter-rouge">Delay</code> 不工作.
目前类型系统还不能保证 <code class="language-plaintext highlighter-rouge">Delay</code> 和 <code class="language-plaintext highlighter-rouge">Pwm</code> 不会使用同一个 <code class="language-plaintext highlighter-rouge">TIM</code> 设备.
最终的解决方法是使用 <code class="language-plaintext highlighter-rouge">cortex_m::delay::Delay</code>, 这是一个基于 SYSTICK 的实现.</p>

<p>本位未介绍 Embassy 的多任务功能, 在代码仓库里有一个简单的按钮控制闪灯频率的例子 <code class="language-plaintext highlighter-rouge">src/bin/button-control-blinky.rs</code>.
多任务的时候需要有 <code class="language-plaintext highlighter-rouge">.await</code> 调用让出时间片.</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/embassy-rs/embassy">Github: Embassy</a></li>
  <li><a href="https://embassy.dev/book/dev/index.html">Embassy Documentation</a></li>
  <li><a href="https://apollolabsblog.hashnode.dev/embedded-rust-embassy-gpio-button-controlled-blinking">Embedded Rust &amp; Embassy 系列教程</a></li>
  <li><a href="https://www.st.com/resource/en/datasheet/STM32WLE5.pdf">STM32WLE5.pdf</a></li>
</ul>]]></content><author><name>andelf</name></author><category term="blog" /><category term="embedded" /><category term="stm32" /><category term="embassy" /><category term="rust" /><category term="lora" /><summary type="html"><![CDATA[2024-06 补充: 相关内容已经过期, 且 lora-rust 项目长达 1 年多是时间删去 CN470 支持后没有再加回来. 本文仅作为历史记录.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://user-images.githubusercontent.com/72891/213959627-2d2dfd95-6b29-4770-a1ee-85eb81081acd.png" /><media:content medium="image" url="https://user-images.githubusercontent.com/72891/213959627-2d2dfd95-6b29-4770-a1ee-85eb81081acd.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">施阿姨的互联网 - Interview with Aunt Shi</title><link href="https://andelf.github.io/blog/2021/02/04/interview-with-aunt-shi/" rel="alternate" type="text/html" title="施阿姨的互联网 - Interview with Aunt Shi" /><published>2021-02-04T12:03:00+00:00</published><updated>2023-01-23T16:59:59+00:00</updated><id>https://andelf.github.io/blog/2021/02/04/interview-with-aunt-shi</id><content type="html" xml:base="https://andelf.github.io/blog/2021/02/04/interview-with-aunt-shi/"><![CDATA[<p>这是几年前田野调查时候的一篇访谈稿。最近的聊天室热，让我想起了这个有意思的阿姨。</p>

<p>在一个小村子的路口小卖店，看到一位略残疾腿脚不方便的阿姨极其熟练地单指打字聊天，操作着在线聊天室服务端软件，
同时管理虚拟摄像头播放的擦边球女主播视频。可想当时我有多震惊。于是有了这遍访谈。</p>

<h2 id="正文">正文</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>title: 施阿姨的互联网
时间: 7月22日 下午
地点: XQ村村口小卖店
访谈人: Mono
被访谈人: 施阿姨
整理汇总: Mono
整理时间: 7/26
版本: v3
</code></pre></div></div>

<p>施阿姨。XQ村路口小卖店老板，56岁，似乎残疾。中午买水时见到她对着两台电脑的屏幕熟练操作，很是惊异，于是下午去做问卷和访谈。</p>

<p>访谈时，他的老公刚要外出。她卧坐在椅子上，眼睛时不时回头看两台电脑的屏幕（一台台式机，一台笔记本，均WinXP操作系统），打开的是视频聊天室的应用程序，能看到长长的在线用户列表和正在直播的视频窗口，她时不时用右手单手中指打出一句话和聊天室的网友互动，打字速度还挺快。每隔一会她还切换到一个类似老虎机到网络赌博程序，去查看状态。</p>

<p>访谈中了解到，施阿姨今年56岁，村里的普通农户。她弟弟在上海市的一家医院里工作，收入还可以，各方面也有一定的人脉，给施阿姨棒过不少忙。施阿姨的丈夫今年59岁，似乎不太会说话，不在家里做主的样子，没几分钟就出门去村北的蔬菜大棚里做工。丈夫的父母都已去世，施阿姨的母亲还健在，每天在家里给施阿姨和她老公做饭，平日里他们两口回家时间都略晚。施阿姨的儿子在上海上班。</p>

<p>早在80年代末，施阿姨就开始做裁缝，用缝纫机帮人加工衣服，她自豪地说，最多时候一年能有一万多收入，96年家里建的3层楼房就是用自己做衣服的钱盖的。但是95年后，人们的消费习惯逐渐发生变化，更多直接购买品牌衣服而不是买布料找裁缝加工，施阿姨的裁缝生意一天不如一天。</p>

<p>这时候，施阿姨借用了亲戚家在村路口的地，盖了一间屋子做小卖店，当时卖香烟很赚钱，但香烟需要烟草局的许可，施阿姨等了很久也没消息，一两年后听说上海市区比她晚申请烟草专卖许可的都办了下来，就托弟弟去崇明县烟草局去质问，之后才办了下来，但这时候烟草利润已经没有当年高，生意依旧一般。近几年施阿姨的小卖店每年大概有6000左右的收入。</p>

<p>同时在95年左右，施阿姨的股骨头出了问题，具体哪年做的置换已记不得，右腿（猜是）无法抬起正常走路，残疾人助力车停在小卖店里。阿姨说她当时申请残疾证也是费了好大周折，最后不得已通过弟弟出面，找人花了一万多才办了下来。谈到此，施阿姨感叹说，其实上面政府的政策是好的，残疾（人）补助不少，民政部门每月还发粮油，但到了下面，就不为老百姓考虑了，明明家里有钱开着车天天浪的人办下来了残疾证，真正残疾的人却办不下来。</p>

<p>施阿姨的互联网+，要从她弟弟说起，她弟弟家境宽裕，早在九十年代就置办了电脑，后来因更新换代，把旧电脑淘汰给了她，而她只有初中文化水平，且不会普通话（打字拼音完全不会），所以电脑就放在自己的小卖店里，供自己儿子使用。</p>

<p>后来村里有小孩看到她这里有电脑，就来玩，给她按小时计费，在她的电脑上装了很多游戏，也因此电脑经常中病毒出故障。那时候相当于只有一台电脑的黑网吧。后来施阿姨觉得对这些小孩的家长有愧，同时电脑也经常坏，就停下了黑网吧的生意。儿子后来出去上学，也用不到电脑，所以电脑就闲置了一段时间。（2000年左右）</p>

<p>而后，村里有一个在中学教书的王老师，看到施阿姨家里有电脑能上网，就给施阿姨介绍了QQ，教她网上聊天。一开始施阿姨不会打字，就用语音或者半天打一个字（因为普通话不会，所以拼音输入往往找不到字），同时也买了摄像头。</p>

<p>施阿姨是一个很爱学习东西的人。为了克服打字困难，她找来自己的外甥，将常用字和拼音写下来，挂在电脑背面的墙上，每天对着学习。没过几月，王老师再和施阿姨聊天，惊讶于施阿姨流畅的打字速度（虽然只是用一个指头敲键），敬佩不已。</p>

<p>此外，施阿姨的电脑每次出故障或是有问题，都是邻居家一个学电脑的小伙子解决的，小伙子很热心，说阿姨你会用就行了，这些我给你修。但是阿姨不愿意，比如装系统的时候，就要看着，一步步把步骤记下来，自己摸索。施阿姨还说，自己还会拆装电脑，电脑不亮的时候，什么显卡内存啊都拆了下来然后擦擦灰装起来就能好。（我当时听到这些也是惊到了）</p>

<p>07、08年股市疯涨的时候，施阿姨在弟弟的鼓动下，学起了炒股，当时也是每天盯K线，她以试探的心态投了2万，最多的时候涨到了6、7万，但后来被套牢。也就再没去折腾炒股。</p>

<p>说起视频聊天室，施阿姨说是一开始因为聊天打字太慢，语音视频聊天更方便，所以买了摄像头、耳机话筒。后来QQ上有一个网友，上海的，让她下载个软件，说带她去视频聊天室玩玩，她觉得很新鲜。一开始，都是别人教她怎么下载，注册，进入聊天室。在聊天室里可以排麦（聊天室同时一般只有很少的人可以语音，所以其他人需要按顺序排麦克风，由聊天室房主负责管理），唱歌，送花（虚拟道具）等等。最好玩的时候，一晚上她们一帮人能唱三四十首歌。</p>

<p>后来施阿姨就自己一个去各种聊天室逛，也逐渐萌生了自己做房主开聊天室的念头。她在网上聊天室里认识了一个71岁的老阿姨，在这方面是高手，经验丰富，这位老阿姨教施阿姨申请到了聊天室房间（需要一笔钱，才能拥有自己的房间），还协助施阿姨配置了新的电脑（视频聊天室需要转编码，需要性能稍微好的电脑）。</p>

<p>刚开始的时候，施阿姨的聊天室没多少人。而这类视频聊天室的模式是这样：网站提供视频直播服务器和视频直播软件，集中管理视频直播室的帐号和虚拟道具。虚拟道具即聊天室中用于相互赠送的鲜花、跑车等礼物。虚拟道具需要从网站的平台充值获取。每个聊天室都需要房主（在聊天室内被称为老大）来开启，房主需要向聊天室平台一次性缴纳费用，获得开聊天室的资格。聊天室中所有人的充值消费房主从中抽成，获得收益。部分视频聊天室还有在线赌博功能，虚拟货币流水更高。</p>

<p>视频聊天室往往具有集聚效应，即原本热闹的聊天室会更热闹。所以吸引参与者成了聊天室房主的首要任务。所以有的聊天室房主就会通过色情内容吸引成员，增加用户量。而施阿姨一开始是让老阿姨帮忙“挂聊天室”，赚取人气。所谓“挂聊天室”其实是用“马甲”帐号，从网上下载漂亮女主播的视频片段，然后通过模拟摄像头软件，在自己的聊天室内虚拟出一个漂亮的女主播，同时用帐号和房间内的用户互动，拉高人气。</p>

<p>那位71岁的老阿姨在这方面更有经验，帮施阿姨挂没多久后，聊天室的人气就来了，每天高峰大概有几百人在线。施阿姨也能通过道具充值提成获取一些收益。但施阿姨说，她和别人不一样，她获得到的金币（其中某平台，100万金币能换60元人民币）最后又通过各种方式返给了聊天室的参与者，发发小礼物等等，所以她的聊天室人气不错，大家都觉得她是个实在人，都叫她老大，或者老阿姨。</p>

<p>这时候来看，施阿姨更多把这样一个打监管擦边球的、具有获利性质的网络赌博平台当作了自己另一个社交圈子交流的工具。她在网上会和各种年龄段的人闲聊，比如和同时残疾人的网友聊聊政府补助的事情一类。</p>

<p>但较早较广接触网络，明显让施阿姨有了更大的眼界。谈起网络色情，阿姨说，有些小伙子来问她聊天室有没有不穿衣服女人那种视频，她说，都是人身上长得有什么好看的。谈起网络病毒，阿姨讲了她的一次经历，曾经有网友给她发了个文件，叫聚会照片，她打开后，桌面就弹出一个披长头发流血的女人照片，当时把她吓得半死，而且电脑之后也无法启动了。找来邻居家小伙子修好了电脑之后，她从此再也不接陌生人的文件，熟人也要看是不是本地的才会去看。</p>

<p>她家附近有个邻居也很好奇，但是人经常在上海住，想找机会让她教怎么开视频聊天室。而其他邻居对她的评价是，就知道买电脑玩电脑。</p>

<p>很多时候在考虑，互联网的即时、多媒体的社交方式到达农村到底会催生一种什么样的亚文化现象？例如前段时间很火爆的“快手”App，山东老阿姨吃日光灯管、年轻小伙子用鞭炮炸裤裆、残疾姑娘晒自己的打扮、搞怪装精神病的各种丑角、维修农机的小伙子自制各种新奇玩意、叠扑克牌、叠银币等等等等。实际上大部分是基于交流和“被注意到”的需求，当然也不排除部分也被一些小集团控制，编排节目，制作视频，炒作环节一应俱全的产业链。</p>

<p>（快手App已经是全国网络流量前几名的应用了，它的早期推广方式是和华为、酷派、步步高等国产手机在县城及以下的营销网点合作，直接预装。）</p>

<p>施阿姨也许只是孤例，纯流水帐记录，供大家思考。为何视频聊天室这种似乎已经在大中城市过气很久的互联网应用，却可以占有部分三四线城镇及农村的市场，得到生存。</p>

<p>参考：两个网站 <code class="language-plaintext highlighter-rouge">ht tp: / /w ww.99 dzr.com/</code> 大自然娱乐、 <code class="language-plaintext highlighter-rouge">ht tp:/ /w ww.78 90 xy.com/</code> 丰彩人生，还有个未知来源的游戏大厅，实际上是类似在线老虎机的样式，不停地转动切换下一个中奖的商标，可以看到下注量其实很高，单个商标下注在百万金币左右。网站均是未备案，注册地在二线城市。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="interview" /><summary type="html"><![CDATA[这是几年前田野调查时候的一篇访谈稿。最近的聊天室热，让我想起了这个有意思的阿姨。]]></summary></entry><entry><title type="html">Play with 2.13 inch E-Ink display</title><link href="https://andelf.github.io/blog/2021/01/14/play-with-2-13-inch-e-ink-display/" rel="alternate" type="text/html" title="Play with 2.13 inch E-Ink display" /><published>2021-01-14T17:24:00+00:00</published><updated>2021-01-22T07:05:30+00:00</updated><id>https://andelf.github.io/blog/2021/01/14/play-with-2-13-inch-e-ink-display</id><content type="html" xml:base="https://andelf.github.io/blog/2021/01/14/play-with-2-13-inch-e-ink-display/"><![CDATA[<p>故事从买屏幕说起。</p>

<p>无聊逛咸鱼，发现有便宜的电子墨水屏，这玩意正常价格大几十，而咸鱼一片 2.13 寸模块只需要 15 块钱人民币。</p>

<p>是的，还等啥，先来几片凑个包邮。</p>

<p>了解到之所以这么便宜，是因为实际上是拆机屏，拆的是电子价签。来自一茬又一茬倒闭的超市和便利店。</p>

<h2 id="背景">背景</h2>

<p>电子墨水屏，也叫 E-ink, 墨水屏（瓶），电子纸，也简写为 EPD(Electronic Paper Display)。</p>

<p>和你用来压泡面的 Kindle 的屏幕是一个东西。只不过你的 Kindle 屏幕更大素质更高，而超市价签要小很多，相对低成本。</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Electronic_paper_%28Side_view_of_Electrophoretic_display%29_in_svg.svg/2560px-Electronic_paper_%28Side_view_of_Electrophoretic_display%29_in_svg.svg.png" alt="E-Ink technology" /></p>

<p>如上来自维基，原理一目了然。</p>

<p>不需要扯什么 gate 什么的，每个像素是一个小胶囊，顶部是公共 \(V_{com}\) 电压，透明。
底面是驱动芯片在屏幕每一行每一列像素的输出电压，可正可负（相对于 \(V_{com}\)），胶囊内部是对电场方向有反应的带电颜色微粒。
不同电压不同时长作用下，胶囊顶部上的微粒分布情况不同，肉眼看到的像素深浅就不同。</p>

<p>屏幕的驱动芯片，和我们常见的 IC 芯片那种黑色块带引脚是不同的，屏幕驱动芯片一般和屏幕一起封装，
对应屏幕的行列有输出。对外暴露接口，物理上一般是排线。</p>

<h2 id="准备开搞">准备开搞</h2>

<p>屏幕模块到手。显示“微雪电子”，那当然是不可能的，这只是因为默认用了微雪的示例代码出厂测试。
墨水屏的特点就是断电画面驻留，也可以说保持显示状态不需要供电。</p>

<p><img src="https://user-images.githubusercontent.com/72891/104638297-f5b6e800-56e0-11eb-93d6-0bc0fde0d475.jpg" alt="Boards" /></p>

<p>合影是一只凑单的 STM32F4 板子（本例未用到），一只 ESP8266（就准备用它来驱动屏幕了），和屏幕模块（主角）。</p>

<p>一共需要八根线驱动。熟悉的 SPI + CS + DC 式，和多数 SPI 接口的 LCD / TFT-LCD 屏幕接口类似。</p>

<p>不同的是多了一个 BUSY pin，这是墨水屏特有的输出信号，表示屏幕正在刷新，其他操作需要 MCU 延后。</p>

<p>告知该模块兼容微雪 2.13 寸黑白屏幕 v1 版。参数如下:</p>

<ul>
  <li>尺寸： 2.13 inch</li>
  <li>外形尺寸（裸屏）：59.2mm × 29.2mm × 1.05mm</li>
  <li>显示尺寸：48.55mm × 23.71mm</li>
  <li>工作电压：3.3V/5V</li>
  <li>通信接口：SPI</li>
  <li>点距：0.194*0.194</li>
  <li>分辨率：250*122</li>
  <li>显示颜色：黑、白</li>
  <li>灰度等级：2</li>
  <li>局部刷新 ：0.3s</li>
  <li>全局刷新 ：2s</li>
  <li>刷新功耗 ： 26.4mW(typ.)</li>
  <li>待机功耗 ：&lt;=0.017mW</li>
</ul>

<p>查询模块手册，得知该显示屏驱动芯片是 IL3895, 来自 Good Display(大连佳显)。
屏幕排线上有型号 HINK-E0213A04-G01(HINK-E0213-G01).</p>

<h3 id="esp8266">ESP8266</h3>

<p>ESP8266 算是较推荐的墨水屏之友，IO 接口不多但够用，带 WiFi 功能, 适合做这类显示屏小制作。
可以轻易找到各类天气时钟等代码。</p>

<p>推荐编程环境 Arduino. 省事。需要安装 <a href="https://github.com/esp8266/Arduino">ESP8266 Board Support 库</a>.</p>

<p>我这里的 ESP8266 板子是一只 NodeMCU DevKit 兼容板。最普通不过，但比较麻烦的是它的管脚标签和标准的 ESP8266 GPIO
之间有一个映射关系。</p>

<p><img src="https://user-images.githubusercontent.com/72891/104639665-a2de3000-56e2-11eb-9396-04cf946880bd.png" alt="NodeMCU GPIOs" />
(ref: <a href="https://www.electronicwings.com/nodemcu/nodemcu-gpio-with-arduino-ide">https://www.electronicwings.com/nodemcu/nodemcu-gpio-with-arduino-ide</a>)</p>

<p>搞清楚映射关系，写代码就不会错了。</p>

<p>官方有出售专门的 ESP8266 驱动板，集成了 ESP8266, 只需要按照相同的接线，即可使用官方例程。</p>

<p>接线方式:</p>

<table>
  <thead>
    <tr>
      <th>EPD board</th>
      <th style="text-align: right">NodeMCU pin</th>
      <th style="text-align: right">ESP8266 pin</th>
      <th style="text-align: right">description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BUSY</td>
      <td style="text-align: right">D1</td>
      <td style="text-align: right">GPIO5</td>
      <td style="text-align: right">屏幕刷新忙</td>
    </tr>
    <tr>
      <td>RES/RST</td>
      <td style="text-align: right">D4</td>
      <td style="text-align: right">2</td>
      <td style="text-align: right">复位</td>
    </tr>
    <tr>
      <td>DC</td>
      <td style="text-align: right">D2</td>
      <td style="text-align: right">4</td>
      <td style="text-align: right">Data/Command 信号</td>
    </tr>
    <tr>
      <td>CS</td>
      <td style="text-align: right">D8</td>
      <td style="text-align: right">15</td>
      <td style="text-align: right">片选</td>
    </tr>
    <tr>
      <td>CLK/SCK</td>
      <td style="text-align: right">D5</td>
      <td style="text-align: right">14</td>
      <td style="text-align: right">SPI 时钟</td>
    </tr>
    <tr>
      <td>DIN/SDA</td>
      <td style="text-align: right">D7</td>
      <td style="text-align: right">13</td>
      <td style="text-align: right">SPI MOSI</td>
    </tr>
  </tbody>
</table>

<p>常识 VCC = 3.3V, GND 接地。</p>

<h3 id="屏幕官方例程">屏幕官方例程</h3>

<p>虽然不是官方正版，只是个拆机屏模块，但好在屏幕型号一致，全兼容微雪官方例程。</p>

<ul>
  <li><a href="https://www.waveshare.net/wiki/E-Paper_ESP8266_Driver_Board">官方 ESP8266 驱动板及例程</a></li>
</ul>

<p>官方例程解压后子目录复制到 Arduino libraries 目录。</p>

<p>然后就可以直接从 Arduino 的 File-&gt;Examples 菜单打开例程。</p>

<p>例程压缩包中的 <code class="language-plaintext highlighter-rouge">src/</code>, <code class="language-plaintext highlighter-rouge">extras/</code> 目录，其实就是官方驱动，所有的不同型号屏幕的例程，都依赖驱动库。</p>

<p>该款屏幕的例程是 <code class="language-plaintext highlighter-rouge">waveshare-e-Paper/epd2in13-demo</code>.</p>

<p>设备选择 NodeMCU 或 Generic EPS8266, 编译上传例程。</p>

<p>屏幕噌噌闪动几下，清屏后，开始执行例程。</p>

<p><img src="https://user-images.githubusercontent.com/72891/104642461-e4bca580-56e5-11eb-9a8f-ea2c7a38da22.jpg" alt="Official Demo" /></p>

<p>屏幕右下角的时间显示，秒位在不停变动。</p>

<p>例程中可以看到基础绘图，中英文数字显示，时间显示（局部刷新功能）。照着改改可以整出不少好玩的。
再加上 ESP8266 的 WiFi 功能，想象力足够。</p>

<h3 id="end-of-get-start">End of get start</h3>

<p>至此，屏幕跑通。画画图，改改文字，皆大欢喜。🤪</p>

<hr />

<p>以下是干货部分。需要知识预备:</p>

<ul>
  <li>二进制位运算知识</li>
  <li>数字电子基础</li>
  <li>电路基础</li>
  <li>计算机图形学基础概念</li>
</ul>

<h2 id="中文显示">中文显示</h2>

<p>看到例程中直接有中文显示语句，暗爽不是？</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Paint_DrawString_CN</span><span class="p">(</span><span class="mi">140</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="s">"你好abc"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Font12CN</span><span class="p">,</span> <span class="n">BLACK</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">);</span>
<span class="n">Paint_DrawString_CN</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="s">"**电子"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Font24CN</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">,</span> <span class="n">BLACK</span><span class="p">);</span>
</code></pre></div></div>

<p>于是改成“你好世界”，然而只见“你好”不见“世界”。</p>

<p>是的，官方例程（驱动）里没有完整字库，只有测试时候屏幕上出现的那几个汉字。所以需要加字库！</p>

<p>我们能接触到的绝大多数屏幕，都是点阵屏。
所谓字库，就是字符编码到图形象素点的映射。所以这里要增加缺失的字型，怎么整？</p>

<p>先看看官方怎么实现的。</p>

<p>当然，字库还有其他意思，在手机维修界，字库也指 ROM 芯片。
这是历史遗留问题了，当年字库都存在专门的芯片里。
字库和字库芯片在很多场合不区分。这里叫字库，其实是字模，即汉字的模型，对应的二进制数据。</p>

<h3 id="官方驱动字库格式">官方驱动字库格式</h3>

<p>找到驱动目录 <code class="language-plaintext highlighter-rouge">~/Documents/Arduino/libraries/esp8266-waveshare-epd</code>.</p>

<p>在 <code class="language-plaintext highlighter-rouge">src/</code> 目录下，找到若干 <code class="language-plaintext highlighter-rouge">font*.cpp</code>, <code class="language-plaintext highlighter-rouge">font*.h</code> 文件就是字库了。</p>

<p>例如 <code class="language-plaintext highlighter-rouge">font12CN</code> 字体，微软雅黑 12:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">CH_CN</span> <span class="n">Font12CN_Table</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="cm">/*--  文字:  你  --*/</span>
    <span class="cm">/*--  微软雅黑12;  此字体下对应的点阵为：宽x高=16x21   --*/</span>
    <span class="p">{</span><span class="s">"你"</span><span class="p">,</span>
    <span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x1D</span><span class="p">,</span><span class="mh">0xC0</span><span class="p">,</span><span class="mh">0x1D</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0x07</span><span class="p">,</span>
    <span class="mh">0x3F</span><span class="p">,</span><span class="mh">0x77</span><span class="p">,</span><span class="mh">0x7E</span><span class="p">,</span><span class="mh">0x76</span><span class="p">,</span><span class="mh">0xF8</span><span class="p">,</span><span class="mh">0x70</span><span class="p">,</span><span class="mh">0xFB</span><span class="p">,</span><span class="mh">0xFE</span><span class="p">,</span><span class="mh">0xFB</span><span class="p">,</span><span class="mh">0xFE</span><span class="p">,</span><span class="mh">0x3F</span><span class="p">,</span><span class="mh">0x77</span><span class="p">,</span><span class="mh">0x3F</span><span class="p">,</span><span class="mh">0x77</span><span class="p">,</span><span class="mh">0x3E</span><span class="p">,</span><span class="mh">0x73</span><span class="p">,</span>
    <span class="mh">0x38</span><span class="p">,</span><span class="mh">0x70</span><span class="p">,</span><span class="mh">0x38</span><span class="p">,</span><span class="mh">0x70</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">},</span>
    <span class="c1">// ...</span>
    <span class="p">{</span><span class="s">"A"</span><span class="p">,</span>
    <span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x0E</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x1F</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x1F</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span>
    <span class="mh">0x1F</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x71</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x7F</span><span class="p">,</span><span class="mh">0xC0</span><span class="p">,</span><span class="mh">0x71</span><span class="p">,</span><span class="mh">0xC0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span>
    <span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">},</span>
<span class="p">};</span>

<span class="n">cFONT</span> <span class="n">Font12CN</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">Font12CN_Table</span><span class="p">,</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="n">Font12CN_Table</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CH_CN</span><span class="p">),</span>  <span class="cm">/*size of table*/</span>
  <span class="mi">11</span><span class="p">,</span> <span class="cm">/* ASCII Width */</span>
  <span class="mi">16</span><span class="p">,</span> <span class="cm">/* Width */</span>
  <span class="mi">21</span><span class="p">,</span> <span class="cm">/* Height */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>明显看到中文字库分两部分，一部分是字型表 <code class="language-plaintext highlighter-rouge">Font12CN_Table</code>, 一部分是配置结构体 <code class="language-plaintext highlighter-rouge">Font12CN</code>.
字型表即字的象素点二进制表示。因为中文字符较多，为节省空间字库只有例程所需汉字，
所以每条记录第一个元素是中文汉字，用于索引。
而对于英文字库来说，字符是连续的，且总体占用空间较小，一般使用连续字节块表示。</p>

<p>从配置结构我们可以得知，该字型宽 16 位，高 21 位，即两个字节表示一行象素，一共 21 行。
我们可以写个脚本展示下:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">char</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x1D</span><span class="p">,</span><span class="mh">0xC0</span><span class="p">,</span><span class="mh">0x1D</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0xFF</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0x07</span><span class="p">,</span>
    <span class="mh">0x3F</span><span class="p">,</span><span class="mh">0x77</span><span class="p">,</span><span class="mh">0x7E</span><span class="p">,</span><span class="mh">0x76</span><span class="p">,</span><span class="mh">0xF8</span><span class="p">,</span><span class="mh">0x70</span><span class="p">,</span><span class="mh">0xFB</span><span class="p">,</span><span class="mh">0xFE</span><span class="p">,</span><span class="mh">0xFB</span><span class="p">,</span><span class="mh">0xFE</span><span class="p">,</span><span class="mh">0x3F</span><span class="p">,</span><span class="mh">0x77</span><span class="p">,</span><span class="mh">0x3F</span><span class="p">,</span><span class="mh">0x77</span><span class="p">,</span><span class="mh">0x3E</span><span class="p">,</span><span class="mh">0x73</span><span class="p">,</span>
    <span class="mh">0x38</span><span class="p">,</span><span class="mh">0x70</span><span class="p">,</span><span class="mh">0x38</span><span class="p">,</span><span class="mh">0x70</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">]</span>
<span class="c1"># group by 2 -&gt; to 0-1 -&gt; padding with 0
</span><span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">%08d%08d</span><span class="sh">"</span> <span class="o">%</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">bin</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]),</span> <span class="nf">int</span><span class="p">(</span><span class="nf">bin</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span> <span class="nf">for </span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">char</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">char</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">lines</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">.</span><span class="sh">'</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">))</span>
</code></pre></div></div>

<p>得到命令行下输出:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>................
................
................
................
...***.***......
...***.**.......
..***.**********
..***.**.....***
..******.***.***
.******..***.**.
*****....***....
*****.*********.
*****.*********.
..******.***.***
..******.***.***
..*****..***..**
..***....***....
..***....***....
..***.*****.....
................
................
</code></pre></div></div>

<p>一个汉字被解析了出来，以点阵的方式展示。上方和下方的 0, 用于行间距。
在实际应用中可以省去，节约空间。</p>

<p>而配置中的 ASCII Width 11 表示该中文字体中的 ASCII 字符宽度。因为半角全角的关系，
中文字体中的半角英文字符(ASCII)相对来说宽度都不足一字，为了显示效果，不留过多字间距，
丢弃多余位不用，所以这里单独有一个配置项。</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">char</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x0E</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x1F</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x1F</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span>
     <span class="p">...:</span>     <span class="mh">0x1F</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x3B</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x71</span><span class="p">,</span><span class="mh">0x80</span><span class="p">,</span><span class="mh">0x7F</span><span class="p">,</span><span class="mh">0xC0</span><span class="p">,</span><span class="mh">0x71</span><span class="p">,</span><span class="mh">0xC0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span>
     <span class="p">...:</span>     <span class="mh">0xE0</span><span class="p">,</span><span class="mh">0xE0</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">]</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">%08d%08d</span><span class="sh">"</span> <span class="o">%</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">bin</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]),</span> <span class="nf">int</span><span class="p">(</span><span class="nf">bin</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span> <span class="nf">for </span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">char</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">char</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">lines</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">.</span><span class="sh">'</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">))</span>

<span class="c1"># outputs:
</span><span class="sh">"""</span><span class="s">
</span><span class="gp">...</span><span class="p">..........</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="p">....</span><span class="o">***</span><span class="p">......</span><span class="bp">...</span>
<span class="p">...</span><span class="o">*****</span><span class="p">.....</span><span class="bp">...</span>
<span class="p">...</span><span class="o">*****</span><span class="p">.....</span><span class="bp">...</span>
<span class="p">...</span><span class="o">*****</span><span class="p">.....</span><span class="bp">...</span>
<span class="p">..</span><span class="o">***</span><span class="p">.</span><span class="o">***</span><span class="p">....</span><span class="bp">...</span>
<span class="p">..</span><span class="o">***</span><span class="p">.</span><span class="o">***</span><span class="p">....</span><span class="bp">...</span>
<span class="p">.</span><span class="o">***</span><span class="p">...</span><span class="o">**</span><span class="p">....</span><span class="bp">...</span>
<span class="p">.</span><span class="o">*********</span><span class="p">...</span><span class="bp">...</span>
<span class="p">.</span><span class="o">***</span><span class="p">...</span><span class="o">***</span><span class="p">...</span><span class="bp">...</span>
<span class="o">***</span><span class="p">.....</span><span class="o">***</span><span class="p">..</span><span class="bp">...</span>
<span class="o">***</span><span class="p">.....</span><span class="o">***</span><span class="p">..</span><span class="bp">...</span>
<span class="o">***</span><span class="p">.....</span><span class="o">***</span><span class="p">..</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="p">.............</span><span class="bp">...</span>
<span class="sh">"""</span>
</code></pre></div></div>

<h3 id="生成字库">生成字库</h3>

<p>搞明白了原理和格式，接下来就是生成所需的字库了。网上有非常多的 Windows 下小工具可以做。
但我这么肝，就自己写了。代码来自之前给 TFT-LCD 写的抠字模小脚本儿。</p>

<p>原理很简单，用 <code class="language-plaintext highlighter-rouge">Pillow/PIL</code> 即可。先把需要的字画在图片上，然后读取象素点，移位生成对于字节表示。
最后最好直接生成 C 代码，就万事大吉。</p>

<p>而字体选择，一般使用点阵字体而非矢量字体，矢量字体在渲染的时候边缘都是带灰阶的，
如果忽略灰阶直接二值化，会导致最终字型锯齿严重，丑。</p>

<p>为了方便处理，这里选用开源的等宽字体<a href="http://wenq.org/wqy2/index.cgi?Unibit">文泉驿点阵字体 Unibit</a>.
以中文点阵最常见的 16x16 输出。正好两个字节宽，16 行高，一个汉字 32 字节。
英文字符也正好是中文字符宽度的一半。</p>

<p>当然你可以随便从系统找个中文字体。需要注意的是，为了在黑白（无灰度）屏幕上达到最好效果，需要位图字体(bitmap font, raster font, pixel font),
否则矢量字体在渲染的过程中会有灰阶边缘，最终屏幕效果锯齿明显。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装依赖</span>

pip3 <span class="nb">install </span>Pillow

<span class="c"># 用于字体缩放的依赖库</span>
brew <span class="nb">install </span>libraqm
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">PIL</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageDraw</span><span class="p">,</span> <span class="n">ImageFont</span>
<span class="kn">import</span> <span class="n">PIL.features</span>

<span class="c1"># brew install libraqm
</span><span class="k">assert</span> <span class="n">PIL</span><span class="p">.</span><span class="n">features</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="sh">'</span><span class="s">raqm</span><span class="sh">'</span><span class="p">),</span> <span class="sh">"</span><span class="s">libraqm required</span><span class="sh">"</span>

<span class="c1"># 画布大小
</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># 黑白格式
</span><span class="n">FORMAT</span> <span class="o">=</span> <span class="sh">'</span><span class="s">1</span><span class="sh">'</span>
<span class="n">BG</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">FG</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Y offset, 多数字体有自带行间距，可以用此参数消除行间距
</span><span class="n">YOFF</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># or -1
</span>

<span class="n">CHARS</span> <span class="o">=</span> <span class="sh">"</span><span class="s">晴天卧槽可以了！你好世界最怕你一生碌碌无为，还安慰自己平凡可贵。雾霾</span><span class="sh">"</span>
<span class="n">CHARS</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">CHARS</span><span class="p">)))</span>

<span class="n">im</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">FORMAT</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">BG</span><span class="p">)</span>

<span class="n">font</span> <span class="o">=</span> <span class="n">ImageFont</span><span class="p">.</span><span class="nf">truetype</span><span class="p">(</span><span class="sh">"</span><span class="s">Unibit.ttf</span><span class="sh">"</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="p">.</span><span class="nc">Draw</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

<span class="c1"># 代码段用于检查字体渲染
# draw.text((0, YOFF), CHARS, font=font, fill=FG, language='zh-CN')
# im.save('font.png')
# im.show()
</span>
<span class="n">draw</span><span class="p">.</span><span class="nf">rectangle</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="p">],</span> <span class="n">fill</span><span class="o">=</span><span class="n">BG</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">CHARS</span><span class="p">):</span>
    <span class="n">charmap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">text</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">YOFF</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">font</span><span class="o">=</span><span class="n">font</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">FG</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">im</span><span class="p">.</span><span class="nf">getpixel</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>

        <span class="n">charmap</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">charmap</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span>

    <span class="n">draw</span><span class="p">.</span><span class="nf">rectangle</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="p">],</span> <span class="n">fill</span><span class="o">=</span><span class="n">BG</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">{</span><span class="sh">"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">''</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'"</span><span class="s">{}</span><span class="sh">"</span><span class="s">, {}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="sh">"</span><span class="s">0x%02x</span><span class="sh">"</span> <span class="o">%</span> <span class="n">c</span><span class="p">,</span> <span class="n">charmap</span><span class="p">))),</span> <span class="n">end</span><span class="o">=</span><span class="sh">""</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">},</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>直接输出 C 代码片段:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="s">"一"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>
<span class="p">{</span><span class="s">"生"</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>
<span class="p">{</span><span class="s">"碌"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0xc8</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x4a</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x4a</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">},</span>
<span class="p">{</span><span class="s">"碌"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0xc8</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x4a</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x4a</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">},</span>
<span class="p">{</span><span class="s">"无"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0xf0</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x7c</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>
<span class="p">{</span><span class="s">"为"</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">},</span>
</code></pre></div></div>

<h3 id="使用字库">使用字库</h3>

<p>要想使用字体，我们需要新建一个字体 <code class="language-plaintext highlighter-rouge">.h</code> 文件，就叫 <code class="language-plaintext highlighter-rouge">ch_font.h</code>，在项目目录即可，不需要修改驱动库:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">"fonts.h"</span><span class="cp">
</span>
<span class="k">const</span> <span class="n">CH_CN</span> <span class="n">Font16CN_Table</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span><span class="s">"一"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"生"</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>
    <span class="c1">// ... 这里写入剩余字型</span>
<span class="p">};</span>

<span class="n">cFONT</span> <span class="n">Font16CN</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">Font16CN_Table</span><span class="p">,</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="n">Font16CN_Table</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CH_CN</span><span class="p">),</span>  <span class="cm">/*size of table*/</span>
  <span class="mi">8</span><span class="p">,</span> <span class="cm">/* ASCII Width */</span>
  <span class="mi">16</span><span class="p">,</span> <span class="cm">/* Width */</span>
  <span class="mi">16</span><span class="p">,</span> <span class="cm">/* Height */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>使用:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>
<span class="cp">#include</span> <span class="cpf">"cn_font.h"</span><span class="cp">
</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">Paint_DrawString_CN</span><span class="p">(</span><span class="mi">140</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="s">"卧槽可以了！"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Font16CN</span><span class="p">,</span> <span class="n">BLACK</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">);</span>

    <span class="n">EPD_2IN13_Display</span><span class="p">(</span><span class="n">BlackImage</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>效果大概是(忘记拍照了，这里是另外一个开源字体 Sarasa):</p>

<p><img src="https://user-images.githubusercontent.com/72891/104816620-5b2ce500-5857-11eb-92fe-2dbd3add8eda.jpg" alt="Chicken soup" /></p>

<p>是的，毒鸡汤。至此中文字体搞定，其他 CJK 字体同理。</p>

<p>而英文字体就更简单了，参考其他驱动中的 <code class="language-plaintext highlighter-rouge">font*</code> 文件即可。字型生成代码略改即可使用。</p>

<p>具体制作中可以混合中英文大小字体，还可以选择例如数码管字体等方案，完成布局。</p>

<p><img src="https://user-images.githubusercontent.com/72891/104816434-21a7aa00-5856-11eb-9dd3-dc05255c8cdb.jpg" alt="Mixed Font" /></p>

<h2 id="其他显示需求">其他显示需求</h2>

<h3 id="图片显示">图片显示</h3>

<p>墨水屏最烂大街的应用，大概就是天气时钟了，各式各样，各种尺寸。</p>

<p>显示文字信息的事情，上面我们已经通过自定义字库搞定了，
发挥想象力可以搞出诸如数码管字体，手写字体，等各种适合在墨水屏上实现的显示效果。</p>

<p>但问题来了，我想搞个天气图标符号显示，比如，<a href="http://www.weather.com.cn/">中国天气网</a> 那样的。</p>

<p><img src="https://user-images.githubusercontent.com/72891/104684474-165c5d80-5734-11eb-8850-9216e07a9dca.png" alt="weather" /></p>

<p>官方例程里其实有全屏图片显示例子，可以看到相关的调用函数 <code class="language-plaintext highlighter-rouge">Paint_DrawBitMap</code>。
同时驱动库里也提供了 <code class="language-plaintext highlighter-rouge">Paint_DrawImage(buf, x_start, y_start, img_width, img_height)</code>
函数用于在任意位置显示任意大小图片。</p>

<p>看一眼驱动库里 <code class="language-plaintext highlighter-rouge">Paint_DrawImage</code> 代码，好像哪里不对，只支持宽度象素是 8 倍数的图片。
改也简单，用 <code class="language-plaintext highlighter-rouge">Paint_SetPixel</code> 函数替换即可，简单的位运算。</p>

<p>现在问题是怎么生成一张用于显示的图片。其实和上面的字库非常类似，就是用二进制位去映射象素点。
然后生成 C 数组。甚至核心代码逻辑也差不多。</p>

<p>需要注意的是图片只能是黑白二值图。为方便库函数识别，也提前将图片宽度处理成 8 的整数倍。</p>

<p>图源，就取天气网那堆图标，原图是用 CSS offset 方式显示的，也就是所有图标在一张图片上，需要切下。</p>

<p>完整代码见 <a href="https://gist.github.com/andelf/acb0d317eef5d0cc8b7d53d4133c09c2">gist: crop-blue30.py</a>.
这里贴要点</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># RGBA 到 RGB 的转换
</span><span class="n">pix</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">im1</span><span class="p">.</span><span class="nf">getpixel</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="n">BG</span> <span class="o">=</span> <span class="mi">255</span> <span class="c1"># 背景是白色
</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">BG</span> <span class="o">*</span> <span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">255</span>
<span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">BG</span> <span class="o">*</span> <span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">255</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">BG</span> <span class="o">*</span> <span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">255</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">255</span> <span class="c1"># alpha 通道置空，不透明度
</span>
<span class="n">im1</span><span class="p">.</span><span class="nf">putpixel</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 图像二值化,
</span><span class="n">im1</span> <span class="o">=</span> <span class="n">im1</span><span class="p">.</span><span class="nf">resize</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">Image</span><span class="p">.</span><span class="n">LANCZOS</span><span class="p">)</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">im1</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">ImageFilter</span><span class="p">.</span><span class="n">SHARPEN</span><span class="p">)</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">im1</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">,</span> <span class="n">dither</span><span class="o">=</span><span class="n">Image</span><span class="p">.</span><span class="n">NONE</span><span class="p">)</span>
</code></pre></div></div>

<p>当然，你要是用 ImageMagick 或者 Photoshop 也一样可以。</p>

<p>然后把生成的二进制装入 C <code class="language-plaintext highlighter-rouge">uint8_t[]</code> 即可。</p>

<p>显示一个太阳:</p>

<p><img src="https://user-images.githubusercontent.com/72891/104686101-84565400-5737-11eb-9bf5-4e0347e1eb28.png" alt="image" /></p>

<p>因为二值化和缩放的关系，象素周围略有点腐蚀的感觉。
效果还行，考虑考虑界面元素布局，做个天气时钟足够了。</p>

<h3 id="局部刷新">局部刷新</h3>

<p>正常情况下在显示文字和图案的时候屏幕会连续从最黑到最白来回闪动几下，参考显示原理，
这里是为了避免残留墨水粒子影响显示效果，即消除残影的影响。
有使用过 Kindle 的同学对这点会比较清楚，一般是翻页若干次全部刷新一次。</p>

<p>官方例程中右下角有个时间显示，用到了局部刷新技术:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EPD_2IN13_Init</span><span class="p">(</span><span class="n">EPD_2IN13_PART</span><span class="p">);</span>
<span class="n">Paint_SelectImage</span><span class="p">(</span><span class="n">BlackImage</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="n">Paint_ClearWindows</span><span class="p">(</span><span class="mi">140</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">140</span> <span class="o">+</span> <span class="n">Font20</span><span class="p">.</span><span class="n">Width</span> <span class="o">*</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">90</span> <span class="o">+</span> <span class="n">Font20</span><span class="p">.</span><span class="n">Height</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">);</span>
<span class="n">Paint_DrawTime</span><span class="p">(</span><span class="mi">140</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sPaint_time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Font20</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">,</span> <span class="n">BLACK</span><span class="p">);</span>

<span class="n">EPD_2IN13_Display</span><span class="p">(</span><span class="n">BlackImage</span><span class="p">);</span>
</code></pre></div></div>

<p>首先以 <code class="language-plaintext highlighter-rouge">EPD_2IN13_PART</code> 方式重新初始化屏幕（不用清屏），然后就通过 <code class="language-plaintext highlighter-rouge">Paint_ClearWindows</code> 清除需要局部更新的矩形区域，
之后就可以使用各种绘图绘字符函数填写屏幕的这部分。最后调用 Display 上屏。</p>

<p>局部刷新的效果因屏幕体质不同各异，经常会遇到残影特别严重的时候。做小制作的时候也可以学习电纸书，局部刷新多次后全局刷新一次。</p>

<h2 id="再看显示原理">再看显示原理</h2>

<p>以上，基本介绍完了墨水屏的常见功能。已满足绝大部分需求。</p>

<p>回头再看显示原理，有了一开始介绍的小胶囊阵列结构，驱动怎么通过搞定显示的呢？这里以 2.13 寸显示屏的驱动 IC IL3895 为例。</p>

<h3 id="lut">LUT</h3>

<p>LUT, 即 Waveform Look Up Table(LUT), 是很多介绍电子墨水驱动文章的离不开的话题。</p>

<p>所谓的 LUT 功能，其实是驱动芯片的“可编程驱动电压波形”功能。即通过若干寄存器字节，
设置像素在不同状态转换情况下使用的底板电压高低的时序。该设置全局有效，针对全屏幕的任何一个像素的变动。
整个波形通过更新屏幕指令(MasterActivation = 0x20, Activate Display Update Sequence)触发，
此过程中 BUSY 信号有效，更新逻辑完成后, BUSY 信号结束。</p>

<p>例如数据手册中:</p>

<p><img src="https://user-images.githubusercontent.com/72891/104814031-a63efc00-5847-11eb-8fd4-8595a69ad1eb.png" alt="image" /></p>

<p>IL3895 芯片支持 10 个 phase 的波形，分别是 phase0A phase0B phase1A phase1B phase2A phase2B phase3A phase3B phase4A phase4B,
其中每个 phase 可以指定维持状态的时间周期数 TP.
每两个波形可以设置一个重复次数 RP.
在每个 phase, 都可以指定像素底板电压 VS 高低。不同电压级别驱动颜色微粒向不同方向运动，维持不同的时间，最终实现像素的黑白变化。</p>

<p>图表右侧的 XY=LL, XY=LH, … 表示不同的像素值变动情形。例如 HL 表示像素从白色变动到黑色, LL 表示像素在此次刷新中值没有变化。</p>

<p>以上的所有配置项按照固定格式，最终形成了 LUT 表，可以通过命令设置:</p>

<p><img src="https://user-images.githubusercontent.com/72891/104814577-b1475b80-584a-11eb-9cf5-3dcc9b559bf5.png" alt="image" /></p>

<p>而例程中的 <code class="language-plaintext highlighter-rouge">EPD_2IN13_Init(EPD_2IN13_FULL/PART)</code>, 其中最重要也是唯一的区别就是 FULL 和 PART 初始化时使用的 LUT 表不同。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">EPD_2IN13_lut_full_update</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
    <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span>
    <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">EPD_2IN13_lut_partial_update</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
    <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
    <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span>
<span class="p">};</span>
</code></pre></div></div>

<p>初始化后，每次显示更新，都会执行对应的 LUT 表时序。也就是说，全局刷新情况下的屏幕从全黑到全白好几次清空屏幕的动作，
就定义在这个 FULL 对应的 LUT 中。有兴趣的小伙伴可以解析下 <code class="language-plaintext highlighter-rouge">EPD_2IN13_lut_full_update</code>.</p>

<p>正因为有了 LUT 定义，屏幕以 <code class="language-plaintext highlighter-rouge">EPD_2IN13_PART</code> 方式初始化时，新显示内容不再需要全屏刷新后再显示，直接在原始状态进行绘制。</p>

<p>这里以 <code class="language-plaintext highlighter-rouge">EPD_2IN13_lut_partial_update</code> 为例介绍下实际 LUT 执行时候发生的动作。简单得多，以至于整个表只有 3 个非空字节，
对应 phase0A, phase0B, 其余 phase 设置因对应的 TP(period) 为 0, 不生效。所以只有两个 phase 的波形。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// LUT for partial update.</span>
<span class="nd">#[rustfmt::skip]</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">LUT_PARTIAL_UPDATE</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">// VS, voltage in phase n</span>
    <span class="c1">// &lt;&lt;VS[0A-HH]:2/binary, VS[0A-HL]:2/binary, VS[0A-LH]:2/binary, VS[0A-LL]:2/binary&gt;&gt;</span>
    <span class="c1">// &lt;&lt;VS[0B-HH]:2/binary, VS[0B-HL]:2/binary, VS[0B-LH]:2/binary, VS[0B-LL]:2/binary&gt;&gt;</span>
    <span class="c1">// HL: white to black</span>
    <span class="c1">// LH: black to white</span>
    <span class="c1">// e.g. 0x18 = 0b00_01_10_00</span>
    <span class="mi">0x18</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="c1">// phase 0</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="c1">// phase 1</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="c1">// phase 4</span>
    <span class="c1">// padding</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
    <span class="c1">// RP, repeat counter, 0 to 63, 0 means run time = 1</span>
    <span class="c1">// TP, phase period, 0 to 31</span>
    <span class="c1">// &lt;&lt;RP[0]_L:3/binary, TP[0A]:5/binary&gt;&gt;</span>
    <span class="c1">// &lt;&lt;RP[0]_H:3/binary, TP[0B]:5/binary&gt;&gt;</span>
    <span class="mi">0x0F</span><span class="p">,</span> <span class="mi">0x01</span><span class="p">,</span> <span class="c1">// phase 0</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="c1">// phase 4</span>
    <span class="c1">// padding</span>
    <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span> <span class="mi">0x00</span>
<span class="p">];</span>
</code></pre></div></div>

<p>如上，改写为 Rust 代码，加入详细注释，注释混搭假 Erlang 语法。</p>

<p>先看 VS 部分，即驱动电压部分。<code class="language-plaintext highlighter-rouge">0x18 = 0b00_01_10_00</code>, 按照格式拆出:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VS[0A-HL] = 01
VS[0A-LH] = 10

# 其他情况为 00
</code></pre></div></div>

<p>手册中有介绍 VS 格式:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00–VSS
01–VSH
10–VSL

分别是三种电压输出级别，其中 VSS 与顶版 VCOM 相等。相当于无电场存在。
VSH, VSL 分别会导致是两种不同的电场方向。
</code></pre></div></div>

<p>所以解读 phase0A 的配置即:</p>

<ul>
  <li>当像素点从白转黑时(HL), \(V_{pixel}\) 电压为 VSH</li>
  <li>当象素点从黑转白时(LH), \(V_{pixel}\) 电压为 VSL</li>
  <li>其他情况下，\(V_{pixel}\) 电压为 VSS, 由芯片手册可知, VSS = VCOM, 相当于无变化</li>
</ul>

<p>再来看 RP, TP 部分。需要将字节的高低位组合:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x0F = 0b000_01111
0x01 = 0b000_00001

所以得到
RP[0] = 0b000_000 = 0
TP[0A] = 0b01111 = 15
TP[0B] = 0b00001 = 1
</code></pre></div></div>

<p>如上提到, TP 为 0 时表示该 phrase 无效，所以上面说只有 phase0A, phase0B 两个 phase 有效。
RP = 0 是表示重复 1 次。</p>

<p>总结以上那么该 LUT 的逻辑是:</p>

<ul>
  <li>当像素点从白转黑时(HL), \(V_{pixel}\) 电压为 VSH, 持续 15 个周期，随后转 VSS, 持续一个周期</li>
  <li>当象素点从黑转白时(LH), \(V_{pixel}\) 电压为 VSL, 持续 15 个周期，随后转 VSS, 持续一个周期</li>
  <li>其他情况下，恒为 VSS</li>
  <li>以上逻辑执行 1 次</li>
  <li>单个周期文档中介绍时长为 \(T_{FRAME}\)</li>
</ul>

<p>所以似乎明了，所谓局部刷新，就是在像素点不变的时候，不做任何操作。
在像素翻转的情况下，执行一次给电压操作，随后静置少量时间。</p>

<p>而全刷新，可以很明显看到，前几个周期都是全置黑全置白的统一操作，为的是清屏。
之后才是处理不同像素状态变更的波形。</p>

<h4 id="idea">Idea</h4>

<p>持续电压 15 个周期，那么少一点会怎么样？</p>

<p>测试发现这样出图效果没那么黑，甚至是灰色。</p>

<p>所以似乎就有了在黑白墨水屏上实现灰度显示的方案。这里的黑白墨水屏，特指驱动手册中单个像素为 1 位的屏幕。即 1bpp(bit per pixel).</p>

<p>本文题头图，即为测试效果。</p>

<p>灰度显示的内容，另开坑讲。</p>

<h3 id="framebuffer">framebuffer</h3>

<blockquote>
  <p>A framebuffer (frame buffer, or sometimes framestore) is a portion of random-access memory (RAM) containing a bitmap that drives a video display.
It is a memory buffer containing data representing all the pixels in a complete video frame. – Wikipedia</p>
</blockquote>

<p>回到例程，可以看到屏幕初始化调用大概是:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EPD_2IN13_Init</span><span class="p">(</span><span class="n">EPD_2IN13_FULL</span><span class="o">/</span><span class="n">PART</span><span class="p">);</span>
<span class="n">EPD_2IN13_Clear</span><span class="p">();</span>

<span class="n">UBYTE</span> <span class="o">*</span><span class="n">BlackImage</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(...);</span>
<span class="n">Paint_NewImage</span><span class="p">(</span><span class="n">BlackImage</span><span class="p">,</span> <span class="n">EPD_2IN13_WIDTH</span><span class="p">,</span> <span class="n">EPD_2IN13_HEIGHT</span><span class="p">,</span> <span class="mi">270</span><span class="p">,</span> <span class="n">WHITE</span><span class="p">);</span>
<span class="n">Paint_SelectImage</span><span class="p">(</span><span class="n">BlackImage</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="n">EPD_2IN13_Display</span><span class="p">(</span><span class="n">BlackImage</span><span class="p">);</span>
</code></pre></div></div>

<p>阅读对应函数得知，这里创建了一个 <code class="language-plaintext highlighter-rouge">BlackImage</code> 字节数组做墨水屏的 framebuffer. 所有的绘图操作都只对这个 framebuffer 进行，
不和设备进行交互，直到调用 Display 才会进行实际的设备交互。</p>

<p>framebuffer 在 Display 被调用时，按照驱动芯片所设定的方向，比如按行，按列的方式，
一个个字节被从 MCU 传输到驱动芯片的内部的“显存”中，随后执行 LUT 更新逻辑。
驱动芯片会对比像素点的当前状态和目标状态，执行对应的 LH, HL, LL, HH 波形。
最终像素出现在屏幕上，完成显示。</p>

<h3 id="next">Next</h3>

<p>之后抽时间写写灰度显示相关的折腾过程。</p>

<p>和 Rust embedded-grahics 驱动的情况。</p>

<h2 id="参考">参考</h2>

<ul>
  <li>Waveshare 官方 store, <a href="https://www.waveshare.com/wiki/2.13inch_e-Paper_HAT">wiki</a></li>
  <li><a href="https://www.e-paper-display.com/download_detail/downloadsId=538.html">IL3895 数据手册</a></li>
  <li><a href="https://en.wikipedia.org/wiki/E_Ink">Wikipedia: E-Ink</a></li>
</ul>]]></content><author><name>andelf</name></author><category term="blog" /><category term="embedded" /><category term="epd" /><summary type="html"><![CDATA[故事从买屏幕说起。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://user-images.githubusercontent.com/72891/104635824-6825c900-56dd-11eb-8caa-d5eb00d11f70.jpg" /><media:content medium="image" url="https://user-images.githubusercontent.com/72891/104635824-6825c900-56dd-11eb-8caa-d5eb00d11f70.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Story of Year 2003</title><link href="https://andelf.github.io/blog/2021/01/01/story-of-year-2003/" rel="alternate" type="text/html" title="Story of Year 2003" /><published>2021-01-01T18:08:00+00:00</published><updated>2021-01-01T19:28:40+00:00</updated><id>https://andelf.github.io/blog/2021/01/01/story-of-year-2003</id><content type="html" xml:base="https://andelf.github.io/blog/2021/01/01/story-of-year-2003/"><![CDATA[<p>2003 竟然没找到张像样的照片。那时候生活没那么数码。还在用胶片。</p>

<p>其实更主要的原因是，整个世纪初的前几年，不曾拍过几张照片。或者出游，也是拍别人。</p>

<p>想讲讲 2003 的故事。其实这么久，能记得的，也都模糊到失真了。</p>

<h2 id="初三">初三</h2>

<p>那年初三。整个寒假在 Uncle Wang 家补课，说是补课，其实更像是托管。有英语和数学课。封闭管理。
他家用水不便，就记得那个寒假好像只洗了一两次头？
洗头这事，好说，当不洗的天数到达一定境界后，就已经感觉不到头发的存在了。</p>

<p>说起来万幸，还好有这一寒假的补课，不然中考大概率会考扯。</p>

<p>开学后就是紧张的中考前复习。依旧玩得昏天黑地。学校为了提高上线率，重新给两个实验班分了班，
二班一部分到我们一班，我班成绩靠后的去二班上课，两个班教学不同步，进度和教学内容都不太一样。</p>

<p>然后位置自己选，这可搞笑了，和一朋友自选搭了同桌，一起坐第一排。陕北方言把闲聊叫“谝”，
于是爱自习课说话的同学们各自封什么“谝王”，“谝圣”一类。形容的原话往往是，“那(ne)xxx太能谝了(liao4)，纯粹一谝x”。</p>

<p>那时候兼任物理课代表。整个初三下近乎所有的课都是做卷子加讲卷子的无聊组合，卷子大概是科任老师自己找的，
比如物理，我们于是每个人要交几块钱的试卷费。收试卷费的任务就落到我头上。</p>

<p>于是一个百无聊赖的晚自习，拉着十几号人，去心灵在线（离学校最近的网吧），用试卷费请大家上网。
近乎包了网吧二楼。那时候玩啥的都有，与几个好友那段时间玩的最多是暗黑破坏神，我玩刺客。</p>

<p>所以试卷费就这么被我散掉了。后来物理老师总碎碎念这大几十块钱，还了他。</p>

<p>初三，整个初中没有比我们更资历老的学生了，所以你看周围人总多少带点痞气，放学回家路上逗逗学妹一类的。
那时候初中生男女之间的感情，大概基本上就是写纸条，送xx回家之类。
“送xx回家”这可能要以后细了说。</p>

<h2 id="非典">非典</h2>

<p>突然有天，电视说什么 SARS, 什么非典，那时候口号最多的是叫“众志成城，抗击非典”。
倒是印象中没要求啥口罩，记得最深的是每天到教室那浓重的消毒水味。</p>

<p>于是乎网吧游戏厅台球室都关掉了，但朋友们间的小道消息说的是，因为中考前家长投诉关的。
然后黑网吧黑游戏厅成了同学们口口传的秘密，曾跟同学一起翘下午自习翻墙去一家黑游戏厅打 PS(就叫打索尼), 玩的是 FIFA,
但其实我不太会玩这类，被虐就是了。只是热闹。</p>

<p>非典对于小县城来说，也就茶余饭后的小话题，周围没有人真得了非典，那其实大家的消息源还是新闻联播。
依稀记得那年板蓝根的疯狂。但小县城，比板蓝根牛逼的让人啼笑皆非。比如，那时候县里时兴送领导求办事送免疫球蛋白，
或者干扰素。嗯，这个带劲儿。</p>

<p>因为非典的关系，我们那届毕业生没有毕业联欢晚会。很遗憾。之前一年的毕业联欢会上，还出了个小品，
自毁形象那种。</p>

<p>但突然非典就没了。大概也就是6月中考后，就再没有这个话题了。</p>

<h2 id="隔壁班">隔壁班</h2>

<p>那时候全校近乎每个班都有认识的人。曾自大地笑称，没有借不来的东西。</p>

<p>所以很多故事，也就从借东西开始发生。一借一还，看起来简单的事情，却不知，借的人或被借的人那一节课有没有各种胡思乱想。
一胡思乱想，诶，很多事就不一样了。</p>

<p>各种机缘巧合又错过，回头再看，真是捉弄人。</p>

<h2 id="中考">中考</h2>

<p>中考比想像中来得快很多。所有人都是突然间发现就要中考了。也不知复习没复习完事。</p>

<p>不曾想到，那时候遇到的人儿，成了后来很长一段时间里的重要的人，也最终成了一不可说的大遗憾。</p>

<p>嗨，苦就苦在，等你想明白这一切，这一切却已经过去了。</p>

<p>以至于成了很长时间都解不开的结，也无从再去回头解释自己的行为逻辑。空留下那么多年和 SA 的来回邮件，
总回看，总内牛满面。</p>

<p>中考就是这样一件事。有时候会梦到在这故事的某一刻，却问的是你这几年还好吗。</p>

<h2 id="高一">高一</h2>

<p>陌生的学校，陌生的环境，不多的几个老同学。</p>

<p>日常交际出问题，所以每周末就是单调和无聊。</p>

<p>就交际来说，现在看，可能自己是极被动的那种。总在等。但实际上又较依赖亲密关系的存在。</p>

<p>想起那时候的 IC 卡电话和校门外的话吧。某段时间里，也曾是常客。</p>

<p>这段高一，每年都会出现在梦里，那是种容易让人分不清现实的梦，总愿意在梦里永远呆下去不醒来。</p>]]></content><author><name>andelf</name></author><category term="blog" /><category term="diary" /><summary type="html"><![CDATA[2003 竟然没找到张像样的照片。那时候生活没那么数码。还在用胶片。]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://user-images.githubusercontent.com/72891/103444082-373aa280-4ca0-11eb-9e68-6410f2f6817c.png" /><media:content medium="image" url="https://user-images.githubusercontent.com/72891/103444082-373aa280-4ca0-11eb-9e68-6410f2f6817c.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Why?!</title><link href="https://andelf.github.io/blog/2020/11/27/why-and-why/" rel="alternate" type="text/html" title="Why?!" /><published>2020-11-27T04:00:00+00:00</published><updated>2020-11-27T08:27:15+00:00</updated><id>https://andelf.github.io/blog/2020/11/27/why-and-why</id><content type="html" xml:base="https://andelf.github.io/blog/2020/11/27/why-and-why/"><![CDATA[<p>“为什么呢，这次你这么坏，我却还是会想你。”</p>

<p>“总是这样，来不及相认就失散。”</p>]]></content><author><name>andelf</name></author><category term="blog" /><category term="diary" /><summary type="html"><![CDATA[“为什么呢，这次你这么坏，我却还是会想你。”]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://user-images.githubusercontent.com/72891/100425593-7cc8e600-30ca-11eb-873c-1f9878911c20.jpg" /><media:content medium="image" url="https://user-images.githubusercontent.com/72891/100425593-7cc8e600-30ca-11eb-873c-1f9878911c20.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Welcome to Jekyll!</title><link href="https://andelf.github.io/blog/2020/11/16/welcome-to-jekyll/" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2020-11-16T06:54:24+00:00</published><updated>2020-11-16T07:47:16+00:00</updated><id>https://andelf.github.io/blog/2020/11/16/welcome-to-jekyll</id><content type="html" xml:base="https://andelf.github.io/blog/2020/11/16/welcome-to-jekyll/"><![CDATA[<p>是的我升级了.</p>

<p>是的我又回来了.</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><summary type="html"><![CDATA[是的我升级了.]]></summary></entry><entry><title type="html">迷之一键部署</title><link href="https://andelf.github.io/blog/2020/02/27/one-click/" rel="alternate" type="text/html" title="迷之一键部署" /><published>2020-02-27T06:00:00+00:00</published><updated>2020-11-16T08:12:52+00:00</updated><id>https://andelf.github.io/blog/2020/02/27/one-click</id><content type="html" xml:base="https://andelf.github.io/blog/2020/02/27/one-click/"><![CDATA[<p>搞 IT 技术相关的，尤其是后端技术和分布式相关的同学，怕是不只一次听过所谓的一键部署的提法，与此相似或者相关的，可能还包括自动化部署，一键上线/回滚，以及 CI/CD 相关的持续部署，持续集成，持续交付等等概念。</p>

<p>这里，不谈 CI/CD，只谈作为对用户产品的一键部署，无论是叫 one-click, single-click, one-key, one-press, one-button, one-command, single-command… 还是只是对外发布的某种快速部署工具(集)。部署，俗称上线，不过细究概念，上线似乎更侧重日常功能更新，而部署的概念，更侧重首次的初始环境搭建。无论何，传统上，部署都是运维(OP)同学的日常工作。</p>

<p>所谓一键，大都是虚指。做过运维的同学知道，部署怎么可能是一件容易的事情。考虑到现代服务端软件集的庞大，从数据库/缓存，到后端逻辑，到前端服务，到监控系统，到报警系统，各组件相互配合，才完成最终对用户提供服务。更不用说机房服务器环境，云主机环境，现代分布式服务的多样和复杂性，导致 trouble shooting 极其复杂，哪怕是饱经事故的老 OP，也不容易。</p>

<p>正因有了这些复杂性，可信赖的部署工具就更显得重要。好用的工具不只为虎添翼，还给萌新在黑夜里点了盏明灯，在产品拉新的层面更有极其重要的作用。垃圾的工具，处处是坑不说，让人骂娘的心都有，且有工具还不如没有工具。没有工具的时候，OP 拿着命令行一顿敲，不也成功部署了么？</p>

<p>是的，关于一键部署，这里要从命令行说起。</p>

<h2 id="一键部署从哪来">一键部署从哪来</h2>

<h3 id="命令行-op">命令行 OP</h3>

<p>最原始的典型服务部署过程，不过是登录到服务器，通过 scp/wget 下载到最近的软件包，解压编译，必要时候还需要下载若干编译依赖，然后修改配置，最后启动程序完成部署。</p>

<p>潮一点的容器部署方式，拉几个容器镜像下来，加上参数 run 起来，也是略苦逼。</p>

<p>是命令，就有可能出错，相信多数 OP 都有一个命令行小本本，记录着常见操作需要执行的命令。</p>

<h3 id="一键部署小脚本儿">一键部署小脚本儿</h3>

<p>看起来传统的命令行式部署很容易自动化，把这些命令集合在一起，于是就诞生了最原始的，一键部署脚本儿。脚本丢到服务器上，一执行，漫长或短暂的等待过去，服务 ready.</p>

<p>而容器化部署，也可以自动化成 docker-compose 等待，外部包一个处理配置的脚本，依旧好使。</p>

<p>随后 OP 同学为该脚本增加了更多的命令行参数，比如软件包版本号，部署路径，配置文件的某条常修改的参数，看起来这个时候，已经可以交付外部使用了。</p>

<h3 id="一键部署命令行工具集">一键部署命令行工具集</h3>

<p>然而多数服务端软件比以上流程复杂得多，OP 们往往面对的是一个集群，每台机器的配置或命令都有所不同，且服务的启停过程往往具有某种依赖顺序。这时候，简单的命令堆叠小脚本就不能满足需求了。</p>

<p>开源届倒是提供了不少解决方案，比如 Ansible, Puppet, Chef 等待，以及若干虚拟化解决方案，实现了配置，执行，部署，交付的完整流程。此外还有若干轻量工具，靠更多的人工配置环境提供更高的自由度，例如 fabric.</p>

<p>这时候的一键部署，可能就是某个强大工具的配置文件，描述了部署的步骤，然后加上目标机器环境的配置文件，通过执行一条命令，完成整个环境检查，环境初始化，部署应用，启动应用的全流程。</p>

<p>例如 ansible-playbook -i inventory install.yml 这样一条命令，加载 install.yml 描述的安装流程，然后在 inverntory 指定的服务器列表上执行这些安装流程。</p>

<p>但是这样的工具有一个很大的缺点，那就是运行异常可能需要工具的专家介入。专家大概是能给工具写插件级别的。以 Ansible 为例，能讲清楚机器登陆时候，不同发行版报错原因以及解决方法的人，并不多。</p>

<p>对于容器化部署，那当然要诉诸于各种编排工具，不在此讨论了。</p>

<h3 id="一键部署-ui">一键部署 UI</h3>

<p>严格地说，命令行也是 UI 的一种，原教旨主义会告诉你，UI 就是 User Interface，就好比 explorer.exe 也是 SHELL 一样。这里说的 UI, 特指 GUI，大概包括说有的图形应用程序，尤其指浏览器 Web UI.</p>

<p>之前在推上有句吐槽，“每个傻逼的后端产品 PM，都有一颗给命令行写 GUI 的心“，这话放在一键部署领域，依旧是合适无比。</p>

<p>做好 UI 的第一步，大概是不做 UI.</p>

<p>你可以认为 UI 在大部分时候是伪需求，问问自己的内心：在已经有较完善的一键部署工具集或者脚本的情况下，为什么做 UI?</p>

<p>其实答案很简单，UI 不是给 OP 或者一线工程师用的。它目标是为了把一件事情的门槛降低到尽可能低，低到只是恰好理解这个服务是干什么有什么要素的人，也能操作。</p>

<p>然而这是不可能的。所以所谓的你看到到的一众 UI 只能将大部分晦涩的配置选项隐藏起来，然后让你填写一个机器列表然后”一键“部署。然后失败了，弹出简洁的“部署失败”四个大字，或是晦涩的冗长的没人会去看的错误日志。</p>

<p>迄今为止，见过可以说的上能用的一键部署 UI, 可能是 Ansible-Tower，即 Ansible AWX, 但它真的只是包装了 Ansible 的命令行，所以足够简洁，足够完备。然而它的 trouble shooting 难度依旧是 Ansible 级的。除非你对 Ansible 足够熟悉，否则还是找足够经验丰富的人去追查背后到底发生了什么错误。</p>

<h3 id="历史的例外">历史的例外</h3>

<p>大概会有若干种特殊情况。例如大型公司的自研（或致敬某开源项目的）内部系统，例如云平台服务商的某些自动部署工具等。共同点是，受控底层环境，用户有天然身份门槛。</p>

<p>所以这个时候，不乏内部优秀工具或是云平台优秀工具。</p>

<h2 id="一键部署现状">一键部署现状</h2>

<p>然而该做不该做的东西，总是要做的。所以谈谈一键部署到底要做啥吧？这里主要谈分布式系统集群的一键部署。一个应用一个二进制文件一台机器，就真没必要折腾。</p>

<h3 id="inventory-管理">Inventory 管理</h3>

<p>这里的 inventory, 泛指一切目标资产，比如服务器，云主机或者虚拟机。其中的属性信息繁杂，和后续的部署过程有着强依赖，比如机器上的配置，例如磁盘空间，内存，CPU 时间等。通过 inventory 的自动检查和初始化脚本，获取各种信息，为部署过程提供方便。</p>

<p>部分支持云主机的 Inventory 管理，还包括按需动态创建主机实例。</p>

<p>再广义些，还可能包括外部可用的服务资源，例如公共的 redis 服务。</p>

<h4 id="credential-管理">Credential 管理</h4>

<p>Credential 是指登陆机器进行操作的用户权限，比如 SSH 私钥，或是机器的用户名密码，或是云平台的访问所需密钥 KEY.</p>

<h3 id="应用管理">应用管理</h3>

<p>所谓应用，就是将要部署的服务（往往包含多个不同子应用），它们之间通过特定的依赖关系互联，最终对外界提供服务。除核心服务应用之外，还可能包括监控应用(含报警应用)，管理应用(adminstrative dashboard)，工具应用(例如备份/恢复工具)等。</p>

<p>应用的管理，主要是应用元信息的管理，应用之间的依赖关系管理，应用对资源的关系，应用配置管理。</p>

<p>应用元信息的管理，往往是描述一个应用的诸如版本，二进制等等信息，往往是部署的第一步，先准备好将要部署的应用。其中涉及到产品二进制分发的问题，则是额外的话题了。</p>

<p>应用之间依赖，应用对资源的依赖关系的管理，往往通过配置管理的形态实现。</p>

<h3 id="配置管理">配置管理</h3>

<p>配置管理不只包括应用配置管理，往往还包括部署的配置管理，但两者之间往往存在交叉融合的地方，比如说指定某个机器的上部署的应用 A 需要一个特殊的配置项。</p>

<h4 id="应用配置管理">应用配置管理</h4>

<p>管理各应用的配置参数，最终可能以配置文件，应用启动的命令行参数，或是应用的环境变量等方式存在。其中部分配置暗含各应用各部署目标机器之间的互联关系，往往是动态生成得到。例如</p>

<ul>
  <li>应用提供服务的端口号</li>
  <li>应用的数据目录</li>
  <li>应用的日志目录</li>
  <li>某应用有两套配置，一套用于生产环境，一套应用于测试环境</li>
  <li>某条配置项目按某种特定规律生成</li>
  <li>某配置项目随机生成，但要求全服务集群应用的改配置项必须相同</li>
</ul>

<h4 id="部署配置管理">部署配置管理</h4>

<p>部署配置管理其实就是所部署的应用到具体的部署目标之间的映射关系。例如：</p>

<ul>
  <li>某台机器是监控机，需要部署所有监控模块</li>
  <li>某台机器需要打开端口 80 提供服务</li>
  <li>某台机器的某个目录部署应用 A</li>
  <li>某台机器的某个目录做应用 B 的数据目录</li>
</ul>

<p>部署配置管理的高级形态，是声明式。即机器声明我支持某资源，由一键部署系统自动选择依赖关系。这也稍许牵扯到高级形态的部署。</p>

<h3 id="状态数据管理">状态数据管理</h3>

<p>应用的正常运行，不只依赖配置，往往还有若干依赖数据。传统的静态依赖数据之外，就是动态数据了，往往以数据库或是数据目录的方式存在。</p>

<p>状态数据的管理，是整个部署届的难题。越是庞大的状态数据，在部署，环境变更，灾难恢复，以及迁移的时候就越成为问题。</p>

<p>现代分布式系统一般通过底层分布式数据库的方式解决状态数据管理，然而这带来了一个鸡生蛋蛋生鸡的问题，底层分布式数据库的部署，又是一个状态数据管理问题。</p>

<p>是的。我们还有分布式文件系统。233。</p>

<h3 id="部署管理">部署管理</h3>

<p>部署管理，即管理具体的部署操作任务。往往通过任务队列的方式实现，是整个一键部署最核心的部分。</p>

<p>在部署过程中，尤其要提供相对较清晰的进度展示，并输出合理的操作日志供时候追查问题。</p>

<p>部署往往也包含了变更管理，即应用版本或某依赖更新后，再次触发部署。所以部署不应是一次性任务，而是可重入任务。</p>

<p>部署任务的触发一般提供手动和自动两种模式。所谓的“一键”就是这里点击的“部署”按钮。</p>

<p>而自动触发，就隶属持续部署或是持续交付的范畴了，一般通过某种触发器或是任务计划实现。</p>

<h3 id="监控管理">监控管理</h3>

<p>服务的正常运行，离不开监控。在一键部署系统中，监控往往作为单独的应用存在，所以将之化解为另一个应用管理的问题。</p>

<p>监控往往包括监控数据的收集，监控数据的查询展示，日志收集等问题。高级形态还包括动态调试等，加入了诊断系统的功能。</p>

<p>监控系统一般还会提供通知(notification)的功能，报警或者状态日报信息通过通知系统发送给关注者。</p>

<h3 id="服务管理">服务管理</h3>

<p>服务管理相对较简单，即一个部署完成的集群，其中服务的启动，停止，删库跑路等操作。其中还可能牵扯到服务存活检测，服务自启动，服务异常自动重启(保活)等知识点。</p>

<p>服务管理可以作为特殊的部署操作来实现，比如设定特定的部署动作，检查环境后启停对应服务。</p>

<h3 id="pm-们提出的其他管理">PM 们提出的其他管理</h3>

<p>如上是核心功能。然后 PM 往往会提其他需求。例如：</p>

<ul>
  <li>权限管理：作为持久运行的变更系统，至少需要一个权限控制，尤其生成环境
    <ul>
      <li>用户管理</li>
      <li>用户组管理</li>
      <li>用户和用户组的权限管理</li>
    </ul>
  </li>
  <li>多应用管理：即整个一键部署工具作为通用平台</li>
</ul>

<h2 id="一键部署的将要到哪里去">一键部署的将要到哪里去</h2>

<p>一键部署，终将要被云平台或是云平台的容器编排消灭的吧。</p>

<p>但到时候，又是给容器编排做 UI 了。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="ci" /><summary type="html"><![CDATA[搞 IT 技术相关的，尤其是后端技术和分布式相关的同学，怕是不只一次听过所谓的一键部署的提法，与此相似或者相关的，可能还包括自动化部署，一键上线/回滚，以及 CI/CD 相关的持续部署，持续集成，持续交付等等概念。]]></summary></entry><entry><title type="html">Fix Ansible Tower: stdout capture is missing</title><link href="https://andelf.github.io/blog/2016/12/07/fix-ansible-tower-stdout-capture-is-missing/" rel="alternate" type="text/html" title="Fix Ansible Tower: stdout capture is missing" /><published>2016-12-07T08:33:20+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2016/12/07/fix-ansible-tower-stdout-capture-is-missing</id><content type="html" xml:base="https://andelf.github.io/blog/2016/12/07/fix-ansible-tower-stdout-capture-is-missing/"><![CDATA[<p>Ansible Tower will report <code class="language-plaintext highlighter-rouge">stdout capture is missing</code> when restoring from previous backup.</p>

<p>Or run from docker?</p>

<p>(得，不装 B 英语了)</p>

<p>长话短说，之前要把 Ansible Tower 拆到 Docker 里，结果发现总不能正常执行。任务界面会提示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stdout capture is missing
</code></pre></div></div>

<p>检查发现是 celery 进程出错，用 root 启动 celery 倒是正常的。</p>

<p>最后发现是 docker 中的 supervisord 启动时缺乏部分环境变量，解决方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>change supervisor/conf.d/tower.conf
ADD:
[program:awx-celeryd]
......
environment=HOME="/var/lib/awx",USER="awx"
......
</code></pre></div></div>

<p>是的，为找到原因，逆向了整个 Ansible Tower。</p>

<p>Ref: <a href="https://github.com/ansible/ansible/issues/13904">GitHub Issue</a></p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="linux" /><category term="ansible" /><summary type="html"><![CDATA[Ansible Tower will report stdout capture is missing when restoring from previous backup.]]></summary></entry><entry><title type="html">在 CircleCI 上使用 Rust(CircleCI meets Rust)</title><link href="https://andelf.github.io/blog/2016/11/18/circleci-meets-rust/" rel="alternate" type="text/html" title="在 CircleCI 上使用 Rust(CircleCI meets Rust)" /><published>2016-11-18T05:26:15+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2016/11/18/circleci-meets-rust</id><content type="html" xml:base="https://andelf.github.io/blog/2016/11/18/circleci-meets-rust/"><![CDATA[<p>最近由于频频遇到 travis-ci 的问题，主要是 Linux 资源排队、macOS 资源更需要排队，导致自动测试时间被拉长，
影响开发效率。</p>

<p>了解到 CircleCI 是不错的替代品，所以打算迁移 Rust 项目过去。当然说起来， CircleCI 的野心更大，是要来替代 jenkins 的。</p>

<p>目前官方支持语言其实都比较落后，包括 go 也只是 1.6 版本，但似乎不是问题，而且据介绍， CircleCI 2.0 支持自定义 build image，支持语言的版本当然不在话下。</p>

<p>每天面对各种 IaaS, PaaS，免不了写配置是，这也是 yaml 程序员的日常。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">pre</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">curl https://sh.rustup.rs -sSf | sh</span>

<span class="na">test</span><span class="pi">:</span>
  <span class="na">override</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">cargo build</span>
    <span class="pi">-</span> <span class="s">cargo test</span>
</code></pre></div></div>

<p>如上。然而不 work。报错：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: spurious network error (2 tries remaining): [12/-12] Malformed URL 'ssh://git@github.com:/rust-lang/crates.io-index'
warning: spurious network error (1 tries remaining): [12/-12] Malformed URL 'ssh://git@github.com:/rust-lang/crates.io-index'
error: failed to fetch `https://github.com/rust-lang/crates.io-index`

To learn more, run the command again with --verbose.

cargo build returned exit code 101

Action failed: cargo build
</code></pre></div></div>

<p>神了。原来， CircleCI 自作聪明在 <code class="language-plaintext highlighter-rouge">.gitconfig</code> 里修改了映射配置，强制用它自己的 ssh key 去访问 github，rewrite 了 <code class="language-plaintext highlighter-rouge">https://github.com</code> 的所有仓库。
这恰恰和 cargo 的 registry 机制冲突。所以报错。</p>

<blockquote>
  <p>CircleCI has rewrite <code class="language-plaintext highlighter-rouge">https:://github.com</code> to <code class="language-plaintext highlighter-rouge">ssh://git@github.com:</code> in <code class="language-plaintext highlighter-rouge">.gitconfig</code>. And this made cargo fail with above error message.</p>
</blockquote>

<p>找到了原因，就可以搞了：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">machine</span><span class="pi">:</span>
  <span class="na">pre</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">sed -i 's/github/git-non-exist-hub/g' ~/.gitconfig</span>

<span class="na">dependencies</span><span class="pi">:</span>
  <span class="na">pre</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">curl https://sh.rustup.rs -sSf | sh</span>

<span class="na">test</span><span class="pi">:</span>
  <span class="na">override</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">cargo build</span>
    <span class="pi">-</span> <span class="s">cargo test</span>
</code></pre></div></div>

<p>嗯, Ugly but works.</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="rust" /><category term="ci" /><summary type="html"><![CDATA[最近由于频频遇到 travis-ci 的问题，主要是 Linux 资源排队、macOS 资源更需要排队，导致自动测试时间被拉长， 影响开发效率。]]></summary></entry><entry><title type="html">折腾 Raspberry Pi + HomeKit 手记</title><link href="https://andelf.github.io/blog/2016/09/16/play-homekit-with-ios-10-and-raspberry-pi/" rel="alternate" type="text/html" title="折腾 Raspberry Pi + HomeKit 手记" /><published>2016-09-16T12:34:43+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2016/09/16/play-homekit-with-ios-10-and-raspberry-pi</id><content type="html" xml:base="https://andelf.github.io/blog/2016/09/16/play-homekit-with-ios-10-and-raspberry-pi/"><![CDATA[<p>9月14日凌晨苹果终于推送了 iOS 10 的更新。从之前发布会来看，并没有多少亮点，除了几天的新鲜感之外，
尤其是对于目前还在用上两代机型的我来说，2333。</p>

<p>两年前苹果发布 Swift 语言的同时，新增了 HomeKit，当时用工具 dump 过最老版本的 Swift 声明。传送门：<a href="https://github.com/andelf/Defines-Swift/blob/6a8cda2e12bf6e5a23979a1ad121e70a0eeef6dd/HomeKit.swift">HomeKit.swift</a>。目前所有官方相关的资料位于 <a href="http://www.apple.com/ios/home/">HomeKit - Apple</a>。</p>

<p>好消息是期待很久的 HomeKit 应用终于上线，屏幕上多了“家庭(Home)”应用，控制中心（从屏幕下方滑动）、
Siri 均对此有支持。
iOS 10 终于强化了推出已有两年智能家居平台，提供了官方 App，有不少硬件厂商支持。</p>

<p>简单说，HomeKit 就是苹果官方的智能家居平台解决方案，包括移动设备 SDK，智能家居硬件通信协议(HAP: HomeKit Accessory Protocol)、以及 MFi(Made for iPhone/iPod/iPad) 认证等等。通过 WiFi 或蓝牙连接智能家居设备（或 bridge 设备），也可以利用 Apple TV(4代) 或闲家中的置 iPad 实现设备的远程控制（HAP over iCloud）。</p>

<p>Home App 的维度划分：</p>

<ul>
  <li>Home: 家，和地理位置绑定，支持共享给好友控制。</li>
  <li>Room: 房间，用于对设备进行分组。</li>
  <li>Scene: 场景，一组对设备的配置，例如“起床”，那么可能的配置是打开卧室灯、窗帘、放段舒缓music等等。</li>
</ul>

<p>众所周知苹果是卖数据线等硬件的公司（嗯，假设你数据线也坏过不少），HAP 协议部分是需要加入 MFi Program 才能获取文档，而且 MFi Program 无法以个人开发者身份加入。</p>

<p>好在有好心人逆向了 HAP 的服务端协议（对于智能硬件来说，硬件是服务端，手机App是客户端）。</p>

<p>对于折腾党来说，机会来了，自己动手改造家居！本文不涉及 App 开发，只涉及如何自制支持 HomeKit 的设备。</p>

<h2 id="准备工作">准备工作</h2>

<p>设备列表：</p>

<ul>
  <li>iPhone 6P (iOS 10)</li>
  <li>Raspberry Pi 3 (Debian jessie)</li>
</ul>

<p>考察了两个比较靠谱的 HAP 实现：</p>

<ul>
  <li>https://github.com/KhaosT/HAP-NodeJS</li>
  <li>https://github.com/brutella/hc (golang)</li>
</ul>

<p>最终选择使用 golang 的 <code class="language-plaintext highlighter-rouge">brutella/hc</code>，准备环境。</p>

<p>需要保证树莓派和手机位于统一子网，因为 HAP 底层是基于 Apple mDNS(RFC 6762)。</p>

<p><code class="language-plaintext highlighter-rouge">brutella/hc</code> 要求 golang &gt;= 1.4，而 Debian jessie 版本较低，
需要配置 jessie-backports 源：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deb ftp://ftp.cn.debian.org/debian jessie-backports main contrib non-free
</code></pre></div></div>

<p>同时导入源的 GPG Key。方法参考 <a href="http://raspberrypi.stackexchange.com/questions/12258/where-is-the-archive-key-for-backports-debian-org">这里</a>。</p>

<p>安装好 golang 1.6.2，建立开发目录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 似乎直接 install golang 会出点小问题，所以折衷用了如下方法:</span>
<span class="o">&gt;</span> <span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-t</span> jessie-backports golang-1.6 golang-1.6-go golang-1.6-src golang-1.6-doc
<span class="o">&gt;</span> <span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-t</span> jessie-backports golang
</code></pre></div></div>

<h2 id="示例">示例</h2>

<p>跑通官方示例代码：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"github.com/brutella/hc"</span>
	<span class="s">"github.com/brutella/hc/accessory"</span>
	<span class="s">"log"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">info</span> <span class="o">:=</span> <span class="n">accessory</span><span class="o">.</span><span class="n">Info</span><span class="p">{</span>
		<span class="n">Name</span><span class="o">:</span>         <span class="s">"Lamp"</span><span class="p">,</span>
		<span class="n">SerialNumber</span><span class="o">:</span> <span class="s">"051AC-23AAM1"</span><span class="p">,</span>
		<span class="n">Manufacturer</span><span class="o">:</span> <span class="s">"Apple"</span><span class="p">,</span>
		<span class="n">Model</span><span class="o">:</span>        <span class="s">"AB"</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="n">acc</span> <span class="o">:=</span> <span class="n">accessory</span><span class="o">.</span><span class="n">NewSwitch</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

	<span class="n">acc</span><span class="o">.</span><span class="n">Switch</span><span class="o">.</span><span class="n">On</span><span class="o">.</span><span class="n">OnValueRemoteUpdate</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">on</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">on</span> <span class="o">==</span> <span class="no">true</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Client changed switch to on"</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Client changed switch to off"</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="n">config</span> <span class="o">:=</span> <span class="n">hc</span><span class="o">.</span><span class="n">Config</span><span class="p">{</span><span class="n">Pin</span><span class="o">:</span> <span class="s">"00102003"</span><span class="p">}</span>
	<span class="n">t</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">hc</span><span class="o">.</span><span class="n">NewIPTransport</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">acc</span><span class="o">.</span><span class="n">Accessory</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">hc</span><span class="o">.</span><span class="n">OnTermination</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="n">t</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译执行.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ AppleHome&gt; # current dir

$ AppleHome&gt; go get
...

$ AppleHome&gt; go build
...

$ AppleHome&gt; ./AppleHome
...
</code></pre></div></div>

<p>随后打开手机的 Home App，添加设备，选择 Lamp，输入 PIN 00102003，完成配对，即可使用。</p>

<h2 id="自定义设备">自定义设备</h2>

<p>树莓派外接小音箱一只，用来放电台，尝试用 HomeKit 控制树莓派的禁音。命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>amixer set PCM on
amixer set PCM off
</code></pre></div></div>

<p>代码：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
        <span class="s">"os/exec"</span>
        <span class="s">"github.com/brutella/hc"</span>
        <span class="s">"github.com/brutella/hc/accessory"</span>
        <span class="s">"log"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">info</span> <span class="o">:=</span> <span class="n">accessory</span><span class="o">.</span><span class="n">Info</span><span class="p">{</span>
                <span class="n">Name</span><span class="o">:</span>            <span class="s">"Radio"</span><span class="p">,</span>
                <span class="n">SerialNumber</span><span class="o">:</span> <span class="s">"051AC-23AAM2"</span><span class="p">,</span>
                <span class="n">Manufacturer</span><span class="o">:</span> <span class="s">"Apple"</span><span class="p">,</span>
                <span class="n">Model</span><span class="o">:</span>          <span class="s">"RPI3"</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">acc</span> <span class="o">:=</span> <span class="n">accessory</span><span class="o">.</span><span class="n">NewSwitch</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="n">acc</span><span class="o">.</span><span class="n">Switch</span><span class="o">.</span><span class="n">On</span><span class="o">.</span><span class="n">OnValueRemoteUpdate</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">on</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Toggled PCM!"</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">on</span> <span class="o">==</span> <span class="no">true</span> <span class="p">{</span>
                        <span class="n">exec</span><span class="o">.</span><span class="n">Command</span><span class="p">(</span><span class="s">"amixer"</span><span class="p">,</span> <span class="s">"set"</span><span class="p">,</span> <span class="s">"PCM"</span><span class="p">,</span> <span class="s">"on"</span><span class="p">)</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Client changed switch to on"</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">exec</span><span class="o">.</span><span class="n">Command</span><span class="p">(</span><span class="s">"amixer"</span><span class="p">,</span> <span class="s">"set"</span><span class="p">,</span> <span class="s">"PCM"</span><span class="p">,</span> <span class="s">"off"</span><span class="p">)</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Client changed switch to off"</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">})</span>

        <span class="n">config</span> <span class="o">:=</span> <span class="n">hc</span><span class="o">.</span><span class="n">Config</span><span class="p">{</span><span class="n">Pin</span><span class="o">:</span> <span class="s">"00102004"</span><span class="p">}</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">hc</span><span class="o">.</span><span class="n">NewIPTransport</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">acc</span><span class="o">.</span><span class="n">Accessory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">hc</span><span class="o">.</span><span class="n">OnTermination</span><span class="p">(</span><span class="k">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">t</span><span class="o">.</span><span class="n">Stop</span><span class="p">()</span>
        <span class="p">})</span>

        <span class="n">t</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="其他">其他</h2>

<p>HAP 将智能家居分为以下维度：</p>

<ul>
  <li>Accessory: 单个设备，例如开关，温度计，调节器</li>
  <li>Service: 一组值，合起来提供服务，例如中央空调（调节温度，风速等等）</li>
</ul>

<p>TODO</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="ios" /><summary type="html"><![CDATA[9月14日凌晨苹果终于推送了 iOS 10 的更新。从之前发布会来看，并没有多少亮点，除了几天的新鲜感之外， 尤其是对于目前还在用上两代机型的我来说，2333。]]></summary></entry><entry><title type="html">Swift 3.0 尝试——从入门到再学一门(A Glimpse of Swift 3.0)</title><link href="https://andelf.github.io/blog/2016/04/28/a-glimpse-of-swift-3-dot-0/" rel="alternate" type="text/html" title="Swift 3.0 尝试——从入门到再学一门(A Glimpse of Swift 3.0)" /><published>2016-04-28T02:06:53+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2016/04/28/a-glimpse-of-swift-3-dot-0</id><content type="html" xml:base="https://andelf.github.io/blog/2016/04/28/a-glimpse-of-swift-3-dot-0/"><![CDATA[<p>安装工具</p>

<p>https://github.com/kylef/swiftenv</p>

<h2 id="swift-30-新变化">Swift 3.0 新变化</h2>

<p>以下内容来自 Swift 语言提案<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>。</p>

<p>Swift 3.0 发布计划</p>

<h3 id="swift-package-system">Swift Package System</h3>

<p>https://github.com/donald-pinckney/swift-packages</p>

<h2 id="ast-结构">AST 结构</h2>

<p>代码位于 <code class="language-plaintext highlighter-rouge">include/swift/AST</code> 和 <code class="language-plaintext highlighter-rouge">lib/AST</code>。</p>

<p>ModuleDecl
模块（单个库或是可执行文件）。编译的最小单元，由多个文件组成。</p>

<p>FileUnit（抽象类）
文件作用域，是代码组织的最小单元。</p>

<ul>
  <li>DerivedFileUnit: A container for a module-level definition derived as part of an implicit protocol conformance.</li>
  <li>SourceFile: A file containing Swift source code. .swift 或 .sil 也可以是虚拟 REPL
    <ul>
      <li>Imports: Vec&lt;(ImportedModule, ImportOptions)&gt;</li>
      <li>Identifier</li>
      <li>Decls: Vec<Decl></Decl></li>
      <li>LocalTypeDecl: Vec<TypeDecl></TypeDecl></li>
      <li>ObjCMethods: Map&lt;ObjCSelector, AbstractFunctionDecl&gt;</li>
      <li>infix, postfix, prefix operators: OperatorMap</li>
    </ul>
  </li>
  <li>BuiltinUnit</li>
</ul>

<h2 id="swift-命令入口">swift 命令入口</h2>

<p>入口函数 <code class="language-plaintext highlighter-rouge">tools/driver/driver.cpp</code>，<code class="language-plaintext highlighter-rouge">main</code> 函数。</p>

<p>集成多个子工具。同时若 <code class="language-plaintext highlighter-rouge">PATH</code> 下有名为 <code class="language-plaintext highlighter-rouge">swift-foobar</code> 的可执行文件，则可通过 <code class="language-plaintext highlighter-rouge">swift foobar</code> 调用。</p>

<h3 id="编译器前端-swift--frontend">编译器前端 <code class="language-plaintext highlighter-rouge">swift -frontend</code></h3>

<p>编译。同时支持打印出各种编译时中间结果。</p>

<h3 id="api-notes-功能-swift--apinotes">API Notes 功能 <code class="language-plaintext highlighter-rouge">swift -apinotes</code></h3>

<p>参考信息位于 <a href="https://github.com/apple/swift/tree/master/apinotes">https://github.com/apple/swift/tree/master/apinotes</a> .</p>

<p>简单说，API Notes 机制就是通过 <code class="language-plaintext highlighter-rouge">.apinotes</code> 文件（YAML格式）描述 Objective-C Framework 和对应 Swift API 的关系。最终生成 <code class="language-plaintext highlighter-rouge">.apinotesc</code> 文件，与 <code class="language-plaintext highlighter-rouge">.swiftmodule</code> 文件一起作为 Swift 的模块。</p>

<p>主要功能包括且不限于：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SwiftBridge</code>：设置对应的 Bridge 类型，例如 NSArray 对应与 <code class="language-plaintext highlighter-rouge">Swift.Array</code></li>
  <li><code class="language-plaintext highlighter-rouge">Nullability</code>/<code class="language-plaintext highlighter-rouge">NullabilityOfRet</code>： 类的属性、方法的参数、返回值对应类型是否可以为 null，即对应与 Swift 的 T 还是 T?</li>
  <li><code class="language-plaintext highlighter-rouge">Availability</code>：方法是否在 Swift 中暴露，并给出 availability message</li>
  <li><code class="language-plaintext highlighter-rouge">SwiftName</code>：方法 Selector 在 Swift 中的重命名，例如 <code class="language-plaintext highlighter-rouge">filteredArrayUsingPredicate:</code> 替换为 <code class="language-plaintext highlighter-rouge">filtered(using:)</code></li>
</ul>

<p>Dump 为YAML文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$&gt; swift -apinotes -binary-to-yaml /path/to/lib/swift/macosx/x86_64/Dispatch.apinotesc -o=-
</code></pre></div></div>

<h3 id="module-wrap-工具-swift--modulewrap">Module Wrap 工具 <code class="language-plaintext highlighter-rouge">swift -modulewrap</code></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Wraps .swiftmodule files inside an object file container so they
// can be passed to the linker directly. Mostly useful for platforms
// where the debug info typically stays in the executable.
// (ie. ELF-based platforms).
</code></pre></div></div>

<p>用法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swift -modulewrap ObjectiveC.swiftmodule -o objc.o
</code></pre></div></div>

<p>实际发现是在 <code class="language-plaintext highlighter-rouge">.o</code> 里定义了 <code class="language-plaintext highlighter-rouge">___Swift_AST</code> 符号。</p>

<h3 id="repl">REPL</h3>

<p>Swift 提供了两个 REPL(Read-Evaluate-Print Loop)，一个是 Swift 本身内置，另一个集成到了 lldb 命令行下。前者只有基本功能，即将废弃，后者功能更强大。</p>

<p>子命令分别是：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">swift -deprecated-integrated-repl</code></li>
  <li><code class="language-plaintext highlighter-rouge">swift -lldb-repl</code>。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">swift -repl</code> 子命令选择可用的 REPL 进入，一般是 <code class="language-plaintext highlighter-rouge">lldb-repl</code>，除非找不到 lldb 时。这也是 Swift 命令不带任何参数的默认行为。</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>(apple/swift-evolution)[https://github.com/apple/swift-evolution] <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[安装工具]]></summary></entry><entry><title type="html">Rust Pattern Match(Rust中的模式匹配)</title><link href="https://andelf.github.io/blog/2016/03/22/rust-pattern-match/" rel="alternate" type="text/html" title="Rust Pattern Match(Rust中的模式匹配)" /><published>2016-03-22T15:35:19+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2016/03/22/rust-pattern-match</id><content type="html" xml:base="https://andelf.github.io/blog/2016/03/22/rust-pattern-match/"><![CDATA[<h1 id="模式匹配">模式匹配</h1>

<p>汉语字典中对“模式”的解释是：事物的标准样式。在计算机科学中，它指特定类型的数据（往往是序列或是树形结构）满足某一特定结构或格式。“匹配”本身是指一个判断寻找过程。最早的模式匹配用于文本编辑器中的正则字符串搜索，之后才作为编程语言特性。</p>

<h2 id="模式匹配基础">模式匹配基础</h2>

<p>模式匹配在计算机科学领域有两层意思。其一，可以特指字符串匹配算法，例如为人熟知的 KMP 字符串匹配算法、命令行工具 grep 等。
其二，特指在一些语言中作为一种以结构的方式处理数据的工具，此时的匹配过程往往是树形匹配，与此相伴的往往还有一个特性叫 guard（守卫）。</p>

<p>Rust 中模式匹配随处可见，例如在<code class="language-plaintext highlighter-rouge">let</code>变量绑定语句、<code class="language-plaintext highlighter-rouge">match</code>匹配语句中等。利用好模式匹配这一特性可以使代码更简洁易懂。<code class="language-plaintext highlighter-rouge">Rust</code>支持模式匹配中的变量绑定、结构体/元组解构、守卫条件判断、数值范围匹配等特性。</p>

<h3 id="原始匹配">原始匹配</h3>

<p><code class="language-plaintext highlighter-rouge">match</code> 语句中可以直接匹配字面常量，下划线<code class="language-plaintext highlighter-rouge">_</code>匹配任意情形。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"one"</span><span class="p">),</span>
    <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"two"</span><span class="p">),</span>
    <span class="mi">3</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"three"</span><span class="p">),</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"anything"</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以上代码会打印出<code class="language-plaintext highlighter-rouge">one</code>。</p>

<h3 id="结构匹配">结构匹配</h3>

<p><code class="language-plaintext highlighter-rouge">match</code> 用于匹配一个表达式的值，寻找满足条件的子分支(<code class="language-plaintext highlighter-rouge">arm</code>)并执行。每个子分支包含三部分：一系列模式、可选的守卫条件以及主体代码块。</p>

<h3 id="多个模式">多个模式</h3>

<p>每个子分支可以是多个模式，通过 <code class="language-plaintext highlighter-rouge">|</code> 符号分割：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="p">|</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"one or two"</span><span class="p">),</span>
    <span class="mi">3</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"three"</span><span class="p">),</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"anything"</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以上代码打印出<code class="language-plaintext highlighter-rouge">one or two</code>。</p>

<h3 id="守卫条件">守卫条件</h3>

<p>通过<code class="language-plaintext highlighter-rouge">if</code>引入子分支的守卫条件：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">OptionalInt</span> <span class="p">{</span>
    <span class="nf">Value</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
    <span class="n">Missing</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">OptionalInt</span><span class="p">::</span><span class="nf">Value</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
    <span class="nn">OptionalInt</span><span class="p">::</span><span class="nf">Value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got an int bigger than five!"</span><span class="p">),</span>
    <span class="nn">OptionalInt</span><span class="p">::</span><span class="nf">Value</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got an int!"</span><span class="p">),</span>
    <span class="nn">OptionalInt</span><span class="p">::</span><span class="n">Missing</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"No such luck."</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="模式匹配进阶">模式匹配进阶</h2>

<p>其实进阶，不如直接从<code class="language-plaintext highlighter-rouge">libsyntax</code>源码看看到底模式匹配是如何实现。<code class="language-plaintext highlighter-rouge">syntax::ast::Pat</code>。</p>

<p>从AST源码中寻找语法要素屋外户两个要点，其一，语法要素是如何表达为对应AST的；其二，对应AST在哪些父AST中出现。</p>

<p>Rust中使用<code class="language-plaintext highlighter-rouge">syntax::ast::Pat</code>枚举来表示一个模式匹配。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Pat</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">id</span><span class="p">:</span> <span class="n">NodeId</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">node</span><span class="p">:</span> <span class="n">PatKind</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">PatKind</span> <span class="p">{</span>
    <span class="cd">/// Represents a wildcard pattern (`_`)</span>
    <span class="cd">/// 表示通配，下划线</span>
    <span class="n">Wild</span><span class="p">,</span>

    <span class="cd">/// A `PatKind::Ident` may either be a new bound variable,</span>
    <span class="cd">/// or a unit struct/variant pattern, or a const pattern (in the last two cases</span>
    <span class="cd">/// the third field must be `None`).</span>
    <span class="cd">///</span>
    <span class="cd">/// In the unit or const pattern case, the parser can't determine</span>
    <span class="cd">/// which it is. The resolver determines this, and</span>
    <span class="cd">/// records this pattern's `NodeId` in an auxiliary</span>
    <span class="cd">/// set (of "PatIdents that refer to unit patterns or constants").</span>
    <span class="nf">Ident</span><span class="p">(</span><span class="n">BindingMode</span><span class="p">,</span> <span class="n">SpannedIdent</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">),</span>

    <span class="cd">/// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.</span>
    <span class="cd">/// The `bool` is `true` in the presence of a `..`.</span>
    <span class="nf">Struct</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Spanned</span><span class="o">&lt;</span><span class="n">FieldPat</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span>

    <span class="cd">/// A tuple struct/variant pattern `Variant(x, y, z)`.</span>
    <span class="cd">/// "None" means a `Variant(..)` pattern where we don't bind the fields to names.</span>
    <span class="nf">TupleStruct</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;&gt;</span><span class="p">),</span>

    <span class="cd">/// A path pattern.</span>
    <span class="cd">/// Such pattern can be resolved to a unit struct/variant or a constant.</span>
    <span class="nf">Path</span><span class="p">(</span><span class="n">Path</span><span class="p">),</span>

    <span class="cd">/// An associated const named using the qualified path `&lt;T&gt;::CONST` or</span>
    <span class="cd">/// `&lt;T as Trait&gt;::CONST`. Associated consts from inherent impls can be</span>
    <span class="cd">/// referred to as simply `T::CONST`, in which case they will end up as</span>
    <span class="cd">/// PatKind::Path, and the resolver will have to sort that out.</span>
    <span class="nf">QPath</span><span class="p">(</span><span class="n">QSelf</span><span class="p">,</span> <span class="n">Path</span><span class="p">),</span>

    <span class="cd">/// A tuple pattern `(a, b)`</span>
    <span class="nf">Tup</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="cd">/// A `box` pattern</span>
    <span class="nf">Box</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="cd">/// A reference pattern, e.g. `&amp;mut (a, b)`</span>
    <span class="nf">Ref</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Mutability</span><span class="p">),</span>
    <span class="cd">/// A literal</span>
    <span class="nf">Lit</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="cd">/// A range pattern, e.g. `1...2`</span>
    <span class="nf">Range</span><span class="p">(</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="cd">/// `[a, b, ..i, y, z]` is represented as:</span>
    <span class="cd">///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`</span>
    <span class="nf">Vec</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&lt;</span><span class="n">Pat</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="cd">/// A macro pattern; pre-expansion</span>
    <span class="nf">Mac</span><span class="p">(</span><span class="n">Mac</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以上AST定义，即说明，到底什么被认为是一个“模式”。</p>

<p>以下介绍<code class="language-plaintext highlighter-rouge">Pat</code>在哪些AST中出现。</p>

<h3 id="全局-item">全局 Item</h3>

<p>全局 Item 中，使用模式匹配的均为函数参数。</p>

<h4 id="itemkindfn">ItemKind::Fn</h4>

<p><code class="language-plaintext highlighter-rouge">Fn</code> 全局函数 -&gt; <code class="language-plaintext highlighter-rouge">FnDecl</code> 函数声明 -&gt; <code class="language-plaintext highlighter-rouge">[Arg]</code> 函数头参数声明。</p>

<h4 id="itemkindtrait">ItemKind::Trait</h4>

<p><code class="language-plaintext highlighter-rouge">Trait</code> -&gt; <code class="language-plaintext highlighter-rouge">[TraitItem]</code> -&gt; <code class="language-plaintext highlighter-rouge">TraitItemKind::Method</code> -&gt; <code class="language-plaintext highlighter-rouge">MethodSig</code> -&gt; <code class="language-plaintext highlighter-rouge">FnDecl</code> 方法声明，同上。</p>

<h4 id="itemkindimpl">ItemKind::Impl</h4>

<p><code class="language-plaintext highlighter-rouge">Impl</code> -&gt; <code class="language-plaintext highlighter-rouge">[ImplItem]</code> -&gt; <code class="language-plaintext highlighter-rouge">ImplItemKind::Method</code> -&gt; <code class="language-plaintext highlighter-rouge">MethodSig</code> -&gt; <code class="language-plaintext highlighter-rouge">FnDecl</code>。</p>

<h3 id="aststmt-语句">ast::Stmt 语句</h3>

<h4 id="stmtkinddecl">StmtKind::Decl</h4>

<p><code class="language-plaintext highlighter-rouge">Decl</code> -&gt; <code class="language-plaintext highlighter-rouge">DeclKind::Local</code>。</p>

<p>即 <code class="language-plaintext highlighter-rouge">let</code> 语句 <code class="language-plaintext highlighter-rouge">let &lt;pat&gt;:&lt;ty&gt; = &lt;expr&gt;;</code>。</p>

<h4 id="stmtkindexpr-表达式">StmtKind::Expr 表达式</h4>

<p>见下。</p>

<h3 id="astexpr">ast::Expr</h3>

<p>除<code class="language-plaintext highlighter-rouge">match</code>外，<code class="language-plaintext highlighter-rouge">if let</code>、<code class="language-plaintext highlighter-rouge">while let</code>、<code class="language-plaintext highlighter-rouge">for</code>控制语句支持同时进行模式匹配。具体实现是一种<code class="language-plaintext highlighter-rouge">desugared</code>过程，即，去语法糖化。</p>

<p>同时类似于函数定义，闭包参数也支持模式匹配。</p>

<h4 id="if-let">if let</h4>

<p><code class="language-plaintext highlighter-rouge">IfLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;P&lt;Expr&gt;&gt;)</code></p>

<p><code class="language-plaintext highlighter-rouge">if let pat = expr { block } else { expr }</code></p>

<p>This is desugared to a match expression.</p>

<h4 id="while-let">while let</h4>

<p><code class="language-plaintext highlighter-rouge">WhileLet(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code class="language-plaintext highlighter-rouge">'label: while let pat = expr { block }</code></p>

<h4 id="for">for</h4>

<p><code class="language-plaintext highlighter-rouge">ForLoop(P&lt;Pat&gt;, P&lt;Expr&gt;, P&lt;Block&gt;, Option&lt;Ident&gt;)</code></p>

<p><code class="language-plaintext highlighter-rouge">'label: for pat in expr { block }</code></p>

<h4 id="match">match</h4>

<p><code class="language-plaintext highlighter-rouge">Match(P&lt;Expr&gt;, Vec&lt;Arm&gt;)</code></p>

<p><code class="language-plaintext highlighter-rouge">match</code> 语句，在 <code class="language-plaintext highlighter-rouge">Arm</code> 中出现，其中 <code class="language-plaintext highlighter-rouge">Arm</code> 定义为</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pub struct Arm {
    pub attrs: Vec&lt;Attribute&gt;,
    pub pats: Vec&lt;P&lt;Pat&gt;&gt;,
    pub guard: Option&lt;P&lt;Expr&gt;&gt;,
    pub body: P&lt;Expr&gt;,
}
</code></pre></div></div>

<h4 id="闭包">闭包</h4>

<p><code class="language-plaintext highlighter-rouge">Closure(CaptureBy, P&lt;FnDecl&gt;, P&lt;Block&gt;)</code></p>

<p>闭包，例如 <code class="language-plaintext highlighter-rouge">move |a, b, c| {a + b + c}</code>。</p>

<h2 id="相关-feature-gate">相关 feature gate</h2>

<p><code class="language-plaintext highlighter-rouge">advanced_slice_patterns</code> - See the match expressions section for discussion; the exact semantics of slice patterns are subject to change, so some types are still unstable.</p>

<p><code class="language-plaintext highlighter-rouge">slice_patterns</code> - OK, actually, slice patterns are just scary and completely unstable.</p>

<p><code class="language-plaintext highlighter-rouge">box_patterns</code> - Allows box patterns, the exact semantics of which is subject to change.</p>

<h2 id="参考">参考</h2>

<p>https://doc.rust-lang.org/book/patterns.html</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="rust" /><summary type="html"><![CDATA[模式匹配]]></summary></entry><entry><title type="html">广州实时工具App逆向</title><link href="https://andelf.github.io/blog/2015/06/18/guangzhou-realtime-bus/" rel="alternate" type="text/html" title="广州实时工具App逆向" /><published>2015-06-18T09:39:06+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2015/06/18/guangzhou-realtime-bus</id><content type="html" xml:base="https://andelf.github.io/blog/2015/06/18/guangzhou-realtime-bus/"><![CDATA[<p>简记。用了 IDA Pro，安卓手机的 Remote 客户端。以及 apktool 等。</p>

<p><a href="https://github.com/andelf/guangzhou-realtime-bus">Github: guangzhou-realtime-bus</a></p>

<ul>
  <li>生成 e=3 的 1024 位 RSA 密钥对</li>
  <li>公钥串用查表加密(byte 映射)，然后 base64 封装发送给服务器</li>
  <li>服务器返回一串用公钥加密过的数据</li>
  <li>用本地私钥解密后，该数据包含未知96字节的一段数据和 DES Key</li>
  <li>从此通信用 DES 加密</li>
</ul>

<p>base64封装过程：先打包字符串长度，然后是原始字符串（JSON），然后是<code class="language-plaintext highlighter-rouge">0x10</code>(md5字符串长度)，
然后是 md5 校验值。整个二进制字符串用 base64 转码，POST 给服务器。</p>

<p>具体的登录注册过程还需要进一步抓包分析，不过暂时兴趣不在这里了。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="crack" /><summary type="html"><![CDATA[简记。用了 IDA Pro，安卓手机的 Remote 客户端。以及 apktool 等。]]></summary></entry><entry><title type="html">北京实时公交分析</title><link href="https://andelf.github.io/blog/2015/06/01/beijing-realtime-bus/" rel="alternate" type="text/html" title="北京实时公交分析" /><published>2015-06-01T05:17:50+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2015/06/01/beijing-realtime-bus</id><content type="html" xml:base="https://andelf.github.io/blog/2015/06/01/beijing-realtime-bus/"><![CDATA[<p>361 条线路，705条单向线路。 aibang 负责数据服务。</p>

<p>每辆车，每15秒更新一次 GPS，</p>

<p>整理成为 Repo <a href="https://github.com/andelf/beijing-realtime-bus">andelf/beijing-realtime-bus</a>.</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><summary type="html"><![CDATA[361 条线路，705条单向线路。 aibang 负责数据服务。]]></summary></entry><entry><title type="html">为第三方扩展创建 Swift 模块</title><link href="https://andelf.github.io/blog/2015/01/23/swift-3rd-library-install-as-swift-modules/" rel="alternate" type="text/html" title="为第三方扩展创建 Swift 模块" /><published>2015-01-23T15:21:00+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2015/01/23/swift-3rd-library-install-as-swift-modules</id><content type="html" xml:base="https://andelf.github.io/blog/2015/01/23/swift-3rd-library-install-as-swift-modules/"><![CDATA[<p>本文提出了一种将第三方扩展引入到 Swift 标准库的方法。</p>

<p>以 Alamofire 为例，</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd Path-To-Alamofire-Src-Dir
mkdir -p 32 64

# 创建动态链接库，及对应 Swift 模块，32/64版本
xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphoneos) Alamofire.swift -target arm64-apple-ios7.1 -target-cpu cyclone -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib

mv Alamofire.swiftdoc Alamofire.swiftmodule libswiftAlamofire.dylib ./64

xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphoneos) Alamofire.swift -target armv7-apple-ios7.1 -target-cpu cyclone -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib

mv Alamofire.swiftdoc Alamofire.swiftmodule libswiftAlamofire.dylib ./64

# 创建 universal lib
lipo -create ./{32,64}/libswiftAlamofire.dylib  -output ./libswiftAlamofire.dylib

# 创建模拟器用 lib
xcrun swiftc -sdk $(xcrun --show-sdk-path --sdk iphonesimulator) Alamofire.swift -target i386-apple-ios7.1 -target-cpu yonah -emit-library -emit-module -module-name Alamofire -v -o libswiftAlamofire.dylib -module-link-name swiftAlamofire -Xlinker -install_name -Xlinker @rpath/libswiftAlamofire.dylib
</code></pre></div></div>

<p>其他相关 target</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-target armv7-apple-ios7.1 -target-cpu cortex-a8
-target arm64-apple-ios7.1 -target-cpu cyclone
-target i386-apple-ios7.1 -target-cpu yonah
-target x86_64-apple-ios7.1 -target-cpu core2
</code></pre></div></div>

<p>其实你了解 Swift 模块结构的化，应该回想到，将第三方模块创建为 swiftmodule 应该是最靠谱的选择。不过实际操作发现，
编译命令无法很方便地调整，主要是因为 xcodebuild 系统，和编译命令不知道怎么导出。也是略纠结。</p>

<p>实际上，如果使用 Carthage 的话，即把第三方扩展作为 Framework 引入，会导致无法支持 iOS 7，但是 Swift 本身是支持 iOS 7 的，
在编译命令和生成的文件中检查发现，对于 iOS 7，Swift 使用了纯静态模块编译的方法。所以其实我们引入第三方扩展的时候也可以这样做。</p>

<p>以下是静态编译所需命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) SwiftyJSON.swift -c -parse-as-library -module-name SwiftyJSON -v -o SwiftyJSON.o

ar rvs libswiftSwiftyJSON.a SwiftyJSON.o
</code></pre></div></div>

<p>如何使用？</p>

<p>将编译结果扔到：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift_static
</code></pre></div></div>

<p>下对应目录。</p>

<p>然后在 Xcode 里，直接 import。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[本文提出了一种将第三方扩展引入到 Swift 标准库的方法。]]></summary></entry><entry><title type="html">Swift beta3 Changes ( Swift 在 beta3 中的变化）</title><link href="https://andelf.github.io/blog/2014/07/08/swift-beta3-changes/" rel="alternate" type="text/html" title="Swift beta3 Changes ( Swift 在 beta3 中的变化）" /><published>2014-07-08T09:22:11+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/07/08/swift-beta3-changes</id><content type="html" xml:base="https://andelf.github.io/blog/2014/07/08/swift-beta3-changes/"><![CDATA[<p>准确说是 beta2 <code class="language-plaintext highlighter-rouge">Swift version 1.0 (swift-600.0.34.4.8)</code> 到 beta3 <code class="language-plaintext highlighter-rouge">Swift version 1.0 (swift-600.0.38.7)</code> 的变化。</p>

<p>对了，补充下。 beta1 <code class="language-plaintext highlighter-rouge">Swift version 1.0 (swift-600.0.34.4.5)</code> 到 beta2 几乎没有什么变化。</p>

<h2 id="语法">语法</h2>

<p><code class="language-plaintext highlighter-rouge">nil</code> 成为关键字。</p>

<p><code class="language-plaintext highlighter-rouge">[KeyType : ValueType]</code> 可以表示字典类型 <code class="language-plaintext highlighter-rouge">Dictionary&lt;KeyType, ValueType&gt;</code>。</p>

<p><code class="language-plaintext highlighter-rouge">[Type]</code> 用于表示原 Array 类型 <code class="language-plaintext highlighter-rouge">Type[]</code>，等价 <code class="language-plaintext highlighter-rouge">Array&lt;T&gt;</code>，原用法会导致警告。</p>

<p><del>增加 @noinline 属性</del></p>

<p><code class="language-plaintext highlighter-rouge">..</code> 运算符改为 <code class="language-plaintext highlighter-rouge">..&lt;</code>，不容易和 <code class="language-plaintext highlighter-rouge">...</code> 混淆。</p>

<h2 id="函数类型">函数、类型</h2>

<p>原 <code class="language-plaintext highlighter-rouge">sort()</code> 改名为 <code class="language-plaintext highlighter-rouge">sorted()</code>。新增 <code class="language-plaintext highlighter-rouge">sort()</code> 函数，参数为 <code class="language-plaintext highlighter-rouge">inout</code>。</p>

<p>Index 类型中的 <code class="language-plaintext highlighter-rouge">.succ()</code> 变为 <code class="language-plaintext highlighter-rouge">.successor()</code>、 <code class="language-plaintext highlighter-rouge">.pred()</code> 变为 <code class="language-plaintext highlighter-rouge">.predecessor()</code>。</p>

<h2 id="cobjc-交互变化">C/ObjC 交互变化</h2>

<p>增加 <code class="language-plaintext highlighter-rouge">UnsafeMutableArray&lt;T&gt;</code> 类型。</p>

<p>增加 <code class="language-plaintext highlighter-rouge">CFunctionPointer&lt;T&gt;</code> 类型。</p>

<p>删除 <code class="language-plaintext highlighter-rouge">CConstVoidPointer</code>、 <code class="language-plaintext highlighter-rouge">CMutableVoidPointer</code>。替换为 <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;()&gt;</code>、<code class="language-plaintext highlighter-rouge">ConstUnsafePointer&lt;Int32&gt;</code>。</p>

<p>删除 <code class="language-plaintext highlighter-rouge">CConstPointer&lt;T&gt;</code>、<code class="language-plaintext highlighter-rouge">CMutablePointer&lt;T&gt;</code>。替换为 <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;T&gt;</code>、<code class="language-plaintext highlighter-rouge">ConstUnsafePointer&lt;T&gt;</code>。</p>

<p>这么一来指针操作简单了好多。原有会出现 <code class="language-plaintext highlighter-rouge">COpaquePointer</code> 的不合理情况，也都对应到适合的类型。</p>

<p><code class="language-plaintext highlighter-rouge">CString</code> 可以从 <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;UInt8&gt;</code> 和 <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;CChar&gt;</code> 两种类型构造获得，之前只支持 <code class="language-plaintext highlighter-rouge">UInt8</code>。</p>

<p>module.map 中头文件声明转换为 Swift 声明不再使用 C 兼容类型，直接使用 Swift 相应类型。原有 <code class="language-plaintext highlighter-rouge">CInt</code>，现在成为 <code class="language-plaintext highlighter-rouge">Int32</code>。</p>

<p>结构体会自动添加构造函数 <code class="language-plaintext highlighter-rouge">init(field1:field2:...)</code> 这样。</p>

<h3 id="nil">nil</h3>

<p>去掉了 <code class="language-plaintext highlighter-rouge">NilType</code>，增加了 <code class="language-plaintext highlighter-rouge">NilLiteralConvertible</code>， <code class="language-plaintext highlighter-rouge">nil</code> 成为关键字。可以认为是 nil 常量。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol NilLiteralConvertible {
  class func convertFromNilLiteral() -&gt; Self
}
</code></pre></div></div>

<p>除了 Optional 、上面所提到的指针类型外，<code class="language-plaintext highlighter-rouge">RawOptionSet</code> 也实现了该协议。</p>

<h3 id="array">Array</h3>

<p>去掉了 <code class="language-plaintext highlighter-rouge">.copy()</code>、<code class="language-plaintext highlighter-rouge">unshare()</code> 方法。</p>

<p>增加了以下方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func makeUnique(inout buffer: ArrayBuffer&lt;T&gt;, e: T, index: Int)
func sorted(isOrderedBefore: (T, T) -&gt; Bool) -&gt; Array&lt;T&gt;
</code></pre></div></div>

<p>看起来 <code class="language-plaintext highlighter-rouge">Array</code> 对底层容器的引用有了更好的控制 <code class="language-plaintext highlighter-rouge">ArrayBufferType</code> 增加了判断方法 <code class="language-plaintext highlighter-rouge">func isMutableAndUniquelyReferenced() -&gt; Bool</code>。</p>

<p>Array 目前可以认为是真正的值类型。</p>

<h3 id="指针">指针</h3>

<h4 id="增加了-_pointer-protocol">增加了 <code class="language-plaintext highlighter-rouge">_Pointer</code> protocol</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">protocol</span> <span class="nc">_Pointer</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">RawPointer</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">init</span><span class="o">(</span><span class="k">_</span> <span class="kt">value:</span> <span class="kt">RawPointer</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>表示一个类型可以对应到原生指针。</p>

<p>同时成为内部桥接类型，编译器内部在转换时使用它（取出 RawPointer, 构造具体指针类型）。</p>

<h2 id="模块">模块</h2>

<p>增加了  StdlibUnittest 模块。 <a href="https://github.com/andelf/Defines-Swift/blob/79ed8d40659e4d038f41e3c30b4b3358106bd50a/StdlibUnittest.swift">声明代码</a>。单元测试终于有了。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[准确说是 beta2 Swift version 1.0 (swift-600.0.34.4.8) 到 beta3 Swift version 1.0 (swift-600.0.38.7) 的变化。]]></summary></entry><entry><title type="html">Use Swift Dynamic Framework （如何科学地引用第三方 Swift 库)</title><link href="https://andelf.github.io/blog/2014/07/07/use-swift-dynamic-library/" rel="alternate" type="text/html" title="Use Swift Dynamic Framework （如何科学地引用第三方 Swift 库)" /><published>2014-07-07T04:09:54+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/07/07/use-swift-dynamic-library</id><content type="html" xml:base="https://andelf.github.io/blog/2014/07/07/use-swift-dynamic-library/"><![CDATA[<p>排名 16 了。啧啧。你看才刚出一个月。</p>

<p>目前已经有了很多非常棒的 Swift 第三方库， JSON 处理啊、 HTTP 访问啊、 UIView 插件啊等等。</p>

<p>如何科学地引用这些第三方库呢？</p>

<h2 id="现状">现状</h2>

<p>CocoaPods 由于完全使用静态链接解决方法，过度依赖 Objective-C ，目前应该是官方 repo 有提到是 <code class="language-plaintext highlighter-rouge">-Xlinker</code> error , 这个问题之前我也遇到过，无解。除非手工执行 <code class="language-plaintext highlighter-rouge">ar</code> 不用 <code class="language-plaintext highlighter-rouge">ld</code> 和 <code class="language-plaintext highlighter-rouge">libtool</code>。</p>

<p>小伙伴有用子目录的方法引用代码，貌似不错，还有就是直接用 <code class="language-plaintext highlighter-rouge">git submodule</code>，看起来维护性也可以。</p>

<h2 id="简单解决方案">简单解决方案</h2>

<p>一个良好的第三方库应该实现为 Cocoa Touch Framework (实际内容为 Header + 动态链接库)。而不是直接把 Swift 代码 Copy 过来放入自己的项目。这里以一个简单项目为例，介绍如何科学使用。</p>

<h3 id="目标描述">目标描述</h3>

<p>用 Swift 创建一个 Demo ，使用 SwiftyJSON 和 LTMorphingLabel 库。</p>

<p>项目的名字叫 DemoApp 。</p>

<h4 id="创建-workspace">创建 Workspace</h4>

<p>创建一个 Workspace ，名字随意，位置能找到就好。这个 Workspace 主要用来管理我们的项目及其依赖的第三方库。</p>

<h4 id="创建-demoapp">创建 DemoApp</h4>

<p>在 Workspace 创建一个 App ，因为是测试所以我选了 Single View Application 。</p>

<h4 id="引入-swiftyjson">引入 SwiftyJSON</h4>

<p>SwiftyJSON 是一个 Cocoa Touch Framework ，可以直接使用， <code class="language-plaintext highlighter-rouge">git clone</code> 后，添加项目到 Workspace 即可。</p>

<p>尝试操作发现。。最容易最不会出错的方法就是直接从 Finder 里把 <code class="language-plaintext highlighter-rouge">.xcodeproj</code> 文件拖动到 Workspace 。</p>

<h4 id="引入-ltmorphinglabel">引入 LTMorphingLabel</h4>

<p>LTMorphingLabel 是一个 App Deme 式项目。其中 Label View 的实现在一个子目录中。可以采用创建 Cocoa
Touch Framework 的方法来引入这几个文件。</p>

<p>当然也可以直接把目录拖到我们的 DemoApp 里，不过太原始粗暴了。</p>

<h4 id="为-app-添加依赖">为 App 添加依赖</h4>

<p>在 DemoApp 的 Genral 选项卡中，添加 Linked Frameworks and Libraries 。选择  Workspace 中 SwiftyJSON 和
LTMorphingLabel 两个 <code class="language-plaintext highlighter-rouge">.framework</code> 。</p>

<p>如果是直接选择来自其他项目的 <code class="language-plaintext highlighter-rouge">.framework</code> 而不是同一 Workspace ，那么这里也许还要同时加入 <code class="language-plaintext highlighter-rouge">Embedded Binaries</code>。</p>

<h4 id="使用">使用</h4>

<p>添加好依赖后，就可以在 DemoApp 项目代码中 <code class="language-plaintext highlighter-rouge">import SwiftyJSON</code> 或者 <code class="language-plaintext highlighter-rouge">import LTMorphingLabel</code> 来使用对应的库。同时还可以用 Command + 鼠标点击的方法查看声明代码。</p>

<h4 id="除错">除错</h4>

<p>比较坑爹的是，实际上按照以上方法， <code class="language-plaintext highlighter-rouge">LTMorphingLabel</code> 并不能正常使用，查看报错信息发现是自动生成的 <code class="language-plaintext highlighter-rouge">LTMorphingLabel-Swift.h</code> 有处语法无法被识别，编辑器找到 <code class="language-plaintext highlighter-rouge">.h</code> 文件，注释掉这行诡异代码即可。</p>

<p>看起来目前的 Bridge Header 和 -emit-objc-header 实现还是有问题的。小伙伴一定要淡定。</p>

<h2 id="对于非-workspace">对于非 Workspace</h2>

<p>如果不喜欢使用 Workspace ，也可以将第三方库的编译结果，一个 <code class="language-plaintext highlighter-rouge">.framework</code> 目录拖到项目文件里，然后添加 <code class="language-plaintext highlighter-rouge">Embedded Binaries</code>。</p>

<h2 id="评论">评论</h2>

<p>创建 Cocoa Touch Framework 选项中，可以使用 Swift 代码，此时编译结果（默认）会包含 <code class="language-plaintext highlighter-rouge">module.modulemap</code> 文件，
之前有介绍过它的作用，通过它， Swift 可以使用第三方模块。参考 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a> 。</p>

<p>实际上这个解决方案绕了一大圈，通过 Swift 文件导出 <code class="language-plaintext highlighter-rouge">ProjName-Swift.h</code>、然后 <code class="language-plaintext highlighter-rouge">module.modulemap</code> 模块描述文件引入、然后再由 Swift 导入。</p>

<p>其实 <code class="language-plaintext highlighter-rouge">.framework</code> 同时也包含了 <code class="language-plaintext highlighter-rouge">ProjName.swiftmodule/[ARCH].swiftmodule</code> 不过看起来没有使用到，而且默认在 IDE 下也不支持 Swift 从 <code class="language-plaintext highlighter-rouge">.swiftmodule</code> 文件导入，比较坑。希望以后版本能加入支持。</p>

<p><code class="language-plaintext highlighter-rouge">.framework</code> 包含了所有 Swift 标准库的动态链接库，小伙伴可能会以为这会导致编译后的 App 变大。其实大可放心，任何 Swift 语言的 App 都会包含这些动态链接库，而且只会包含一个副本。此方法对 App 最终的大小几乎无影响。</p>

<p>注： 个人测试了下，发现这个 <code class="language-plaintext highlighter-rouge">.swiftmodule</code> 是可以通过其他方法使用的，绕过 <code class="language-plaintext highlighter-rouge">module.modulemap</code>，应该是更佳的解决方案，但是需要控制命令行参数。</p>

<p>至于静态链接库，过时了。抛弃吧。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont/">Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）</a></li>
</ul>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[排名 16 了。啧啧。你看才刚出一个月。]]></summary></entry><entry><title type="html">Swift Undocumented Grammar （Swift 黑语法）</title><link href="https://andelf.github.io/blog/2014/07/03/swift-undocumented-grammar/" rel="alternate" type="text/html" title="Swift Undocumented Grammar （Swift 黑语法）" /><published>2014-07-03T19:05:11+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/07/03/swift-undocumented-grammar</id><content type="html" xml:base="https://andelf.github.io/blog/2014/07/03/swift-undocumented-grammar/"><![CDATA[<p>本文介绍 Swift 的 Undocumented 语法特性。</p>

<p>电子书上介绍的 default function parameter 这里都不好意思拿出来写。</p>

<p>咳咳。持续更新。</p>

<h2 id="用关键字当变量名">用关键字当变量名</h2>

<p>Keywards as variable name.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// escaped variable name</span>
<span class="n">let</span> <span class="n">`let`</span> <span class="k">=</span> <span class="mi">1000</span>
<span class="nf">dump</span><span class="o">(</span><span class="n">`let`</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="err">"</span><span class="kt">variable</span> <span class="kt">named</span> <span class="kt">let</span><span class="err">"</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="new-关键字"><code class="language-plaintext highlighter-rouge">new</code> 关键字</h2>

<p>The <code class="language-plaintext highlighter-rouge">new</code> keyword.</p>

<p>快速初始化数组。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">an_array_with_100_zero</span> <span class="k">=</span> <span class="nf">new</span><span class="o">(</span><span class="nc">Int</span><span class="o">)[</span><span class="err">100</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="protocol-type">protocol type</h2>

<p>use <code class="language-plaintext highlighter-rouge">protocol&lt;Protocol1, Protocol2, ...&gt;</code> as a type.</p>

<h2 id="how-i-find-it">How I find it?</h2>

<p>瞎试出来的。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[本文介绍 Swift 的 Undocumented 语法特性。]]></summary></entry><entry><title type="html">Cocoa Extensions in Swift ( Cocoa 在 Swift 中所添加的扩展）</title><link href="https://andelf.github.io/blog/2014/07/03/cocoa-in-swift/" rel="alternate" type="text/html" title="Cocoa Extensions in Swift ( Cocoa 在 Swift 中所添加的扩展）" /><published>2014-07-03T17:05:55+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/07/03/cocoa-in-swift</id><content type="html" xml:base="https://andelf.github.io/blog/2014/07/03/cocoa-in-swift/"><![CDATA[<p>最近看到了 <a href="https://github.com/raywenderlich/swift-style-guide">Swift Style Guide</a> 个人觉得内容太少，
Swift 本身作为一门庞大的语言，语素众多。本文就 Swift 本身对 Cocoa 的扩展，看看对日常 Cocoa 风格有什么影响。</p>

<p>Swift 本身的特性，导致它在一些用法上和 Objective-C 上有所不同，比如 ObjC 的 struct 单纯和 C 的一样，但是在 Swift
中的 struct 则要强大得多。</p>

<p>个人认为比如 <code class="language-plaintext highlighter-rouge">CGPointMake</code> 这样的函数，理论上不应该出现在 Swift 代码中。而是应该用 <code class="language-plaintext highlighter-rouge">CGPoint(x:y:)</code>。</p>

<p>本文可以作为参考手册使用。</p>

<h2 id="标准库扩展">标准库扩展</h2>

<h3 id="objectivec">ObjectiveC</h3>

<p>值得注意的是 Selector 相关方法，实现了 <code class="language-plaintext highlighter-rouge">StringLiteralConvertible</code>。也可以从 <code class="language-plaintext highlighter-rouge">nil</code> 获得。</p>

<h3 id="foundation">Foundation</h3>

<p>这里忽略之前介绍过的 <code class="language-plaintext highlighter-rouge">_BridgedToObjectiveC</code> 相关内容。</p>

<h4 id="协议附加">协议附加</h4>

<p>Sequence 协议</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSMutableArray NSSet NSArray NSMutableDictionary NSMutableSet NSDictionary
</code></pre></div></div>

<p>所有以上这些类型都可以通过 for-in 操作。</p>

<p>*LiteralConvertible</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSNumber NSString NSArray NSDictionary
</code></pre></div></div>

<h4 id="隐式类型转换">隐式类型转换</h4>

<p>CF 几乎都对应到了 NS 类型。这里略去</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">NilType</code> -&gt; <code class="language-plaintext highlighter-rouge">NSZone</code></li>
  <li><code class="language-plaintext highlighter-rouge">Dictionary&lt;KeyType: Hashable, ValueType&gt;</code> -&gt; <code class="language-plaintext highlighter-rouge">NSDictionary</code></li>
  <li><code class="language-plaintext highlighter-rouge">NSDictionary</code> -&gt; <code class="language-plaintext highlighter-rouge">Dictionary&lt;NSObject, AnyObject&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">String</code> &lt;-&gt; <code class="language-plaintext highlighter-rouge">NSString</code></li>
  <li><code class="language-plaintext highlighter-rouge">NSArray</code> -&gt; <code class="language-plaintext highlighter-rouge">AnyObject[]</code></li>
  <li><code class="language-plaintext highlighter-rouge">A[]</code> -&gt; <code class="language-plaintext highlighter-rouge">NSArray</code></li>
  <li><code class="language-plaintext highlighter-rouge">Float Double Int UInt Bool</code> -&gt; <code class="language-plaintext highlighter-rouge">NSNumber</code></li>
  <li><code class="language-plaintext highlighter-rouge">NSRange</code> -&gt; <code class="language-plaintext highlighter-rouge">Range&lt;Int&gt;</code> // 比较有意思的一个</li>
</ul>

<h4 id="方法扩展">方法扩展</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// let s = NSSet(objects: 12, 32, 23, 12)</span>
<span class="n">extension</span> <span class="nc">NSSet</span> <span class="o">{</span>
  <span class="n">convenience</span> <span class="nf">init</span><span class="o">(</span><span class="n">objects</span> <span class="n">elements</span><span class="k">:</span> <span class="kt">AnyObject...</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">extension</span> <span class="nc">NSOrderedSet</span> <span class="o">{</span>
  <span class="n">convenience</span> <span class="nf">init</span><span class="o">(</span><span class="n">objects</span> <span class="n">elements</span><span class="k">:</span> <span class="kt">AnyObject...</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// 这里注意，NSRange 和 Swift Range 对 range 结束的表述方法不同</span>
<span class="c1">// NSRange 保存 range 元素个数</span>
<span class="c1">// Swift Range 保存的是结束元素</span>
<span class="c1">// let r = NSRange(0..20)</span>
<span class="n">extension</span> <span class="nc">NSRange</span> <span class="o">{</span>
  <span class="nf">init</span><span class="o">(</span><span class="k">_</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Range&lt;Int&gt;</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// let prop = NSDictionary(objectsAndKeys: "Feather", "name", "Programming", "hobby")</span>
<span class="n">extension</span> <span class="nc">NSDictionary</span> <span class="o">{</span>
  <span class="n">convenience</span> <span class="nf">init</span><span class="o">(</span><span class="n">objectsAndKeys</span> <span class="n">objects</span><span class="k">:</span> <span class="kt">AnyObject...</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">extension</span> <span class="nc">NSObject</span> <span class="k">:</span> <span class="kt">CVarArg</span> <span class="o">{</span>
  <span class="kt">@objc</span> <span class="kt">func</span> <span class="kt">encode</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">Word</span><span class="o">[]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>字符串的扩展方法非常多。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">static</span> <span class="n">func</span> <span class="nf">availableStringEncodings</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">NSStringEncoding</span><span class="o">[]</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">defaultCStringEncoding</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">NSStringEncoding</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">localizedNameOfStringEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">localizedStringWithFormat</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">_</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">pathWithComponents</span><span class="o">(</span><span class="n">components</span><span class="k">:</span> <span class="kt">String</span><span class="o">[])</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">stringWithContentsOfFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">stringWithContentsOfFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">usedEncoding</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;NSStringEncoding&gt;</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">stringWithContentsOfURL</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">NSURL</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">stringWithContentsOfURL</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">NSURL</span><span class="o">,</span> <span class="n">usedEncoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;NSStringEncoding&gt;</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">stringWithCString</span><span class="o">(</span><span class="n">cString</span><span class="k">:</span> <span class="kt">CString</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">stringWithUTF8String</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">CString</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="n">func</span> <span class="nf">canBeConvertedToEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
  <span class="k">var</span> <span class="n">capitalizedString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">capitalizedStringWithLocale</span><span class="o">(</span><span class="kt">locale:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">String</span>
  <span class="n">func</span> <span class="nf">caseInsensitiveCompare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
  <span class="n">func</span> <span class="nf">commonPrefixWithString</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">compare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">mask</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
  <span class="n">func</span> <span class="nf">completePathIntoString</span><span class="o">(</span><span class="k">_</span> <span class="n">outputName</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String&gt;</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">caseSensitive</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">,</span> <span class="n">matchesIntoArray</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String</span><span class="o">[]&gt;</span> <span class="k">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">filterTypes</span><span class="k">:</span> <span class="kt">String</span><span class="o">[]?</span> <span class="k">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Int</span>
  <span class="n">func</span> <span class="nf">componentsSeparatedByCharactersInSet</span><span class="o">(</span><span class="n">separator</span><span class="k">:</span> <span class="kt">NSCharacterSet</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
  <span class="n">func</span> <span class="nf">componentsSeparatedByString</span><span class="o">(</span><span class="n">separator</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
  <span class="n">func</span> <span class="nf">cStringUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CChar</span><span class="o">[]?</span>
  <span class="n">func</span> <span class="nf">dataUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">allowLossyConversion</span><span class="k">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSData</span>
  <span class="k">var</span> <span class="n">decomposedStringWithCanonicalMapping</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">var</span> <span class="kt">decomposedStringWithCompatibilityMapping:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">enumerateLines</span><span class="o">(</span><span class="kt">body:</span> <span class="o">(</span><span class="kt">line:</span> <span class="kt">String</span><span class="o">,</span> <span class="kt">inout</span> <span class="kt">stop:</span> <span class="kt">Bool</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="o">())</span>
  <span class="n">func</span> <span class="nf">enumerateLinguisticTagsInRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">scheme</span> <span class="n">tagScheme</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">opts</span><span class="k">:</span> <span class="kt">NSLinguisticTaggerOptions</span><span class="o">,</span> <span class="n">orthography</span><span class="k">:</span> <span class="kt">NSOrthography?</span><span class="o">,</span> <span class="k">_</span> <span class="n">body</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nv">String</span><span class="o">.</span><span class="py">Index</span><span class="o">&gt;,</span> <span class="n">inout</span> <span class="nc">Bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">())</span>
  <span class="n">func</span> <span class="nf">enumerateSubstringsInRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">options</span> <span class="n">opts</span><span class="k">:</span> <span class="kt">NSStringEnumerationOptions</span><span class="o">,</span> <span class="k">_</span> <span class="n">body</span><span class="k">:</span> <span class="o">(</span><span class="kt">substring:</span> <span class="kt">String</span><span class="o">,</span> <span class="kt">substringRange:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">enclosingRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">inout</span> <span class="nc">Bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">())</span>
  <span class="k">var</span> <span class="n">fastestEncoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">fileSystemRepresentation</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">CChar</span><span class="o">[]</span>
  <span class="n">func</span> <span class="nf">getBytes</span><span class="o">(</span><span class="n">inout</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">UInt8</span><span class="o">[],</span> <span class="n">maxLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">usedLength</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;Int&gt;</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">options</span><span class="k">:</span> <span class="kt">NSStringEncodingConversionOptions</span><span class="o">,</span> <span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">remainingRange</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;Range&lt;String.Index&gt;&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
  <span class="n">func</span> <span class="nf">getCString</span><span class="o">(</span><span class="n">inout</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">CChar</span><span class="o">[],</span> <span class="n">maxLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
  <span class="n">func</span> <span class="nf">getFileSystemRepresentation</span><span class="o">(</span><span class="n">inout</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">CChar</span><span class="o">[],</span> <span class="n">maxLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
  <span class="n">func</span> <span class="nf">getLineStart</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">contentsEnd</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">forRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span>
  <span class="n">func</span> <span class="nf">getParagraphStart</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">contentsEnd</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">forRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span>
  <span class="k">var</span> <span class="n">hash</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">static</span> <span class="kt">func</span> <span class="kt">stringWithBytes</span><span class="o">(</span><span class="kt">bytes:</span> <span class="kt">UInt8</span><span class="o">[],</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="n">static</span> <span class="n">func</span> <span class="nf">stringWithBytesNoCopy</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">CMutableVoidPointer</span><span class="o">,</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">freeWhenDone</span> <span class="n">flag</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">?</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">utf16CodeUnits</span><span class="k">:</span> <span class="kt">CConstPointer&lt;unichar&gt;</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">utf16CodeUnitsNoCopy</span><span class="k">:</span> <span class="kt">CConstPointer&lt;unichar&gt;</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">freeWhenDone</span> <span class="n">flag</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">)</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">_</span> <span class="nc">_arguments</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg</span><span class="o">[])</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span><span class="o">,</span> <span class="k">_</span> <span class="n">args</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span><span class="o">,</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg</span><span class="o">[])</span>
  <span class="k">var</span> <span class="n">lastPathComponent</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">var</span> <span class="kt">utf16count:</span> <span class="kt">Int</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">lengthOfBytesUsingEncoding</span><span class="o">(</span><span class="kt">encoding:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">Int</span>
  <span class="n">func</span> <span class="nf">lineRangeForRange</span><span class="o">(</span><span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nv">String</span><span class="o">.</span><span class="py">Index</span><span class="o">&gt;</span>
  <span class="n">func</span> <span class="nf">linguisticTagsInRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="n">scheme</span> <span class="n">tagScheme</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">opts</span><span class="k">:</span> <span class="kt">NSLinguisticTaggerOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">orthography</span><span class="k">:</span> <span class="kt">NSOrthography?</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">tokenRanges</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;Range&lt;String.Index&gt;</span><span class="err">[]</span><span class="kt">&gt;</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
  <span class="n">func</span> <span class="nf">localizedCaseInsensitiveCompare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
  <span class="n">func</span> <span class="nf">localizedCompare</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
  <span class="n">func</span> <span class="nf">localizedStandardCompare</span><span class="o">(</span><span class="n">string</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">NSComparisonResult</span>
  <span class="n">func</span> <span class="nf">lowercaseStringWithLocale</span><span class="o">(</span><span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">maximumLengthOfBytesUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Int</span>
  <span class="n">func</span> <span class="nf">paragraphRangeForRange</span><span class="o">(</span><span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nv">String</span><span class="o">.</span><span class="py">Index</span><span class="o">&gt;</span>
  <span class="k">var</span> <span class="n">pathComponents</span><span class="k">:</span> <span class="kt">String</span><span class="o">[]</span> <span class="o">{</span> <span class="n">get</span> <span class="o">}</span>
  <span class="k">var</span> <span class="n">pathExtension</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">var</span> <span class="kt">precomposedStringWithCanonicalMapping:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">var</span> <span class="kt">precomposedStringWithCompatibilityMapping:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">propertyList</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">AnyObject</span>
  <span class="n">func</span> <span class="nf">propertyListFromStringsFileFormat</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Dictionary</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span>
  <span class="n">func</span> <span class="nf">rangeOfCharacterFromSet</span><span class="o">(</span><span class="n">aSet</span><span class="k">:</span> <span class="kt">NSCharacterSet</span><span class="o">,</span> <span class="n">options</span> <span class="n">mask</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span> <span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nv">String</span><span class="o">.</span><span class="py">Index</span><span class="o">&gt;</span>
  <span class="n">func</span> <span class="nf">rangeOfComposedCharacterSequenceAtIndex</span><span class="o">(</span><span class="n">anIndex</span><span class="k">:</span> <span class="kt">String.Index</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nv">String</span><span class="o">.</span><span class="py">Index</span><span class="o">&gt;</span>
  <span class="n">func</span> <span class="nf">rangeOfComposedCharacterSequencesForRange</span><span class="o">(</span><span class="n">range</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nv">String</span><span class="o">.</span><span class="py">Index</span><span class="o">&gt;</span>
  <span class="n">func</span> <span class="nf">rangeOfString</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span> <span class="n">mask</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span> <span class="n">searchRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Range</span><span class="o">&lt;</span><span class="nv">String</span><span class="o">.</span><span class="py">Index</span><span class="o">&gt;</span>
  <span class="k">var</span> <span class="n">smallestEncoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">stringByAbbreviatingWithTildeInPath</span><span class="o">()</span> <span class="kt">-&gt;</span> <span class="kt">String</span>
  <span class="n">func</span> <span class="nf">stringByAddingPercentEncodingWithAllowedCharacters</span><span class="o">(</span><span class="n">allowedCharacters</span><span class="k">:</span> <span class="kt">NSCharacterSet</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByAddingPercentEscapesUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByAppendingFormat</span><span class="o">(</span><span class="n">format</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">_</span> <span class="n">arguments</span><span class="k">:</span> <span class="kt">CVarArg...</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByAppendingPathComponent</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByAppendingPathExtension</span><span class="o">(</span><span class="n">ext</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByAppendingString</span><span class="o">(</span><span class="n">aString</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="k">var</span> <span class="n">stringByDeletingLastPathComponent</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">var</span> <span class="kt">stringByDeletingPathExtension:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">var</span> <span class="kt">stringByExpandingTildeInPath:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">stringByFoldingWithOptions</span><span class="o">(</span><span class="kt">options:</span> <span class="kt">NSStringCompareOptions</span><span class="o">,</span> <span class="kt">locale:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByPaddingToLength</span><span class="o">(</span><span class="n">newLength</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">withString</span> <span class="n">padString</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">startingAtIndex</span> <span class="n">padIndex</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="k">var</span> <span class="n">stringByRemovingPercentEncoding</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">stringByReplacingCharactersInRange</span><span class="o">(</span><span class="kt">range:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">,</span> <span class="kt">withString</span> <span class="kt">replacement:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByReplacingOccurrencesOfString</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">withString</span> <span class="n">replacement</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">options</span><span class="k">:</span> <span class="kt">NSStringCompareOptions</span> <span class="o">=</span> <span class="n">default</span><span class="o">,</span> <span class="n">range</span> <span class="n">searchRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;?</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">stringByReplacingPercentEscapesUsingEncoding</span><span class="o">(</span><span class="n">encoding</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="k">var</span> <span class="n">stringByResolvingSymlinksInPath</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">var</span> <span class="kt">stringByStandardizingPath:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
  <span class="kt">func</span> <span class="kt">stringByTrimmingCharactersInSet</span><span class="o">(</span><span class="kt">set:</span> <span class="kt">NSCharacterSet</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">String</span>
  <span class="n">func</span> <span class="nf">stringsByAppendingPaths</span><span class="o">(</span><span class="n">paths</span><span class="k">:</span> <span class="kt">String</span><span class="o">[])</span> <span class="o">-&gt;</span> <span class="nc">String</span><span class="o">[]</span>
  <span class="n">func</span> <span class="nf">substringFromIndex</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">substringToIndex</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">substringWithRange</span><span class="o">(</span><span class="n">aRange</span><span class="k">:</span> <span class="kt">Range&lt;String.Index&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">uppercaseStringWithLocale</span><span class="o">(</span><span class="n">locale</span><span class="k">:</span> <span class="kt">NSLocale</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">String</span>
  <span class="n">func</span> <span class="nf">writeToFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">atomically</span> <span class="n">useAuxiliaryFile</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
  <span class="n">func</span> <span class="nf">writeToURL</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">NSURL</span><span class="o">,</span> <span class="n">atomically</span> <span class="n">useAuxiliaryFile</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">,</span> <span class="n">encoding</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">NSStringEncoding</span><span class="o">,</span> <span class="n">error</span><span class="k">:</span> <span class="kt">NSErrorPointer</span> <span class="o">=</span> <span class="n">default</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
</code></pre></div></div>

<h3 id="coregraphics">CoreGraphics</h3>

<p>几个常用基本类型都有了 Swift-style 的构造函数。其中 <code class="language-plaintext highlighter-rouge">CGRect</code> 有很多的相关运算都被封装为方法，很不错。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extension</span> <span class="nc">CGPoint</span> <span class="k">:</span> <span class="kt">Equatable</span> <span class="o">{</span>
  <span class="kt">static</span> <span class="kt">var</span> <span class="kt">zeroPoint:</span> <span class="kt">CGPoint</span>
  <span class="kt">init</span><span class="o">()</span>
  <span class="kt">init</span><span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">extension</span> <span class="nc">CGSize</span> <span class="o">{</span>
  <span class="n">static</span> <span class="k">var</span> <span class="n">zeroSize</span><span class="k">:</span> <span class="kt">CGSize</span>
  <span class="nf">init</span><span class="o">()</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">extension</span> <span class="nc">CGVector</span> <span class="o">{</span>
  <span class="n">static</span> <span class="k">var</span> <span class="n">zeroVector</span><span class="k">:</span> <span class="kt">CGVector</span>
  <span class="nf">init</span><span class="o">(</span><span class="k">_</span> <span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="k">_</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
  <span class="nf">init</span><span class="o">(</span><span class="k">_</span> <span class="n">dx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">_</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">extension</span> <span class="nc">CGRect</span> <span class="k">:</span> <span class="kt">Equatable</span> <span class="o">{</span>
  <span class="c1">// 全为 0</span>
  <span class="kt">static</span> <span class="kt">var</span> <span class="kt">zeroRect:</span> <span class="kt">CGRect</span>
  <span class="c1">// 原点为无穷大，表示空</span>
  <span class="n">static</span> <span class="k">var</span> <span class="n">nullRect</span><span class="k">:</span> <span class="kt">CGRect</span>
  <span class="c1">// 原点无穷小，宽高无穷大</span>
  <span class="n">static</span> <span class="k">var</span> <span class="n">infiniteRect</span><span class="k">:</span> <span class="kt">CGRect</span>
  <span class="nf">init</span><span class="o">()</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
  <span class="nf">init</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="k">var</span> <span class="n">width</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="k">var</span> <span class="n">height</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="k">var</span> <span class="n">minX</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="k">var</span> <span class="n">minY</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="c1">// 中点</span>
  <span class="k">var</span> <span class="n">midX</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="k">var</span> <span class="n">midY</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="k">var</span> <span class="n">maxX</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="k">var</span> <span class="n">maxY</span><span class="k">:</span> <span class="kt">CGFloat</span>
  <span class="k">var</span> <span class="n">isNull</span><span class="k">:</span> <span class="kt">Bool</span>
  <span class="k">var</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Bool</span>
  <span class="k">var</span> <span class="n">isInfinite</span><span class="k">:</span> <span class="kt">Bool</span>
  <span class="k">var</span> <span class="n">standardizedRect</span><span class="k">:</span> <span class="kt">CGRect</span>
  <span class="n">func</span> <span class="nf">standardize</span><span class="o">()</span>
  <span class="k">var</span> <span class="n">integerRect</span><span class="k">:</span> <span class="kt">CGRect</span>
  <span class="n">func</span> <span class="nf">integerize</span><span class="o">()</span>
  <span class="n">func</span> <span class="nf">rectByInsetting</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
  <span class="n">func</span> <span class="nf">inset</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
  <span class="n">func</span> <span class="nf">rectByOffsetting</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
  <span class="n">func</span> <span class="nf">offset</span><span class="o">(</span><span class="k">#</span><span class="n">dx</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">)</span>
  <span class="n">func</span> <span class="nf">rectByUnion</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
  <span class="n">func</span> <span class="nf">union</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span>
  <span class="n">func</span> <span class="nf">rectByIntersecting</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">CGRect</span>
  <span class="n">func</span> <span class="nf">intersect</span><span class="o">(</span><span class="n">withRect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span>
  <span class="n">func</span> <span class="nf">rectsByDividing</span><span class="o">(</span><span class="n">atDistance</span><span class="k">:</span> <span class="kt">CGFloat</span><span class="o">,</span> <span class="n">fromEdge</span><span class="k">:</span> <span class="kt">CGRectEdge</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">slice</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">,</span> <span class="n">remainder</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span>
  <span class="n">func</span> <span class="nf">contains</span><span class="o">(</span><span class="n">rect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
  <span class="n">func</span> <span class="nf">contains</span><span class="o">(</span><span class="n">point</span><span class="k">:</span> <span class="kt">CGPoint</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
  <span class="n">func</span> <span class="nf">intersects</span><span class="o">(</span><span class="n">rect</span><span class="k">:</span> <span class="kt">CGRect</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="appkit">AppKit</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extension</span> <span class="nc">NSGradient</span> <span class="o">{</span>
  <span class="n">convenience</span> <span class="nf">init</span><span class="o">(</span><span class="n">colorsAndLocations</span> <span class="n">objects</span><span class="k">:</span> <span class="o">(</span><span class="kt">AnyObject</span><span class="o">,</span> <span class="kt">CGFloat</span><span class="o">)...)</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="uikit">UIKit</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extension</span> <span class="nc">UIDeviceOrientation</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">isPortrait</span><span class="k">:</span> <span class="kt">Bool</span>
  <span class="c1">// also isLandscape isValidInterfaceOrientation isFlat</span>
<span class="o">}</span>
<span class="n">extension</span> <span class="nc">UIInterfaceOrientation</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">isPortrait</span><span class="k">:</span> <span class="kt">Bool</span>
  <span class="k">var</span> <span class="n">isLandscape</span><span class="k">:</span> <span class="kt">Bool</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个模块是交叉编译的。。不太容易获得信息。不过好在扩展内容不多。</p>

<h3 id="spritekit">SpriteKit</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extension</span> <span class="nc">SKNode</span> <span class="o">{</span>
  <span class="nd">@objc</span> <span class="nf">subscript</span> <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">SKNode</span><span class="o">[]</span> <span class="o">{</span> <span class="n">get</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="特殊-mirror-实现">特殊 Mirror 实现</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSSet NSDate NSArray NSRange NSURL NSDictionary NSString
CGPoint CGRect CGSize
NSView
UIView
SKTextureAtlas SKTexture SKSpriteNode SKShapeNode
</code></pre></div></div>

<p>单独添加了自己的 <code class="language-plaintext highlighter-rouge">Mirror</code> 类型，单独实现。</p>

<p><code class="language-plaintext highlighter-rouge">Mirror</code> 类型其实是为 <code class="language-plaintext highlighter-rouge">QuickLookObject</code> 准备的，也就是在 Xcode Playground 中快速查看。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[最近看到了 Swift Style Guide 个人觉得内容太少， Swift 本身作为一门庞大的语言，语素众多。本文就 Swift 本身对 Cocoa 的扩展，看看对日常 Cocoa 风格有什么影响。]]></summary></entry><entry><title type="html">Swift Type Hierarchy ( Swift 类型层次结构 ）</title><link href="https://andelf.github.io/blog/2014/06/30/swift-type-hierarchy/" rel="alternate" type="text/html" title="Swift Type Hierarchy ( Swift 类型层次结构 ）" /><published>2014-06-30T07:10:41+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/06/30/swift-type-hierarchy</id><content type="html" xml:base="https://andelf.github.io/blog/2014/06/30/swift-type-hierarchy/"><![CDATA[<p>声明： 转载请注明，方便的情况下请知会本人. <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文主要介绍 Swift 所有标准库类型的层次结构，及所有标准类型。本文可作为参考手册使用。</p>

<p>本人不保证内容及时性和正确性，请善于怀疑并反馈。谢谢。</p>

<p>本文探索 Swift 所有基础类型和高级类型，以及所有协议和他们之间的继承关系。</p>

<p>为了简化问题，某些类型略去了中间的过渡类型，人肉保证不歧义。</p>

<h2 id="swift-基础类型">Swift 基础类型</h2>

<h3 id="数值类型">数值类型</h3>

<h4 id="位">位</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bit
</code></pre></div></div>

<p>只有一位，实现为 <code class="language-plaintext highlighter-rouge">enum</code>， <code class="language-plaintext highlighter-rouge">.zero</code> 或 <code class="language-plaintext highlighter-rouge">.one</code>。简单明了。</p>

<p>协议: <code class="language-plaintext highlighter-rouge">RandomAccessIndex IntegerArithmetic</code></p>

<h4 id="整型">整型</h4>

<p>有符号:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Int Int8 Int16 Int32 Int64
</code></pre></div></div>

<p>协议：<code class="language-plaintext highlighter-rouge">SignedInteger RandomAccessIndex BitwiseOperations SignedNumber CVarArg</code></p>

<p>无符号:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UInt UInt8 UInt16 UInt32 UInt64
</code></pre></div></div>
<p>协议：<code class="language-plaintext highlighter-rouge">UnsignedInteger RandomAccessIndex BitwiseOperations</code></p>

<p>别名:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IntMax = Int64
UIntMax = UInt64
IntegerLiteralType = Int
Word = Int // 字长
UWord = UInt
</code></pre></div></div>

<h4 id="浮点型">浮点型</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Float Double Float80
</code></pre></div></div>

<p>别名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FloatLiteralType = Double
Float64 = Double
</code></pre></div></div>

<p>协议：<code class="language-plaintext highlighter-rouge">FloatingPointNumber</code>。</p>

<h3 id="逻辑型">逻辑型</h3>

<p>只有一个 <code class="language-plaintext highlighter-rouge">Bool</code>。</p>

<p>实例： <code class="language-plaintext highlighter-rouge">true</code>、<code class="language-plaintext highlighter-rouge">false</code></p>

<p>协议：<code class="language-plaintext highlighter-rouge">LogicValue</code>。</p>

<h3 id="空">空</h3>

<p>只有一个 <code class="language-plaintext highlighter-rouge">NilType</code>。</p>

<p>唯一实例 <code class="language-plaintext highlighter-rouge">nil</code>。</p>

<h3 id="字符串类型">字符（串）类型</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String</code></li>
  <li><code class="language-plaintext highlighter-rouge">Character</code> Unicode 字符</li>
  <li><code class="language-plaintext highlighter-rouge">UnicodeScalar</code> 相当于 C 中的 <code class="language-plaintext highlighter-rouge">wchar_t</code></li>
  <li><code class="language-plaintext highlighter-rouge">CString</code> 用于表示 C 中的 <code class="language-plaintext highlighter-rouge">const char *</code>，请参考相关文章</li>
  <li><code class="language-plaintext highlighter-rouge">StaticString</code> 静态字符串，内部使用，例如 <code class="language-plaintext highlighter-rouge">fatalError</code></li>
</ul>

<p>别名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StringLiteralType = String
ExtendedGraphemeClusterType = String
</code></pre></div></div>

<p>官方文档</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Character</code> represents some Unicode grapheme cluster as
defined by a canonical, localized, or otherwise tailored
segmentation algorithm.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">String</code> 实现协议：<code class="language-plaintext highlighter-rouge">Collection ExtensibleCollection OutputStream TargetStream</code>。</p>

<h3 id="array-类型">Array 类型</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Array&lt;T&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">ContiguousArray&lt;T&gt;</code></li>
</ul>

<p>实现协议 <code class="language-plaintext highlighter-rouge">ArrayType</code>。</p>

<p>内部容器：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ArrayBuffer&lt;T&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">ContiguousArrayBuffer&lt;T&gt;</code></li>
</ul>

<p>这两个类型看起来是 Array 的内部容器，一般不应该直接使用。</p>

<h3 id="字典类型">字典类型</h3>

<p><code class="language-plaintext highlighter-rouge">Dictionary&lt;KeyType : Hashable, ValueType&gt;</code></p>

<p>只实现了 <code class="language-plaintext highlighter-rouge">Collection</code>。</p>

<h3 id="元祖类型">元祖类型</h3>

<p>除正常元祖外，还有个特殊的别名</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Void = ()
</code></pre></div></div>

<p>其实很多语言都这么定义的，比如 Haskell 。</p>

<h3 id="optional-类型">Optional 类型</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code> 即 <code class="language-plaintext highlighter-rouge">T?</code></li>
  <li><code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional&lt;T&gt;</code> 即 <code class="language-plaintext highlighter-rouge">T!</code></li>
</ul>

<p>实现协议: <code class="language-plaintext highlighter-rouge">LogicValue</code>，行为是判断是否为 <code class="language-plaintext highlighter-rouge">.None</code>。</p>

<p>另外 <a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">Swift 的隐式类型转换</a>
有提到，为什么 <code class="language-plaintext highlighter-rouge">nil</code> 可以给 <code class="language-plaintext highlighter-rouge">Optional</code> 类型赋值的问题。</p>

<h3 id="cobjc-兼容类型">C/ObjC 兼容类型</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CBool = Bool
CFloat = Float
CDouble = Double
CChar = Int8
CSignedChar = Int8
CUnsignedChar = UInt8
CChar16 = UInt16
CWideChar = UnicodeScalar
CChar32 = UnicodeScalar
CInt = Int32
CUnsignedInt = UInt32
CShort = Int16
CUnsignedShort = UInt16
CLong = Int
CUnsignedLong = UInt
CLongLong = Int64
CUnsignedLongLong = UInt64
</code></pre></div></div>

<p>具体使用参考 C 交互的几篇文章，基本没区别。</p>

<h3 id="any-类型">Any 类型</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AnyObject
// 别名
Any = protocol&lt;&gt;
AnyClass = AnyObject.Type
</code></pre></div></div>

<p>还有个用在函数定义的类型签名上， <code class="language-plaintext highlighter-rouge">Any.Type</code>。</p>

<p>顺便这里看到一个奇异的语法 <code class="language-plaintext highlighter-rouge">protocol&lt;&gt;</code>，这个也是 Swift 一种用来表示类型限制的方法，可以用在类型的位置，尖括号里可以是协议的列表。</p>

<h3 id="指针类型">指针类型</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnsafePointer&lt;T&gt;
CMutableVoidPointer
CConstVoidPointer
COpaquePointer
CConstPointer&lt;T&gt;
AutoreleasingUnsafePointer&lt;T&gt;
CVaListPointer
CMutablePointer&lt;T&gt;
</code></pre></div></div>

<p>参考 C 交互文章。</p>

<ul>
  <li><a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">简析Swift和C的交互</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">简析 Swift 和 C 的交互，Part 二</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc/">Swift 与 ObjC 和 C 的交互，第三部分</a></li>
</ul>

<h3 id="其他辅助类型">其他辅助类型</h3>

<p>多了去了。比如 for-in 实现时候的 Generator 、比如反射时候用的 <code class="language-plaintext highlighter-rouge">*Mirror</code>、比如切片操作用的 <code class="language-plaintext highlighter-rouge">Range&lt;T&gt;</code>。比如内部储存类。</p>

<p>还有储存辅助类 <code class="language-plaintext highlighter-rouge">OnHeap&lt;T&gt;</code> 等等。以后有机会再探索。</p>

<h2 id="swift-标准库协议">Swift 标准库协议</h2>

<h3 id="打印相关-printable-debugprintable">打印相关 <code class="language-plaintext highlighter-rouge">Printable DebugPrintable</code></h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">protocol</span> <span class="nc">Printable</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">description</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">protocol</span> <span class="nc">DebugPrintable</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">debugDescription</span><span class="k">:</span> <span class="kt">String</span> <span class="o">{</span> <span class="kt">get</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>用于打印和字符串的 Interpolation 。</p>

<h3 id="literalconvertible"><code class="language-plaintext highlighter-rouge">*LiteralConvertible</code></h3>

<p>从字面常量获取。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ArrayLiteralConvertible
IntegerLiteralConvertible
DictionaryLiteralConvertible
CharacterLiteralConvertible
FloatLiteralConvertible
ExtendedGraphemeClusterLiteralConvertible
StringLiteralConvertible
</code></pre></div></div>

<p>其中字符串和字符的字面常量表示有所重合，也就是说 <code class="language-plaintext highlighter-rouge">"a"</code> 可以是字符串也可以是字符。<a href="http://andelf.github.io/blog/2014/06/17/nsobject-pattern-match-in-swift/">简析 Swift 中的 Pattern Match</a> 一文中就是遇到了类似的情况。</p>

<h3 id="logicvalue"><code class="language-plaintext highlighter-rouge">LogicValue</code></h3>

<p>相当于重载 <code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">while</code> 的行为。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">protocol</span> <span class="nc">LogicValue</span> <span class="o">{</span>
  <span class="n">func</span> <span class="nf">getLogicValue</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Bool</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="sequence"><code class="language-plaintext highlighter-rouge">Sequence</code></h3>

<p>相当于重载 for-in 。和 <code class="language-plaintext highlighter-rouge">Generator</code> 联用。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">protocol</span> <span class="nc">Sequence</span> <span class="o">{</span>
  <span class="n">typealias</span> <span class="nc">GeneratorType</span> <span class="k">:</span> <span class="kt">Generator</span>
  <span class="n">func</span> <span class="nf">generate</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">GeneratorType</span>
<span class="o">}</span>

<span class="n">protocol</span> <span class="nc">Generator</span> <span class="o">{</span>
  <span class="n">typealias</span> <span class="nc">Element</span>
  <span class="n">mutating</span> <span class="n">func</span> <span class="nf">next</span><span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Element</span><span class="o">?</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// for .. in { }</span>
<span class="k">var</span> <span class="nc">__g</span> <span class="k">=</span> <span class="nv">someSequence</span><span class="o">.</span><span class="py">generate</span><span class="o">()</span>
<span class="k">while</span> <span class="n">let</span> <span class="n">x</span> <span class="k">=</span> <span class="nv">__g</span><span class="o">.</span><span class="py">next</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}}</span>
</code></pre></div></div>

<h3 id="整型-index-相关协议">整型、 Index 相关协议</h3>

<p>这些协议都是用来表示容器类型的索引、及相关的索引运算。</p>

<p>这里略去了部分私有内容。略去了 <code class="language-plaintext highlighter-rouge">Printable</code> 等。</p>

<p><img src="/assets/swift-integer.png" alt="Swift Integer Type Hierarchy" /></p>

<h3 id="rawoptionset-相关协议">RawOptionSet 相关协议</h3>

<p>一般用来表示二进制的选项，类似于 C enum ，很多 Cocoa 的 flag 被映射到它。相当于一个 Wrapper 的作用。</p>

<p><img src="/assets/swift-rawoptset.png" alt="Swift RawOptionSet" /></p>

<p>可以看到要求被 Wrap 的对象支持 <code class="language-plaintext highlighter-rouge">BitwiseOperations</code>。</p>

<h3 id="array-相关协议">Array 相关协议</h3>

<p>图中用虚线标注了和 <code class="language-plaintext highlighter-rouge">Generator</code> 的关系。</p>

<p><img src="/assets/swift-collection.png" alt="Swift Collection Protocol" /></p>

<p><code class="language-plaintext highlighter-rouge">Array&lt;T&gt;</code> 类型实现了 <code class="language-plaintext highlighter-rouge">ArrayType</code> 协议。</p>

<p><code class="language-plaintext highlighter-rouge">Dictionary</code> 类型实现了 <code class="language-plaintext highlighter-rouge">Collection</code> 协议。</p>

<h3 id="反射相关协议">反射相关协议</h3>

<p>包括 <code class="language-plaintext highlighter-rouge">Mirror</code>、<code class="language-plaintext highlighter-rouge">MirrorDisposition</code>、<code class="language-plaintext highlighter-rouge">Reflectable</code>。</p>

<p>请参考 <a href="http://andelf.github.io/blog/2014/06/20/swift-reflection/">Swift 的反射</a>。</p>

<h3 id="浮点数协议">浮点数协议</h3>

<p>只有一个 <code class="language-plaintext highlighter-rouge">FloatingPointNumber</code>。单独存在。是为了定义完整而存在。看官自己搞定。</p>

<h3 id="io-输出伪输出相关">IO 输出，伪输出相关</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Streamable {
  func writeTo&lt;Target : OutputStream&gt;(inout target: Target)
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Streamable</code> 表示可以被写入到输出流中，比如字符串、字符等。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol OutputStream {
  func write(string: String)
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">OutputStream</code> 表示一个输出流，比如标准输出（<code class="language-plaintext highlighter-rouge">stdout</code>），也可以表示一个伪输出流，例如字符串 <code class="language-plaintext highlighter-rouge">String</code>。</p>

<p>标准输出的获取方法</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var stdout = _Stdout()
</code></pre></div></div>

<p>看起来是私有结构，某一天不能用的话，别怪我。调用时候用 <code class="language-plaintext highlighter-rouge">inout</code> 引用语法。</p>

<h3 id="cvararg-处理">CVarArg 处理</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol CVarArg {
  func encode() -&gt; Word[]
}
</code></pre></div></div>

<p>用于处理 C 函数的可变参数，参考 <a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">简析 Swift 和 C 的交互，Part 二</a>。</p>

<h3 id="bridge-协议">Bridge 协议</h3>

<p>这里有个疑问就是编译过程中这些 Bridge 协议有没有参与。目前还没办法确定。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">_BridgedToObjectiveC</code></li>
  <li><code class="language-plaintext highlighter-rouge">_ConditionallyBridgedToObjectiveC</code></li>
</ul>

<p>具体内容可以参考 <a href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/">Swift 与 Objective-C 之间的交互</a>一文。</p>

<h3 id="其他">其他</h3>

<p><code class="language-plaintext highlighter-rouge">Sink</code> 看起来是一个容器，可能是用来编码时使用。</p>

<p><code class="language-plaintext highlighter-rouge">ArrayBufferType</code> 用于表示 <code class="language-plaintext highlighter-rouge">ArrayType</code> 的内部储存，看起来似乎也可以直接用。</p>

<p><code class="language-plaintext highlighter-rouge">UnicodeCodec</code> 用于处理编码。有 <code class="language-plaintext highlighter-rouge">UTF8</code>、<code class="language-plaintext highlighter-rouge">UTF16</code>、<code class="language-plaintext highlighter-rouge">UTF32</code> 可用。</p>

<p><code class="language-plaintext highlighter-rouge">ArrayBound</code> 用来处理数组边界，详细原理和作用过程未知。</p>

<h2 id="总结">总结</h2>

<p>无。</p>

<p>参考：</p>

<ul>
  <li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a></li>
</ul>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[声明： 转载请注明，方便的情况下请知会本人. weibo]]></summary></entry><entry><title type="html">My View of Swift （闲扯对 Swift 语言的看法）</title><link href="https://andelf.github.io/blog/2014/06/30/my-view-of-swift/" rel="alternate" type="text/html" title="My View of Swift （闲扯对 Swift 语言的看法）" /><published>2014-06-30T03:05:13+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/06/30/my-view-of-swift</id><content type="html" xml:base="https://andelf.github.io/blog/2014/06/30/my-view-of-swift/"><![CDATA[<p>其实这是很早就像要说的了，大概当时信誓旦旦说要看完那本 epub 写个读后感谈谈对 Swift 看法什么的。后来不了了之。
现在觉得这个时机或许差不多，对 Swift 的了解也算凑合了。</p>

<p>纯个人观点。</p>

<h3 id="swift-是系统编程语言">Swift 是系统编程语言</h3>

<p>一开始大家还不太了解的时候，可能会有很多误解。现在好歹一个月了。误解终于少了。</p>

<p>是的， Swift 是系统编程语言，原因是因为它 ABI 兼容 C （不包括 name mangling 部分）。基于强大的 llvm 生成具体平台代码。不是翻译为 Objective-C 的。</p>

<p>编译器参数还显示， Swift 文件的中间编译结果（介于 Swift 代码和 llvm ir ）是 SIL ，猜测是 Swift Intermediate Language 。好像和 llvm ir 有所联系。而且至少有两个 stage 。</p>

<p>不是脚本语言，也不是胶水语言。但是它的标准库 (import Swift 库) 几乎不含任何 IO 网络 等内容，随便做个功能强依赖 Cocoa 框架。也可以 <code class="language-plaintext highlighter-rouge">import Darwin</code> 用 C 语言的标准库来写。</p>

<p>猜测写个 Python C 模块这种任务是可以轻易胜任的。</p>

<p>而 Golang 、 Rust 本身 ABI 是和 C 不兼容的。虽然 Rust 通过 <code class="language-plaintext highlighter-rouge">extern "C"</code> 可以修改单个函数为兼容。</p>

<h3 id="swift-是现代语言">Swift 是现代语言</h3>

<p>自动类型推导、泛型、 LLVM 。当然语言研究党都知道这些都是几十年前的“新东西”。</p>

<h3 id="swift-是半完成品">Swift 是半完成品</h3>

<p>这么说主要是指 Swift 对 Cocoa 的库实在是太半吊子了。只是 Foundation 有 Bridge 支持，其他库中，明显的列表都无法支持 subscript 、 for-in 这样简单的操作。原因很简单，这些库都是自动转换 ObjC 头文件而来（参考模块那篇文章）。没有额外的封装代码。</p>

<p>所以其实真要用起来，可能会很纠结。或者可以预计很快就有第三方的 Bridge 库给这些类型加上舒服的 Swift 支持。</p>

<p>另外命令行没有静态链接库支持。只能用其他命令拼装。也侧面说明， Apple 希望开发者更多用动态链接库， Framework 。</p>

<p>另外目前的编译器 coredump 、 stackoverflow 太多太多。错哪都不知道。</p>

<h3 id="swift-隐藏细节太多">Swift 隐藏细节太多</h3>

<p>就对应到 Foundation 类型这个特性太说，太多黑魔法，隐式类型转换、 BridgeToObjectiveC 协议、指针类型转换。</p>

<p>这些隐藏的特性多少都会成为 Swift 的坑。</p>

<p>要知道定义在 ObjC 库的 <code class="language-plaintext highlighter-rouge">NSString</code> 参数某些情况下在 Swift 中被转换为 <code class="language-plaintext highlighter-rouge">String</code>。 <code class="language-plaintext highlighter-rouge">NSArray</code> 都被转换为 <code class="language-plaintext highlighter-rouge">AnyObject[]</code>。即使有隐式类型转换，某些极端情况下，还是会有编译时错误。</p>

<h3 id="swfit-的性能">Swfit 的性能</h3>

<p>我没做过测试，但就语言特性来说， Swift 是比 ObjC 快的，因为静态类型使得他在编译时就已经知道调用函数的具体位置。而不是 Objective-C 的消息发送、 Selector 机制。</p>

<p>目前来看， Swift 性能略差原因主要是编译器还没足够优化、还有就是 Cocoa 拖了后腿， Cocoa 本身有大量的 <code class="language-plaintext highlighter-rouge">AnyObject</code> 返回值。所以实际写 Swift 代码时，多用 <code class="language-plaintext highlighter-rouge">as</code> 一定是好习惯。明确类型。</p>

<h3 id="swift-的未来">Swift 的未来</h3>

<p>我不知道。至少好像感觉很多培训机构都看到了前途开始疯狂的做视频。</p>

<p>倒是觉得什么时候 Cocoa for Swift 出了才算它完全完成任务。</p>

<p>总觉得 Cocoa 拖后腿，不然放到其他平台也不错。</p>

<p>对了，之前不是在 App 开发领域，这才知道原来这个地盘水很深，太多唯利的培训机构，太多嗷嗷待哺等视频教程的新人。觉得挺有意思。就拿 ? ! 这个 Optional 为例，太多介绍的文章。可惜能说明白的太少太少。糊里糊涂做开发就是当前现状吧。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[其实这是很早就像要说的了，大概当时信誓旦旦说要看完那本 epub 写个读后感谈谈对 Swift 看法什么的。后来不了了之。 现在觉得这个时机或许差不多，对 Swift 的了解也算凑合了。]]></summary></entry><entry><title type="html">Swift Interop with C/ObjC Part 3 (Swift 与 ObjC 和 C 的交互，第三部分）</title><link href="https://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc/" rel="alternate" type="text/html" title="Swift Interop with C/ObjC Part 3 (Swift 与 ObjC 和 C 的交互，第三部分）" /><published>2014-06-28T13:58:35+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc</id><content type="html" xml:base="https://andelf.github.io/blog/2014/06/28/swift-interop-with-c-slash-objc/"><![CDATA[<p>声明： 转载请注明，方便的情况下请知会本人. <a href="http://weibo.com/234632333">weibo</a></p>

<p>之前说那是最后一篇。可惜越来越发现有很多东西还没介绍到。事不过三。再坑一篇。</p>

<h2 id="前言">前言</h2>

<p>本文解决如下问题</p>

<ul>
  <li>ObjC/C 中定义的某个类型、结构体，通过 Bridge Header 或者 Module 对应到 Swift 到底是什么类型</li>
  <li>指针间的转换问题</li>
</ul>

<p>补充之前没解决的一些问题，比如提到 <code class="language-plaintext highlighter-rouge">CMutablePointer</code> 的 <code class="language-plaintext highlighter-rouge">sizeof</code> 是两个字长，那么在函数调用中是如何对应到 C 的指针的？</p>

<p>预备内容：</p>

<ul>
  <li><a href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/">Swift 与 Objective-C 之间的交互</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/15/swift-and-c-interop/">简析Swift和C的交互</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">简析 Swift 和 C 的交互，Part 二</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/16/swift-nserror-internals/">Swift NSError Internals（解析 Swift 对 NSError 操作）</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/08/swift-implicit-type-cast/">Swift 的隐式类型转换</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/06/swift-attributes/">Swift Attributes</a></li>
</ul>

<h2 id="cobjc-to-swift-对应规则">C/ObjC to Swift 对应规则</h2>

<p>以下内容均适合 Objective-C 。第一部分适合 C 。</p>

<p><strong>以下内容再 Xcode6-beta3 中不适用</strong> 请参考 <a href="http://andelf.github.io/blog/2014/07/08/swift-beta3-changes/">Swift 在 Xcode6-beta3 中的变化</a>。</p>

<h3 id="for-c">for C</h3>

<h4 id="可导出的类型定义">可导出的类型定义</h4>

<p>函数、枚举、结构体、常量定义、宏定义。</p>

<p>结构体定义支持：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Name</span> <span class="p">{...}</span> <span class="n">Name</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Name_t</span> <span class="p">{...}</span> <span class="n">Name</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<p>其中无法处理的结构体、函数类型、 varargs 定义不导出。预计以后版本会修复。带 bit field 的结构体也无法识别。</p>

<h4 id="类型对应关系">类型对应关系</h4>

<p>仔细分析发现，诡异情况还很多。基础类型请参考上几篇。</p>

<p>在函数定义参数中：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">类型</th>
      <th style="text-align: center">对应为</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">void *</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">CMutableVoidPointer</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Type *</code>、<code class="language-plaintext highlighter-rouge">Type[]</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">CMutablePointer&lt;Type&gt;</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">const char *</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">CString</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">const Type *</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">CConstPointer&lt;Type&gt;</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">const void *</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">CConstVoidPointer</code></td>
    </tr>
  </tbody>
</table>

<p>在函数返回、结构体字段中：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">类型</th>
      <th style="text-align: center">对应为</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">const char *</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">CString</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Type *</code>、<code class="language-plaintext highlighter-rouge">const Type *</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">UnsafePointer&lt;Type&gt;</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">void *</code>、<code class="language-plaintext highlighter-rouge">const void *</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">COpaquePointer</code></td>
    </tr>
    <tr>
      <td style="text-align: center">无法识别的结构指针</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">COpaquePointer</code></td>
    </tr>
  </tbody>
</table>

<p>另外还有如下情况：</p>

<p>全局变量、全局常量(<code class="language-plaintext highlighter-rouge">const</code>)、宏定义常量(<code class="language-plaintext highlighter-rouge">#define</code>) 均使用 <code class="language-plaintext highlighter-rouge">var</code>，常量不带 <code class="language-plaintext highlighter-rouge">set</code>。</p>

<p>结构体中的数组，对应为元祖，例如 <code class="language-plaintext highlighter-rouge">int data[2]</code> 对应为 <code class="language-plaintext highlighter-rouge">(CInt, CInt)</code>，所以也许。。会很长。数组有多少元素就是几元祖。</p>

<h3 id="for-objc">for ObjC</h3>

<p>ObjC 明显情况要好的多，官方文档也很详细。</p>

<p>除了 <code class="language-plaintext highlighter-rouge">NSError **</code> 转为 <code class="language-plaintext highlighter-rouge">NSErrorPointer</code> 外，需要注意的就是：</p>

<p>函数参数、返回中的 <code class="language-plaintext highlighter-rouge">NSString *</code> 被替换为 <code class="language-plaintext highlighter-rouge">String!</code>、<code class="language-plaintext highlighter-rouge">NSArray *</code> 被替换为 <code class="language-plaintext highlighter-rouge">AnyObject[]!</code>。</p>

<p>而全局变量、常量的 <code class="language-plaintext highlighter-rouge">NSString *</code> 不变。</p>

<h2 id="关于-cmutablepointer-的行为">关于 <code class="language-plaintext highlighter-rouge">CMutablePointer</code> 的行为</h2>

<p>上回说到 <code class="language-plaintext highlighter-rouge">CMutablePointer</code>、<code class="language-plaintext highlighter-rouge">CConstPointer</code>、<code class="language-plaintext highlighter-rouge">CMutableVoidPointer</code>、<code class="language-plaintext highlighter-rouge">CConstVoidPointer</code>
四个指针类型的字长是 2，也就是说，不可以直接对应为 C 中的指针。但是前面说类型对应关系的时候， C 函数声明转为 Swift
时候又用到了这些类型，所以看起来自相矛盾。仔细分析了 lldb 反汇编代码后发现，有如下隐藏行为:</p>

<h3 id="in-swift">in Swift</h3>

<p>在纯 Swift 环境下，函数定义等等、这些类型字长都为 2，不会有任何意外情况出现。</p>

<h3 id="in-cobjc">in C/ObjC</h3>

<p>当一个函数的声明是由 Bridge Header 或者 LLVM Module 隐式转换而来，且用到了这四个指针类型，那么代码编译过程中类型转换规则、隐式转换调用等规则依然有效。只不过在代码最生成一步，会插入以下私有函数调用之一：</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCMutablePointerToUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CMutablePointer&lt;T&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">UnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCConstPointerToUnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CConstPointer&lt;T&gt;</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">UnsafePointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCMutableVoidPointerToCOpaquePointer</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CMutableVoidPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">COpaquePointer</span>
<span class="nd">@transparent</span> <span class="n">func</span> <span class="nc">_convertCConstVoidPointerToCOpaquePointer</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">CConstVoidPointer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">COpaquePointer</span>
</code></pre></div></div>

<p>这个过程是背后隐藏的。然后将转换的结果传参给对应的 C/ObjC 函数。实现了指针类型字长正确、一致。</p>

<h3 id="结论">结论</h3>

<p>作为程序员，需要保证调用 C 函数的时候类型一致。如果有特殊需求重新声明了对应的 C 函数，那么以上规则不起作用，所以重声明 C 中的函数时表示指针不可以使用这四个指针类型。</p>

<h2 id="再说指针">再说指针</h2>

<p><img src="/assets/swift-pointers.png" alt="Swift Pointers" /></p>

<p>虚线表示直接隐式类型转换。其中 <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;T&gt;</code> 可以通过用其他任何指针调用构造函数获得。</p>

<p><code class="language-plaintext highlighter-rouge">CMutablePointer&lt;T&gt;</code> 和 <code class="language-plaintext highlighter-rouge">CMutableVoidPointer</code> 也可以通过 <code class="language-plaintext highlighter-rouge">Array&lt;T&gt;</code> 的引用隐式类型转换获得 （ <code class="language-plaintext highlighter-rouge">&amp;arr</code> ）。</p>

<p>椭圆表示类型 <code class="language-plaintext highlighter-rouge">sizeof</code> 为字长，可以用于声明 C 函数。</p>

<p>四大指针可以用 <code class="language-plaintext highlighter-rouge">withUnsafePointer</code> 操作。转换为 <code class="language-plaintext highlighter-rouge">UnsafePointer&lt;T&gt;</code>。上一节提到的私有转换函数请不要使用。</p>

<h2 id="字符串">字符串</h2>

<p>之前的文章已经介绍过怎么从 <code class="language-plaintext highlighter-rouge">CString</code> 获取 <code class="language-plaintext highlighter-rouge">String</code> （静态方法 <code class="language-plaintext highlighter-rouge">String.fromCString</code>）。</p>

<p>从 <code class="language-plaintext highlighter-rouge">String</code> 获取 <code class="language-plaintext highlighter-rouge">CString</code> 也说过， 是用 <code class="language-plaintext highlighter-rouge">withCString</code>。</p>

<p>也可以从 <code class="language-plaintext highlighter-rouge">CString(UnsafePointer.alloc(100))</code> 来分配空数组。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://github.com/andelf/Defines-Swift">我的 Github andelf/Defines-Swift</a></li>
</ul>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[声明： 转载请注明，方便的情况下请知会本人. weibo]]></summary></entry><entry><title type="html">Tilde Arrow in Swift （Swift 标准库中的波浪箭头 ~&amp;gt; ）</title><link href="https://andelf.github.io/blog/2014/06/25/tilde-arrow-in-swift/" rel="alternate" type="text/html" title="Tilde Arrow in Swift （Swift 标准库中的波浪箭头 ~&amp;gt; ）" /><published>2014-06-25T14:44:29+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/06/25/tilde-arrow-in-swift</id><content type="html" xml:base="https://andelf.github.io/blog/2014/06/25/tilde-arrow-in-swift/"><![CDATA[<p>本文瞎写，没实际内容。请不用看了。</p>

<h2 id="摘要">摘要</h2>

<p>本文挖掘 Swift 标准库中的诡异操作符 <code class="language-plaintext highlighter-rouge">~&gt;</code> 波浪箭头的作用。</p>

<h2 id="正文">正文</h2>

<p>查看标准库定义的时候，发现了一个奇怪的运算符 <code class="language-plaintext highlighter-rouge">~&gt;</code>，看起来高大上，所以探索下它到底起什么作用。</p>

<p>标准库对 <code class="language-plaintext highlighter-rouge">~&gt;</code> 用到的地方很多，我取最简单的一个来做说明。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol SignedNumber : _SignedNumber {
  func -(x: Self) -&gt; Self
  func ~&gt;(_: Self, _: (_Abs, ())) -&gt; Self
}
func ~&gt;&lt;T : _SignedNumber&gt;(x: T, _: (_Abs, ())) -&gt; T
func abs(_: CInt) -&gt; CInt
func abs&lt;T : SignedNumber&gt;(x: T) -&gt; T
</code></pre></div></div>

<p>这是对有符号整型的一个协议，我去掉了额外的属性。事实上 <code class="language-plaintext highlighter-rouge">_Abs</code> 类型是一个空结构， <code class="language-plaintext highlighter-rouge">sizeof</code> 为 0 。</p>

<p>写个测试程序，计算下 <code class="language-plaintext highlighter-rouge">abs(-100)</code> 看看情况，发现 <code class="language-plaintext highlighter-rouge">top_level_code()</code> 调用了 <code class="language-plaintext highlighter-rouge">SignedNumber</code> 版本的 <code class="language-plaintext highlighter-rouge">abs()</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>callq  0x100001410               ; Swift.abs &lt;A : Swift.SignedNumber&gt;(A) -&gt; A
</code></pre></div></div>

<p>反汇编这个库函数，发现一个有意思的调用：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>callq  0x10000302a               ; symbol stub for: Swift._abs &lt;A&gt;(A) -&gt; (Swift._Abs, A)
</code></pre></div></div>

<p>这个 <code class="language-plaintext highlighter-rouge">_abs()</code> 函数是私有函数， Swift 中把很多私有的函数、成员变量、结构、协议都以下划线开头，意思就是不希望我们去调用或者访问的函数，在缺乏成员访问控制的语言中，其实这么做也不错。大家可以借鉴。</p>

<p>而 <code class="language-plaintext highlighter-rouge">_abs()</code> 函数很简单，将任意类型 T 直接封装成 <code class="language-plaintext highlighter-rouge">(_Abs, T)</code> 元组，返回。</p>

<p>然后代码的逻辑就是用这个元祖解开重新组装，调用 <code class="language-plaintext highlighter-rouge">~&gt;</code>。逻辑如下：</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// logic of abs() funciton</span>
<span class="nf">let</span> <span class="o">(</span><span class="n">operation</span><span class="o">,</span> <span class="k">val</span><span class="o">)</span> <span class="k">=</span> <span class="nc">_abs</span><span class="o">(-</span><span class="mi">100</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">~&gt;</span> <span class="o">(</span><span class="n">operation</span><span class="o">,</span> <span class="o">())</span> <span class="c1">// 返回 100</span>
</code></pre></div></div>

<p>到这里就清楚了。实际上 <code class="language-plaintext highlighter-rouge">~&gt;</code> 将一个简单的操作复杂化。多调用了层，实际开销主要在元祖的解开和重组装（实际开销理论上在优化模式下应该可以忽略，因为包含 <code class="language-plaintext highlighter-rouge">_Abs</code>， size 为 0）。</p>

<p>到这里很多朋友应该已经知道怎么回事了。 <code class="language-plaintext highlighter-rouge">SignedNumber</code> 中的 <code class="language-plaintext highlighter-rouge">~&gt;</code> 操作是为我们提供了一个方法可以 hook 到标准库的 <code class="language-plaintext highlighter-rouge">abs()</code> 函数。来自 Haskell 的同学应该会见过这种单纯地用类型签名来实现函数分发调用的方式。</p>

<h3 id="优点">优点？</h3>

<p>暂时正在考虑。想明白会发出来。</p>

<h3 id="延伸">延伸</h3>

<p>其实很多标准库函数都用到了类似的方法实现。都用到了 <code class="language-plaintext highlighter-rouge">~&gt;</code> 运算符。包括：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>countElements()
// _countElements() 工具函数  _CountElements 结构
underestimateCount()
// _underestimateCount() 、 _UnderestimateCount
advance()
// _advance() 、 _Advance
</code></pre></div></div>

<p>等。</p>

<h2 id="附录">附录</h2>

<p>这里列出部分定义：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol Sequence : _Sequence_ {
  typealias GeneratorType : Generator
  func generate() -&gt; GeneratorType
  func ~&gt;(_: Self, _: (_UnderestimateCount, ())) -&gt; Int
  func ~&gt;&lt;R&gt;(_: Self, _: (_PreprocessingPass, ((Self) -&gt; R))) -&gt; R?
  func ~&gt;(_: Self, _: (_CopyToNativeArrayBuffer, ())) -&gt; ContiguousArrayBuffer&lt;Self.GeneratorType.Element&gt;
}
protocol Collection : _Collection, Sequence {
  subscript (i: Self.IndexType) -&gt; Self.GeneratorType.Element { get }
  func ~&gt;(_: Self, _: (_CountElements, ())) -&gt; Self.IndexType.DistanceType
}

protocol ForwardIndex : _ForwardIndex {
  func ~&gt;(start: Self, _: (_Distance, Self)) -&gt; Self.DistanceType
  func ~&gt;(start: Self, _: (_Advance, Self.DistanceType)) -&gt; Self
  func ~&gt;(start: Self, _: (_Advance, (Self.DistanceType, Self))) -&gt; Self
}
</code></pre></div></div>

<p>相关更多声明代码信息请参考 我的 Github : <a href="https://github.com/andelf/Defines-Swift">andelf/Defines-Swift</a> 。</p>

<h2 id="总结">总结</h2>

<p>通过 <code class="language-plaintext highlighter-rouge">~&gt;</code> 和 <code class="language-plaintext highlighter-rouge">protocol</code> 可以自定义编译器的行为。相当于 hook 标准库函数。由于内部实现未知，还不能继续断言它还有什么作用。</p>

<p>但是和直接用 extension 实现协议的方法相比，这个有什么好处呢？待考。</p>

<h2 id="更新">更新</h2>

<p>可以避免 <code class="language-plaintext highlighter-rouge">protocol</code> 中的静态函数混淆空间，如果用全局函数，那么相当于全局函数去调用静态函数。</p>

<p>还有就是在使用操作符的时候，如果定义多个，那么需要编译器去寻找可用的一个版本。</p>

<p>仔细查看目前的 <code class="language-plaintext highlighter-rouge">protocol</code> 实现，发现还是有点 BUG ，类型限制还是不清楚，表述高阶类型的时候。</p>

<p>为了描述 <code class="language-plaintext highlighter-rouge">~&gt;</code> 的用法，我写了个 <a href="https://gist.github.com/andelf/6a8432ef0820de9991f6">Monad.swift</a> 。</p>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[本文瞎写，没实际内容。请不用看了。]]></summary></entry><entry><title type="html">Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）</title><link href="https://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont/" rel="alternate" type="text/html" title="Write Swift Module Cont. Static Library （使用 Swift 创建 Swift 模块 - 静态链接库）" /><published>2014-06-25T13:20:55+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont</id><content type="html" xml:base="https://andelf.github.io/blog/2014/06/25/write-swift-module-with-swift-cont/"><![CDATA[<p>声明： 转载注明我或者 SwiftChina, 请在方便的情况下情尽量告知. <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文的发现基于个人研究。请尊重原创。</p>

<h2 id="摘要">摘要</h2>

<p>本文提出了一种可以编译 Swift 静态链接模块的方法，通过对 swift 编译命令行参数的控制，生成可以自由分发的静态链接库和 swift module 描述文件。同时还提出了导出 objC 头文件供 Objective-C 调用的可能。</p>

<p>关键词： Swift 模块 静态链接库</p>

<p>上次一篇文章 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a> 中提到：</p>

<blockquote>
  <p>静态链接库 .a 目前还没有找到方法， -Xlinker -static 会报错。</p>
</blockquote>

<p>最近摸索了下用 Swift 创建静态链接库的方法。有所收获，这里记录下。</p>

<h2 id="废话">废话</h2>

<p>我们中的很多人都知道，编译器编译的最后一个步骤一般都是链接，一般都是调用 <code class="language-plaintext highlighter-rouge">ld</code>。经过仔细分析，之前为什么不能生成 <code class="language-plaintext highlighter-rouge">.a</code> 静态链接库的原因，发现有如下问题：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-Xlinker -static</code> 参数传递的时候， swift 命令本身不能识别，讲 <code class="language-plaintext highlighter-rouge">-dylib</code> 与 <code class="language-plaintext highlighter-rouge">-static</code> 一起传递（这倒不是问题，参数优先级，静态盖掉了动态）</li>
  <li>链接到 <code class="language-plaintext highlighter-rouge">-lSystem</code> 时候，这个库没有静态链接。</li>
</ul>

<p>所以总会报错。</p>

<h3 id="思考">思考</h3>

<p>实际上之前的方法是走了弯路，根本没有必要去调用 <code class="language-plaintext highlighter-rouge">ld</code>，作为一个合格的 <code class="language-plaintext highlighter-rouge">.a</code> 静态链接库，只要有对应的 <code class="language-plaintext highlighter-rouge">.o</code> 就可以了，没必要去链接 <code class="language-plaintext highlighter-rouge">-lSystem</code>，也许是 swift 本身没有编译为静态链接库的参数支持。</p>

<p>检查 Swift 标准库中的静态链接库，果然只包含对应 <code class="language-plaintext highlighter-rouge">.swift</code> 代码编译后的 <code class="language-plaintext highlighter-rouge">.o</code> 文件。（检查方法是用 <code class="language-plaintext highlighter-rouge">ar -t libName.a</code>）</p>

<p>说到底， Swift 静态链接库的目标很简单，就是包含对应 Swift 模块的所有代码，这样就避免了对应动态链接库的引入。和什么 <code class="language-plaintext highlighter-rouge">-lSystem</code> 没啥相干。</p>

<h2 id="解决方法-howto">解决方法 HOWTO</h2>

<p>以 lingoer 的 <a href="https://github.com/lingoer/SwiftyJSON">SwiftyJSON</a> 为例。</p>

<p>我们的目标很简单，就是生成 <code class="language-plaintext highlighter-rouge">ModName.swiftmodule</code>、<code class="language-plaintext highlighter-rouge">ModName.swiftdoc</code>(可选)、<code class="language-plaintext highlighter-rouge">libswiftModName.a</code> 三个文件。</p>

<h3 id="编译">编译</h3>

<h4 id="生成-swiftmodule-swiftdoc">生成 <code class="language-plaintext highlighter-rouge">.swiftmodule</code> <code class="language-plaintext highlighter-rouge">.swiftdoc</code></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) SwiftyJSON.swift -emit-library -emit-module -module-name SwiftyJSON -v -o libswiftSwiftyJSON.dylib -module-link-name swiftSwiftyJSON
</code></pre></div></div>

<h4 id="生成-o">生成 <code class="language-plaintext highlighter-rouge">.o</code></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xcrun swift -sdk $(xcrun --show-sdk-path --sdk macosx) -c SwiftyJSON.swift -parse-as-library -module-name SwiftyJSON -v -o SwiftyJSON.o
</code></pre></div></div>

<h4 id="生成-a">生成 <code class="language-plaintext highlighter-rouge">.a</code></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ar rvs libswiftSwiftyJSON.a SwiftyJSON.o
</code></pre></div></div>

<p>大功告成。</p>

<p>同时应该也可以用 <code class="language-plaintext highlighter-rouge">lipo</code> 来合成不同平台下的 <code class="language-plaintext highlighter-rouge">.a</code> 链接库。</p>

<h3 id="使用">使用</h3>

<p>和静态链接库类似，需要 <code class="language-plaintext highlighter-rouge">-I</code> 包含 <code class="language-plaintext highlighter-rouge">.swiftmodule</code> 所在目录， <code class="language-plaintext highlighter-rouge">-L</code> 包含 <code class="language-plaintext highlighter-rouge">.a</code> 所在目录。</p>

<p>如果动态链接库和静态链接库两者同时存在，可以依靠不同目录来区分。</p>

<h2 id="你丫闲的">你丫闲的！</h2>

<p>可能不少人要群嘲，你这意义是啥。你丫闲的。</p>

<p>其实在分发 library 的时候，很多时候我们需要二进制分发，希望别人可以方便地使用。这种情况下，静态链接更佳（虽然新的 iOS 8 支持动态链接，但是看起来是基于 Framework 的，略复杂些。）</p>

<p>甚至我们可以用 <code class="language-plaintext highlighter-rouge">lipo</code> 创建全平台可用的静态链接库。多赞。</p>

<h2 id="补充">补充</h2>

<p>多个 Swift 文件可以分别编译为 <code class="language-plaintext highlighter-rouge">.o</code> 然后用 <code class="language-plaintext highlighter-rouge">ar</code> 合并。</p>

<p>对于 CocoaPods ，也许可以按照这个逻辑将 Swift 模块暴露出去。需要多加一个参数 <code class="language-plaintext highlighter-rouge">-emit-objc-header</code> （以及 <code class="language-plaintext highlighter-rouge">-emit-objc-header-path</code>）即可。</p>

<h2 id="参考文献">参考文献</h2>

<ul>
  <li>我的另一篇 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module System of Swift (简析 Swift 的模块系统)</a></li>
  <li><a href="http://andelf.github.io/blog/2014/06/23/use-cocoapods-with-swift/">Use CocoaPods With Swift (在 Swift 中使用 CocoaPods）</a></li>
</ul>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[声明： 转载注明我或者 SwiftChina, 请在方便的情况下情尽量告知. weibo]]></summary></entry><entry><title type="html">Use CocoaPods with Swift (在 Swift 中使用 CocoaPods）</title><link href="https://andelf.github.io/blog/2014/06/23/use-cocoapods-with-swift/" rel="alternate" type="text/html" title="Use CocoaPods with Swift (在 Swift 中使用 CocoaPods）" /><published>2014-06-23T12:15:39+00:00</published><updated>2020-11-16T07:41:32+00:00</updated><id>https://andelf.github.io/blog/2014/06/23/use-cocoapods-with-swift</id><content type="html" xml:base="https://andelf.github.io/blog/2014/06/23/use-cocoapods-with-swift/"><![CDATA[<p>声明： 转载注明我或者 SwiftChina 。请在方便的情况下情尽量告知. <a href="http://weibo.com/234632333">weibo</a></p>

<p>本文的发现基于个人研究。请尊重原创。已授权 CocoaChina 转载个人文章。</p>

<p>本文介绍如何在 Swift 项目中使用 CocoaPods 。如果你已经精通 Bridging Header 的方法，请直接跳到 “扩展 CocoaPods” 一节。</p>

<h2 id="什么是-cocoapods">什么是 CocoaPods</h2>

<blockquote>
  <p>CocoaPods is the dependency manager for Objective-C projects.
It has thousands of libraries and can help you scale your projects elegantly. <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></p>
</blockquote>

<p>从介绍看，它是主要给 Objective-C 项目用的，但是我们可以很容易地混合 Objective-C 和 Swift 到同个项目，从而利用大量的 CocoaPods 库和 Swift 漂亮舒服的语法。</p>

<p>作为 iOS 开发新手，一定是要紧跟前人脚步，学习使用 CocoaPods 。</p>

<h2 id="基础用法">基础用法</h2>

<p>这里简单略过，请参考其他无数的文章。</p>

<h3 id="安装">安装</h3>

<p>系统默认安装，可以参考其他教程<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup> 。在命令行下执行。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo gem install cocoapods
</code></pre></div></div>

<p>我的环境是 HomeBrew</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 添加 taobao Mirror 不然被墙掉没办法下载
gem sources -a http://ruby.taobao.org/
# 安装
gem install cocoapods
# 更新命令
rbenv rehash
# 执行
pod
# 此时一般会下载官方的所有 PodSpec 库，也可以用 pod setup 初始化环境
</code></pre></div></div>

<p>本文不打算在安装部分耗费太多时间。希望看到这里保证你的命令行下有可用的 <code class="language-plaintext highlighter-rouge">pod</code> 命令。</p>

<h3 id="使用">使用</h3>

<p>假设我们已经有个项目，叫 ProjName ，需要使用一些注明的 CocoaPods 库，比如 AFNetworking<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>.</p>

<p>首先，命令行 cd 到我们的项目目录，一般 ls 命令会看到如下几个文件夹：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ProjName
ProjName.xcodeproj
ProjNameTests
</code></pre></div></div>

<p>赞，就是这里，创建一个 <code class="language-plaintext highlighter-rouge">Podfile</code> 文本文件，写入如下内容</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>platform :ios, "8.0"
pod "AFNetworking", "~&gt; 2.0"
</code></pre></div></div>

<p>一般这么简单的文件都是直接 nano 写。 :)</p>

<p>直接创建 <code class="language-plaintext highlighter-rouge">Podfile</code> ， CocoaPods 会创建一个项目同名的 WorkSpace ，然后添加一个叫 Pods 的项目，这个项目编译结果是一个叫 <code class="language-plaintext highlighter-rouge">libPods.a</code>的链接库，
它会添加到我们之前的 ProjName 项目中作为编译依赖。</p>

<p>当然，通过命令行执行 <code class="language-plaintext highlighter-rouge">pod init</code> 也可以自动创建 <code class="language-plaintext highlighter-rouge">Podfile</code>，而且可以自动分析当前项目的 target ，相对来说更好，也更优雅。具体请参考官方手册。这样的好处是更细致，还可以区分多个子项目子 target 。原理大同小异。</p>

<p>然后接下来，命令行执行 <code class="language-plaintext highlighter-rouge">open ProjName.xcworkspace</code>，注意这个可不是 <code class="language-plaintext highlighter-rouge">.xcodeproj</code>，这个是 CocoaPods 为我们创建的一个 WorkSpace ，包含我们之前的项目，和 Pods 依赖。</p>

<p>开始编码过程。直接在代码里调用，比如写在某个按钮的 <code class="language-plaintext highlighter-rouge">@IBAction</code> 里：</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">let</span> <span class="n">manager</span> <span class="k">=</span> <span class="nc">AFHTTPRequestOperationManager</span><span class="o">()</span>
        <span class="n">let</span> <span class="n">url</span> <span class="k">=</span> <span class="s">"http://api.openweathermap.org/data/2.5/weather"</span>
        <span class="nf">println</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>

        <span class="n">let</span> <span class="n">params</span> <span class="k">=</span> <span class="o">[</span><span class="err">"</span><span class="kt">lat</span><span class="err">"</span><span class="kt">:</span> <span class="err">39</span><span class="kt">.</span><span class="err">26</span>, <span class="err">"</span><span class="kt">lon</span><span class="err">"</span><span class="kt">:</span> <span class="err">41</span><span class="kt">.</span><span class="err">03</span>, <span class="err">"</span><span class="kt">cnt</span><span class="err">"</span><span class="kt">:</span><span class="err">0</span><span class="o">]</span>
        <span class="nf">println</span><span class="o">(</span><span class="n">params</span><span class="o">)</span>

        <span class="nv">manager</span><span class="o">.</span><span class="py">GET</span><span class="o">(</span><span class="n">url</span><span class="o">,</span>
            <span class="n">parameters</span><span class="k">:</span> <span class="kt">params</span><span class="o">,</span>
            <span class="n">success</span><span class="k">:</span> <span class="o">{</span> <span class="o">(</span><span class="kt">operation:</span> <span class="kt">AFHTTPRequestOperation!</span><span class="o">,</span>
                        <span class="kt">responseObject:</span> <span class="kt">AnyObject!</span><span class="o">)</span> <span class="kt">in</span>
                <span class="nf">println</span><span class="o">(</span><span class="s">"JSON: "</span> <span class="o">+</span> <span class="nv">responseObject</span><span class="o">.</span><span class="py">description</span><span class="o">!)</span>
            <span class="o">},</span>
            <span class="n">failure</span><span class="k">:</span> <span class="o">{</span> <span class="o">(</span><span class="kt">operation:</span> <span class="kt">AFHTTPRequestOperation!</span><span class="o">,</span>
                        <span class="kt">error:</span> <span class="kt">NSError!</span><span class="o">)</span> <span class="kt">in</span>
                <span class="nf">println</span><span class="o">(</span><span class="s">"Error: "</span> <span class="o">+</span> <span class="nv">error</span><span class="o">.</span><span class="py">localizedDescription</span><span class="o">)</span>
            <span class="o">})</span>
</code></pre></div></div>

<p>这里直接抄了 JakeLin 的 SwiftWeather 代码<sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>，就一小段，希望他不会打我。</p>

<h4 id="swift-坑爹了">Swift 坑爹了</h4>

<p>看起来貌似我们已经可以在 Swift 中使用 <code class="language-plaintext highlighter-rouge">AFNetworking</code> 了。结果刚写几句代码一堆类和变量找不到定义，而且坑爹的是很多时候我们只能靠猜测，判断这些 Objective-C 的定义转换成 Swift 定义是什么样子，用起来就是完全靠蒙！</p>

<p>这不科学！</p>

<p>这都三礼拜了，所以大家都摸索出了调用的方法，那就是按照和 Objective-C 代码混编的例子，添加 Bridging Header ！</p>

<h4 id="继续">继续</h4>

<p>之前简单介绍过和  Objective-C 交互的内容<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>，大家可以去围观。</p>

<p>一般说来，你在 Swift 项目新建 Objective-C 类的时候，直接弹出是否创建 Bridge Header 的窗口，点 YES 就是了，这时候一般多出来个 <code class="language-plaintext highlighter-rouge">ProjectName-Bridging-Header.h</code> 。然后删掉这个类， Bridging Header 头文件还在。</p>

<p>在这个 Bridging Header 文件里写入要导入的 CocoaPods 库，就可以在 Swift 中使用了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import &lt;AFNetworking/AFNetworking.h&gt;
</code></pre></div></div>

<p>如果没有自动创建头文件的话，这个配置在项目的 Build Settings 中的 Swift Compiler - Code Generation 子项里。</p>

<p>创建一个头文件，指定为 Bridging Header 也可以。</p>

<p>然后编译，成功执行！</p>

<h4 id="这就完事了">这就完事了？</h4>

<p>实际上，前两天刚写一篇 <a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/">Swift 的模块系统</a> ， 把任意 Objective-C 库当做 Swift Module 是可行的。当时就觉得这个东西应该是可能完全进入 CocoaPods 的，但是在官方 repo 找了下发现，以前有人提过增加 <code class="language-plaintext highlighter-rouge">module.map</code> 支持，结果 CocoaPods 的人认为这个是 llvm 内部特性， issue 被关闭了。<a href="https://github.com/CocoaPods/CocoaPods/issues/2216">#2216</a> 最近又被提起，我在后面提了下 Swift 支持，希望官方靠谱。</p>

<p>所以下面的内容，就是，我们是否可以在 CocoaPods 上加入 <code class="language-plaintext highlighter-rouge">module.map</code> 支持，然后直接在 Swift 中 <code class="language-plaintext highlighter-rouge">import ModuleName</code> ？</p>

<h2 id="扩展-cocoapods">扩展 CocoaPods</h2>

<p>考虑了多种方式，最后选择了 Hook 的方式。如果 Ruby 技术足够好，或许可以直接写个插件。或者直接改官方代码给官方提交。但是实在能力有限。相关的 <code class="language-plaintext highlighter-rouge">module.map</code> 语法参考 llvm 官方手册 <a href="http://clang.llvm.org/docs/Modules.html">Modules – Clang 3.5 documentation</a>。用了最简单的功能。也许遇到复杂的 PodSpec 就不起作用了，但是原理如此，相信小伙伴们已经知道怎么做了。</p>

<p>目前我的 <code class="language-plaintext highlighter-rouge">Podfile</code> 大概是这个样子：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s2">"8.0"</span>
<span class="n">pod</span> <span class="s2">"AFNetworking"</span><span class="p">,</span> <span class="s2">"~&gt; 2.0"</span>
<span class="n">pod</span> <span class="s2">"Baidu-Maps-iOS-SDK"</span><span class="p">,</span> <span class="s2">"~&gt; 2.0"</span>

<span class="n">post_install</span> <span class="k">do</span> <span class="o">|</span><span class="n">installer</span><span class="o">|</span>
  <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">installer</span><span class="p">.</span><span class="nf">sandbox_root</span><span class="si">}</span><span class="s2">/Headers/module.map"</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">fp</span><span class="o">|</span>
    <span class="n">installer</span><span class="p">.</span><span class="nf">pods</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">pod</span><span class="o">|</span>
      <span class="n">normalized_pod_name</span> <span class="o">=</span> <span class="n">pod</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="s1">'-'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
      <span class="n">fp</span><span class="p">.</span><span class="nf">write</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
module </span><span class="si">#{</span><span class="n">normalized_pod_name</span><span class="si">}</span><span class="sh"> [system] {
  umbrella "</span><span class="si">#{</span><span class="n">pod</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="sh">"
  export *
}
</span><span class="no">EOF</span>
      <span class="nb">puts</span> <span class="s2">"Generating Swift Module </span><span class="si">#{</span><span class="n">normalized_pod_name</span><span class="p">.</span><span class="nf">green</span><span class="si">}</span><span class="s2"> for </span><span class="si">#{</span><span class="n">pod</span><span class="si">}</span><span class="s2"> OK!"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">post_install</code> 是 <code class="language-plaintext highlighter-rouge">Podfile</code> 的一种 hook 机制，可以用来加入自定义操作。我在这里的写的逻辑就是，针对所有的 Pod 生成一个 <code class="language-plaintext highlighter-rouge">module.map</code> 文件。
位于 <code class="language-plaintext highlighter-rouge">Pods/Headers/</code>，这个目录被 CocoaPods 自动设置为项目的 Header Search Path 所以不需要额外处理。默认我们的 Swift 文件就找得到。</p>

<p>其中 <code class="language-plaintext highlighter-rouge">normalized_pod_name</code> 用于处理百度地图 API SDK 这一类名字带减号的库，因为他们不能作为 Module Name ，实际上或许有更好的方法来处理。</p>

<h3 id="实际效果">实际效果</h3>

<p>实测发现完全没有问题，直接 <code class="language-plaintext highlighter-rouge">import AFNetworking</code> 或者 <code class="language-plaintext highlighter-rouge">import BaiduMapsiOSSDK</code> 都可以。</p>

<p>而且很不错的一点是，按住 Command 键，然后鼠标点击模块名、类名等，会跳转到 Swift 定义。</p>

<h3 id="坑">坑</h3>

<p>遇到提示 <code class="language-plaintext highlighter-rouge">.pcm</code> 文件 outdate 的情况下需要你删除 <code class="language-plaintext highlighter-rouge">$HOME/Library/Developer/Xcode/DerivedData/ModuleCache</code> 目录，这个目录保存的是预编译模块，类似于预编译头文件。</p>

<p>目前 Swift 还是有很多 BUG 的，调用 <code class="language-plaintext highlighter-rouge">NSObject</code> 也许会让编译器直接 segment fault ，不带任何出错信息。很伤情。此时请第一时间检查语法是否有诡异，其次将所有用到字符串或者 <code class="language-plaintext highlighter-rouge">Optional</code> 的地方都额外用变量处理，避免用字面常量。（个人经验）</p>

<p>如果多次调用 <code class="language-plaintext highlighter-rouge">pod install</code> 并在其中修改过 <code class="language-plaintext highlighter-rouge">Podfile</code>，那么有可能你的项目依赖会乱掉，多了不存在的 <code class="language-plaintext highlighter-rouge">.a</code> 文件到依赖或者多次包含。手工在项目树和项目选项里删除就可以了。此类编译错误都是链接错误。</p>

<h2 id="总结">总结</h2>

<p>本文提出了一种 Bridging Header 之外的使用 CocoaPods 库的方法。利用有限的 Ruby 知识写了个 Hook 。目前测试 OK 。</p>

<h2 id="参考">参考</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="http://cocoapods.org/">CocoaPods Offical Site</a> CocoaPods 官网 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="http://www.cocoachina.com/applenews/devnews/2014/0623/8917.html">CocoaPods - CocoaChina</a> CocoaChina 对 CocoaPods 的介绍 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking - Github</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p><a href="https://github.com/JakeLin/SwiftWeather/blob/master/Swift%20Weather/ViewController.swift">SwiftWeather</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p><a href="http://andelf.github.io/blog/2014/06/11/swift-and-objectivec-interop/">Swift and ObjectiveC Interop (Swift 与 Objective-C 之间的交互)</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>猫·仁波切</name></author><category term="blog" /><category term="swift" /><summary type="html"><![CDATA[声明： 转载注明我或者 SwiftChina 。请在方便的情况下情尽量告知. weibo]]></summary></entry></feed>